"use strict";(self.webpackChunkricalelog=self.webpackChunkricalelog||[]).push([[930],{8842:function(e,n,t){t.r(n),t.d(n,{Head:function(){return g},default:function(){return w}});var a=t(1151),r=t(7294);function l(e){const n=Object.assign({p:"p",h2:"h2",code:"code",a:"a",pre:"pre",h3:"h3",h4:"h4",ul:"ul",li:"li"},(0,a.ah)(),e.components);return r.createElement(r.Fragment,null,r.createElement(n.p,null,"React Native 를 웹뷰 컨테이너로 사용해 웹앱을 구현하고 있다."),"\n",r.createElement(n.p,null,"웹뷰를 사용한 하이브리드앱 구현 시 주의해야 할 점 중 하나는 안드로이드 기기의 백버튼(뒤로가기 버튼)에 대한 처리다. 사람들은 이전 웹페이지로 돌아가길 기대하며 백버튼을 누르지만, React Native 는 웹뷰 내에서의 이전 페이지로 이동하는 것이 아니라 React Native 상의 이전 화면으로 돌아가기 때문이다."),"\n",r.createElement(n.p,null,"만약 웹뷰 화면이 해당 앱의 첫 화면이라면, 백버튼을 눌렀을 때 이전 웹페이지로 가는 것이 아니라 앱이 종료되는 것을 경험할 수 있다. 당연하게도 그것은 개발자가 의도한 사항도, 사용자가 의도한 사항도 아니다."),"\n",r.createElement(n.p,null,"그러면 웹뷰가 있는 화면에서 백버튼을 눌렀을 때 React Native 의 이전 화면이 아닌 웹뷰의 이전 웹페이지가로 가도록 코드를 수정해보자."),"\n",r.createElement(n.h2,null,"1. ",r.createElement(n.code,null,"onNavigationStateChange")),"\n",r.createElement(n.p,null,"React Native WebView 를 사용하고 있다면 ",r.createElement(n.a,{href:"https://github.com/react-native-webview/react-native-webview/blob/master/docs/Reference.md#onnavigationstatechange"},r.createElement(n.code,null,"onNavigationStateChange")," 콜백"),"과 ",r.createElement(n.a,{href:"https://reactnative.dev/docs/backhandler"},r.createElement(n.code,null,"BackHandler")," API"),"를 사용해 이전 웹페이지로 이동하도록 백버튼의 기능을 조정할 수 있다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-js"},'const HomeScreen = (props) => {\n  const ref = useRef();\n  const [navState, setNavState] = useState();\n\n  useEffect(() => {\n    const onPress = () => {\n      if (navState.canGoBack) {\n        // 뒤로 갈 수 있는 상태라면 이전 웹페이지로 이동한다\n        ref.current.goBack();\n        // 기본 뒤로가기 동작을 수행하지 않을 거라면 true 를 리턴한다.\n        return true;\n      } else {\n        // 뒤로 갈 수 없는 상태라면\n        // 다른 원하는 행동을 하면 된다\n        console.log("do something");\n        // 기본 뒤로가기 동작을 수행하지 않을 거라면 true 가 아닌 값을 리턴한다.\n        return false;\n      }\n    };\n\n    // 안드로이드 백버튼이 눌렸을 때 이벤트 리스너를 등록한다.\n    BackHandler.addEventListener("hardwareBackPress", onPress);\n    return () => {\n      BackHandler.removeEventListener("hardwareBackPress", onPress);\n    };\n  }, [navState.canGoBack]);\n\n  return (\n    <WebView\n      // ...\n      ref={ref}\n      // 웹뷰의\n      onNavigationStateChange={setNavState}\n    />\n  );\n};\n')),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"onNavigationStateChange")," 콜백의 첫 번째 인자(",r.createElement(n.code,null,"navState"),")는 웹뷰의 현재 상태가 담긴 객체인데, 해당 객체의 ",r.createElement(n.code,null,"canGoBack")," 값은 현재 웹뷰에서 뒤로가기가 가능한 상태인지를 알려준다 (예를 들어 첫페이지에서는 뒤로 갈 수 없을 것이다. 그런 경우에는 ",r.createElement(n.code,null,"false")," 값을 가진다)."),"\n",r.createElement(n.p,null,"뒤로 갈 수 있다면 ",r.createElement(n.code,null,"ref.current.goBack()"),"메서드를 사용해 이전 페이지로 돌아가고, 그렇지 않다면 필요한 다른 작업을 하면 되겠다."),"\n",r.createElement(n.h2,null,"2. HTML5 History API 대응"),"\n",r.createElement(n.p,null,"하지만 ",r.createElement(n.code,null,"onNavigationStateChange")," 콜백에 문제가 있으니, 바로 ",r.createElement(n.code,null,"pushState()"),", ",r.createElement(n.code,null,"replaceState()")," 등 ",r.createElement(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/History_API"},"HTML5 History API"),"로 추가된 기능으로 페이지 이동을 하면 동작하지 않는다는 것이다. 이는 ",r.createElement(n.code,null,"canGoBack")," 값이 최신화되지 않는다는 뜻이고, 위에서 작성한 코드가 정상적으로 동작할 수 없다는 뜻이다."),"\n",r.createElement(n.p,null,"물론 여기서 주저앉을 수는 없다. 이제 우리는 ",r.createElement(n.a,{href:"https://github.com/react-native-webview/react-native-webview/blob/master/docs/Reference.md#onmessage"},r.createElement(n.code,null,"onMessage")," 콜백"),"과 ",r.createElement(n.a,{href:"https://github.com/react-native-webview/react-native-webview/blob/master/docs/Reference.md#injectjavascriptstr"},r.createElement(n.code,null,"webview.injectJavaScript()")," 메서드"),"를 통해 ",r.createElement(n.code,null,"pushState()"),", ",r.createElement(n.code,null,"replaceState()")," 동작 시 웹뷰의 상태를 받아오도록 할 것이다."),"\n",r.createElement(n.h3,null,"2.1. ",r.createElement(n.code,null,"webview.injectJavaScript()")),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"webview.injectJavaScript()")," 메서드는 웹뷰에 자바스크립트 코드를 삽입할 수 있도록 해주는 메서드이다. 해당 메서드를 통해 ",r.createElement(n.code,null,"pushState()"),"와 ",r.createElement(n.code,null,"replaceState()")," 메서드를 래핑해줄 것이다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-js"},"const INJECTED_CODE = `\n(function() {\n  function wrap(fn) {\n    return function wrapper() {\n      var res = fn.apply(this, arguments);\n      window.ReactNativeWebView.postMessage('navigationStateChange');\n      return res;\n    }\n  }\n\n  history.pushState = wrap(history.pushState);\n  history.replaceState = wrap(history.replaceState);\n  window.addEventListener('popstate', function() {\n    window.ReactNativeWebView.postMessage('navigationStateChange');\n  });\n})();\n\ntrue;\n`;\nconst HomeScreen = (props) => {\n  // ...\n  return (\n    <WebView\n      // ...\n      ref={ref}\n      onLoadStart={() => ref.current.injectJavaScript(INJECTED_CODE)}\n      onNavigationStateChange={setNavState}\n    />\n  );\n};\n")),"\n",r.createElement(n.h4,null,"2.1.1. ",r.createElement(n.code,null,"injectedJavaScript")," props 는 안 되나?"),"\n",r.createElement(n.p,null,"React Native WebView 에는 ",r.createElement(n.code,null,"webview.injectJavaScript()"),"메서드와 비슷한 기능을 하는 ",r.createElement(n.a,{href:"https://github.com/react-native-webview/react-native-webview/blob/master/docs/Reference.md#injectedjavascript"},r.createElement(n.code,null,"injectedJavaScript")," prop"),"도 존재한다. 하지만 결정적인 차이점이 존재하는데, ",r.createElement(n.code,null,"webview.injectJavaScript()"),"는 우리가 원하는 때에만 골라서 코드를 삽입할 수 있지만, ",r.createElement(n.code,null,"injectedJavaScript"),"는 ",r.createElement(n.code,null,"onLoad")," 이벤트가 발생할 때마다 코드를 삽입된다는 것이다."),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"onLoadStart")," 이벤트는 실제 페이지 이동이 일어날 때만 발생하는데 반해 ",r.createElement(n.code,null,"onLoad")," 이벤트는 History API 등으로 로딩이 발생할 때도 발생한다. 때문에 같은 코드가 중복적으로 삽입될 수 있고, 우리는 그러한 현상을 피하기 위해 ",r.createElement(n.code,null,"onLoadStart"),"와 ",r.createElement(n.code,null,"injectJavaScript()")," 메서드를 조합해서 코드를 삽입한다."),"\n",r.createElement(n.p,null,"(단, ",r.createElement(n.code,null,"injectedJavaScriptBeforeContentLoaded")," prop 을 사용하면 위 코드와 거의 동일한 효과를 낼 수 있다.)"),"\n",r.createElement(n.h4,null,"2.1.2. 삽입된 코드는 어떤 코드?"),"\n",r.createElement(n.p,null,"위 코드에는 삽입된 코드가 통문자열로 되어있기 때문에 알아보기 힘들다. 하이라이트된 코드로 다시 살펴보자."),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-js"},'(function () {\n  function wrap(fn) {\n    return function wrapper() {\n      var res = fn.apply(this, arguments);\n      window.ReactNativeWebView.postMessage("navigationStateChange");\n      return res;\n    };\n  }\n\n  history.pushState = wrap(history.pushState);\n  history.replaceState = wrap(history.replaceState);\n  window.addEventListener("popstate", function () {\n    window.ReactNativeWebView.postMessage("navigationStateChange");\n  });\n})();\n\ntrue;\n')),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"pushState()"),"와 ",r.createElement(n.code,null,"replaceState()"),"를 래핑하고 ",r.createElement(n.code,null,"popState")," 이벤트에 리스너를 붙이는 코드라는 것을 알 수 있다. 모든 코드들은 공통적으로 ",r.createElement(n.a,{href:"https://github.com/react-native-webview/react-native-webview/blob/master/docs/Reference.md#postmessagestr"},r.createElement(n.code,null,"ReactNativeWebView.postMessage()")," 메서드"),"를 호출하는 것을 볼 수 있다. 이 메서드가 호출될 때마다 웹뷰는 웹페이지의 상태를 ",r.createElement(n.code,null,"onMessage")," 콜백으로 받아볼 수 있다."),"\n",r.createElement(n.h3,null,"2.2. ",r.createElement(n.code,null,"onMessage")),"\n",r.createElement(n.p,null,"그럼 ",r.createElement(n.code,null,"onMessage")," 콜백도 넣어보자."),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-js"},'const HomeScreen = (props) => {\n  // ...\n  return (\n    <WebView\n      // ...\n      ref={ref}\n      onLoadStart={() => ref.current.injectJavaScript(INJECTED_CODE)}\n      onNavigationStateChange={setNavState}\n      onMessage={({ nativeEvent }) => {\n        if (nativeEvent.data === "navigationStateChange") {\n          setNavState(nativeEvent);\n        }\n      }}\n    />\n  );\n};\n')),"\n",r.createElement(n.p,null,"됐다. 이제 ",r.createElement(n.code,null,"pushState()"),", ",r.createElement(n.code,null,"replaceState()"),"도 놓치지 않게 되었다."),"\n",r.createElement(n.h2,null,"3. 전체 코드"),"\n",r.createElement(n.p,null,"(아래 코드는 이해를 돕기 위한 의사코드로, 실제로는 동작하지 않을 수도 있다)"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-js"},"const INJECTED_CODE = `\n(function() {\n  function wrap(fn) {\n    return function wrapper() {\n      var res = fn.apply(this, arguments);\n      window.ReactNativeWebView.postMessage('navigationStateChange');\n      return res;\n    }\n  }\n\n  history.pushState = wrap(history.pushState);\n  history.replaceState = wrap(history.replaceState);\n  window.addEventListener('popstate', function() {\n    window.ReactNativeWebView.postMessage('navigationStateChange');\n  });\n})();\n\ntrue;\n`;\n\nconst HomeScreen = (props) => {\n  const ref = useRef();\n  const [navState, setNavState] = useState();\n\n  useEffect(() => {\n    const onPress = () => {\n      if (navState.canGoBack) {\n        // 뒤로 갈 수 있는 상태라면 이전 웹페이지로 이동한다\n        ref.current.goBack();\n      } else {\n        // 뒤로 갈 수 없는 상태라면\n        // 다른 원하는 행동을 하면 된다\n      }\n    };\n\n    // 안드로이드 백버튼이 눌렸을 때 이벤트 리스너를 등록한다.\n    BackHandler.addEventListener(\"hardwareBackPress\", onPress);\n    return () => {\n      BackHandler.removeEventListener(\"hardwareBackPress\", onPress);\n    };\n  }, [navState.canGoBack]);\n\n  return (\n    <WebView\n      // ...\n      ref={ref}\n      onLoadStart={() => ref.current.injectJavaScript(INJECTED_CODE)}\n      onNavigationStateChange={setNavState}\n      onMessage={({ nativeEvent }) => {\n        if (nativeEvent.data === \"navigationStateChange\") {\n          setNavState(nativeEvent);\n        }\n      }}\n    />\n  );\n};\n")),"\n",r.createElement(n.h2,null,"4. 참고"),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,r.createElement(n.a,{href:"https://github.com/react-native-webview/react-native-webview"},"React Native WebView")),"\n",r.createElement(n.li,null,r.createElement(n.a,{href:"https://github.com/react-native-webview/react-native-webview/issues/24#issuecomment-483956651"},"MIGRATED: iOS WebView doesn't support hash url change. The onNavigationStateChange listener will not be called when url hash changes. (#20447) #24")),"\n"))}var c,o=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?r.createElement(n,e,r.createElement(l,e)):l(e)},i=t(1880),s=t(1883),u=t(3723),m=t(1858),p=t(3904),d=t(891),E=t(5534);const v=e=>{let{data:n,children:t}=e;const{title:a,date:l,tags:c,heroImage:o,heroImageAlt:i}=n.mdx.frontmatter,p=o?(0,u.c)(o):null;return r.createElement(m.Z,null,r.createElement("h1",null,a),r.createElement(h,null,c.map((e=>r.createElement("li",{key:e},r.createElement(s.rU,{to:"/tags/"+e},e))))),r.createElement("div",null,l),!!p&&r.createElement(u.G,{image:p,alt:null!=i?i:""}),r.createElement(E.Z,null,t))},h=d.ZP.ul(c||(c=(0,i.Z)(["\n  display: flex;\n  flex-direction: row;\n  flex-wrap: wrap;\n  gap: ","px;\n\n  margin: 0;\n  padding: 0;\n  list-style: none;\n\n  > li {\n    padding: ","px ","px\n      0px;\n    border-radius: 2px;\n\n    background-color: ",";\n    color: ",";\n\n    > a {\n      text-decoration: none;\n    }\n  }\n"])),(e=>e.theme.dimens.gutter),(e=>e.theme.dimens.thin),(e=>e.theme.dimens.gutter),(e=>e.theme.colors.tag),(e=>e.theme.colors.onTag)),g=e=>{var n,t;let{data:a}=e;const{frontmatter:{title:l,slug:c,heroImage:o},excerpt:i}=a.mdx,s=o?(0,u.c)(o):null;return r.createElement(p.Z,{title:l,description:i,path:"posts/"+c,thumbnail:null==s||null===(n=s.images)||void 0===n||null===(t=n.fallback)||void 0===t?void 0:t.src,ogType:"article"})};function w(e){return r.createElement(v,e,r.createElement(o,e))}}}]);
//# sourceMappingURL=component---src-pages-posts-mdx-frontmatter-slug-tsx-content-file-path-users-kangseong-workspace-private-ricalelog-posts-210821-react-native-webview-android-back-button-index-mdx-3fef7fb5eb1cd65a69a7.js.map