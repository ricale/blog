<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[RSS Feed of tech blog by ricale]]></title><description><![CDATA[기술 블로그 by ricale]]></description><link>http://github.com/dylang/node-rss</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 24 Jan 2023 08:07:54 GMT</lastBuildDate><author><![CDATA[ricale]]></author><item><title><![CDATA[읽은 글들 (~23.1.24)]]></title><description><![CDATA[메일링, 블로그, 구글링 등을 통해 읽은 글들을 간단히 리뷰하는 글이다.]]></description><link>https://ricale.kr/blogposts/230124-read-writings</link><guid isPermaLink="false">https://ricale.kr/blogposts/230124-read-writings</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Mon, 23 Jan 2023 15:00:00 GMT</pubDate><content:encoded>
## React

### [(번역) 리액트 상호 작용 시간 4배 향상하기](https://velog.io/@superlipbalm/improving-react-interaction-times-by-4x?utm_source=substack&amp;utm_medium=email)

원문 저자가 본인의 서비스에서 React 성능 문제를 개선했던 경험에 대한 글이다. 대체로 AG Grid 라는 라이브러리에 의한 과도한 리렌더링으로 인해 발생하는 이슈들이었다. 크롬 개발자 도구와 리엑트 프로파일러를 이용해 이슈를 추적하고 확인한 뒤 해결하는 과정이 재미있고 유익하다.

### [The Ugliest Pattern In React](https://sebastiancarlos.com/the-ugliest-pattern-in-react-%EF%B8%8F-adjusting-state-in-response-to-rendering-e8f651fa958b)

[React 공식 문서](https://beta.reactjs.org/reference/react/useState#storing-information-from-previous-renders)에서 추천한 아래 코드를 비판하는 글이다.

```jsx
function CountLabel({ count }) {
  const [prevCount, setPrevCount] = useState(count);
  const [trend, setTrend] = useState(null);
  if (prevCount !== count) {
    setPrevCount(count);
    setTrend(count &gt; prevCount ? &quot;increasing&quot; : &quot;decreasing&quot;);
  }
  return (
    &lt;&gt;
      &lt;h1&gt;{count}&lt;/h1&gt;
      {trend &amp;&amp; &lt;p&gt;The count is {trend}&lt;/p&gt;}
    &lt;/&gt;
  );
}
```

`useEffect` 를 사용해서 prop 의존적인 state 를 수정할 경우 자식 컴포넌트들도 두 번 더 렌더링되므로, 위 방법을 사용하라는 것이었다.

이에 대해 저자는 가독성도 없고 순수 함수 규칙마저 어긴다며 최악이라고 말하고 있다.

음.. 나도 쓰고 싶지 않은 코드다.

## JavaScript

### [Promise는 왜 취소가 안 될까?](https://tech.kakao.com/2023/01/11/promise-cancelation-in-javascript/)

Promise 취소 기능의 표준 지정과 관련된 역사와, 본인이 맡은 서비스에서는 취소 기능을 어떻게 구현했는지 설명하는 글. 쉽게 잘 읽힌다.

### [Reasons to avoid Javascript CDNs](https://blog.wesleyac.com/posts/why-not-javascript-cdn)

웹페이지/웹앱의 자바스크립트 파일을 저장할 곳으로 CDN 사용을 피해야 하는 이유에 대해 설명하는 글.

분명 CDN은 쉽게 사용할 수 있고 빠르다고들 말하긴 하지만, 그 못지 않은 단점이 있다고 말한다. 요약하면 아래와 같다.

- 프라이버시: CDN 서비스들은 개인이 어느 사이트들에 방문했는지 추적할 수 있다.
- 속도: 대체로 CDN 이 빠르지만 일부 경우에는 오히려 CDN 이 느릴 수 있다. (특히 자바스크립 파일 용량이 작을 경우)
- 보안: CDN 을 통한 해커의 공격에 노출될 수 있다. [SRI](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity) 로 보안이 어느정도 해결 가능하지만, 이는 한 라이브러리를 여러 파일로 나눠 관리할 때 제대로 적용되지 않는 허점이 있다.
- 시스템적 위험: (AWS 나 cloudflare 가 그랬던 것처럼) CDN 서비스가 장애에 빠지면 전세계 웹의 큰 부분이 다운될 수 있다.

그리고 작성자는 특별한 이유가 없다면 CDN 보다는 웹페이지와 같은 서버에서 자바스크립트 파일을 관리하는 게 좋다고 글을 마무리한다.

자세한 내용은 본문을 참고하자.

### [[번역] 당신이 모르는 자바스크립트의 메모리 누수의 비밀](https://ui.toast.com/posts/ko_20210611)

메모리 누수가 생기는 대표적인 상황들을 크롬 개발자도구로 확인해보는 글이다. 글에서 확인하는 대표적인 메모리 누수 케이스는 아래와 같다.

- 클로저
- 전역변수
- DOM 노드 삭제
- `console` 모듈
- 타이머

메모리 누수 케이스도 케이스지만 크롬 개발자도구의 기능으로 메모리 누수를 추적하는 것이 매우 유익하다.

## CSS

### [3D in CSS](https://garden.bradwoods.io/notes/css/3d)

CSS 의 `perspective` 와 `transform` 을 사용해서 3D 애니메이션을 적용하는 방법에 대한 글. 내용도 내용이지만, (값을 즉석에서 바꿔가며 확인해볼 수 있는) 예제들이 훌륭하다.
</content:encoded></item><item><title><![CDATA[Gatsby 블로그 만들기 4 - 임시글 기능 구현]]></title><description><![CDATA[이전 글들에서는 Gatsby 기본 기능을 구현을 위한 튜토리얼을 소개했고 태그 기능을 구현했고, MDX 글 안에 인라인 이미지와 테이블을 삽입했으며, 시리즈 기능도 만들어보았다. 이번에는 임시글 기능을 구현해보자.

임시글은 작성자에게는 보이고 다른…]]></description><link>https://ricale.kr/blogposts/230122-gatsby-4-drafts</link><guid isPermaLink="false">https://ricale.kr/blogposts/230122-gatsby-4-drafts</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Sat, 21 Jan 2023 15:00:00 GMT</pubDate><content:encoded>
이전 글들에서는 Gatsby [기본 기능을 구현을 위한 튜토리얼을 소개했고 태그 기능을 구현](https://ricale.kr/blog/posts/230111-gatsby-1/)했고, [MDX 글 안에 인라인 이미지와 테이블을 삽입](https://ricale.kr/blog/posts/230112-gatsby-2/)했으며, [시리즈 기능도 만들어](https://ricale.kr/blog/posts/230119-gatsby-3-series/)보았다.

이번에는 임시글 기능을 구현해보자.

# 1. 개요

임시글은 작성자에게는 보이고 다른 사람들에게는 보이지 않는 비공개 글을 의미한다. Gatsby 에서 기본 제공하는 기능은 아니므로, 약간의 작업이 필요하다.

# 2. 구현

먼저 임시글들은 별도의 디렉토리에 모으고, 해당 디렉토리에 있는 글은 개발 환경에서만 보이고 프로덕션 환경에서는 보이지 않도록 할 것이다. 그리고 개발환경에서만 보이는 임시글 목록 페이지도 추가해서 이미 공개된 글들과 목록을 분리할 것이다.

## 2.1. 개발 환경에서만 보이는 임시글 디렉토리 환경 설정

`gatsby-config.ts` 에 아래 설정을 추가하자

```ts
// gatsby-config.ts

// 개발 환경인지 확인하는 플래그
const isDevelopment = process.env.NODE_ENV === &quot;development&quot;;

const config: GatsbyConfig = {
  // ...
  plugins: [
    // ...
    // 개발환경이면 &quot;gatsby-source-filesystem&quot; 플러그인으로
    // 임시글 폴더의 파일들도 읽을 수 있도록 적용
    ...(isDevelopment
      ? [
          {
            resolve: &quot;gatsby-source-filesystem&quot;,
            options: {
              name: &quot;drafts&quot;,
              path: `${__dirname}/drafts`,
            },
          },
        ]
      : []),
  ],
};

export default config;
```

이제 `drafts` 디렉토리에 mdx 파일을 추가하면 Gatsby 가 해당 파일도 GraphQL 쿼리로 읽어올 수 있게 된다. 프로덕션 환경이면 해당 설정이 적용되지 않으므로 `npm run deploy` 를 했을 때는 `drafts` 디렉토리의 글들은 배포되지 않는다.

## 2.2. 임시글 목록 페이지 구현

아쉽게도 GraphQL 쿼리로는 mdx 파일이 속한 디렉토리까지는 알 수 없다. GraphQL 쿼리로 임시글만 가져오려면 mdx 의 `frontmatter` 영역에 이 글이 임시글이라는 정보를 남겨야 한다.

임시글을 위한 별도의 플래그를 만드는 방법도 있지만, 여기서는 작성일 필드를 빈 칸으로 두는 방법을 선택했다.

```
---
title: &quot;React Native 디버거 에러&quot;
date: &quot;&quot;
slug: &quot;react-native-debugger-error&quot;
tags: [&quot;iOS&quot;, &quot;react native&quot;, &quot;빌드 에러&quot;, &quot;안드로이드&quot;, &quot;에러&quot;]
series: &quot;React Native 빌드 에러&quot;
---
```

기존 글목록 페이지에서 임시글은 가져오지 쿼리를 수정하자.

```tsx
// src/pages/posts/index.tsx

//...

export const query = graphql`
  query {
    allMdx(
      # 아래처럼 filter 를 추가하자
      filter: { frontmatter: { date: { ne: &quot;&quot; } } }
      sort: { frontmatter: { date: DESC } }
    ) {
      # ...
    }
  }
`;

// ...
```

그리고 임시글 목록 페이지를 만들자.

```tsx
// src/pages/drafts/index.tsx

// ...

function DraftsPage({ data }: PageProps&lt;DraftsPageData&gt;) {
  const drafts = data.allMdx.nodes;
  return (
    &lt;Layout&gt;
      &lt;ListPageHeader title=&quot;임시글&quot; note={drafts.length} /&gt;
      &lt;PostList data={drafts} /&gt;
    &lt;/Layout&gt;
  );
}

export const query = graphql`
  query {
    allMdx(
      filter: { frontmatter: { date: { eq: &quot;&quot; } } }
      sort: { frontmatter: { date: DESC } }
    ) {
      # ...
    }
  }
`;

// ...
```

## 2.3. 임시글 링크를 메뉴에 추가

마지막으로 메뉴 컴포넌트에 (개발환경일 경우) 임시글 링크도 보이도록 추가하자.

```tsx
// src/components/Layout.tsx

// ...

const isDevelopment = process.env.NODE_ENV === &quot;development&quot;;

const menuItems = [
  { path: &quot;/posts&quot;, title: &quot;글&quot; },
  { path: &quot;/series&quot;, title: &quot;시리즈&quot; },
  { path: &quot;/tags&quot;, title: &quot;태그&quot; },
  // 개발 환경일 경우에만 임시글 목록에 보이도록 추가하자.
  ...(isDevelopment ? [{ path: &quot;/drafts&quot;, title: &quot;임시글&quot; }] : []),
];

function Layout({ children }: LayoutProps) {
  // ...
  return (
    &lt;ThemeProvider theme={normalTheme}&gt;
      &lt;GlobalStyle /&gt;
      &lt;Container&gt;
        &lt;Header&gt;
          {/* ... */}
          &lt;nav&gt;
            &lt;ul&gt;
              {menuItems.map((item) =&gt; (
                &lt;li key={item.path}&gt;
                  &lt;Link to={item.path}&gt;{item.title}&lt;/Link&gt;
                &lt;/li&gt;
              ))}
            &lt;/ul&gt;
          &lt;/nav&gt;
        &lt;/Header&gt;
        &lt;main&gt;{children}&lt;/main&gt;
      &lt;/Container&gt;
    &lt;/ThemeProvider&gt;
  );
}

// ...

export default Layout;
```

## 2.4. 상세 코드

위 코드 조각들은 생략된 부분이 있으므로, 코드 전문을 보고 싶다면 아래를 참고하자.

- [gatsby-config.ts](https://github.com/ricale/blog/blob/23dcb03ea1ceb305a3b73771d2a0962ffd871d5c/gatsby-config.ts)
- [src/pages/posts/index.tsx](https://github.com/ricale/blog/blob/23dcb03ea1ceb305a3b73771d2a0962ffd871d5c/src/pages/posts/index.tsx)
- [src/pages/drafts/index.tsx](https://github.com/ricale/blog/blob/23dcb03ea1ceb305a3b73771d2a0962ffd871d5c/src/pages/drafts/index.tsx)
- [src/components/Layout.tsx](https://github.com/ricale/blog/blob/23dcb03ea1ceb305a3b73771d2a0962ffd871d5c/src/components/Layout.tsx)

# 3. 다음

이로서 시리즈 기능을 구현해보았다. 다음으로 구현 및 정리할 것들은 아래와 같다.

- 댓글 기능 구현
- 코드블록 문법 하이라이팅 기능 구현
- 글의 목차 기능 구현
- GitHub Pages 배포
- 등등

순서는 미정이다.

# 4. 참고

- [Render draft posts locally in Gatsby](https://clubmate.fi/render-draft-posts-locally)
</content:encoded></item><item><title><![CDATA[React Native 빌드 에러 (5)]]></title><description><![CDATA[iOS 1. Command ValidateEmbeddedBinary failed with a nonzero exit code

iOS 에서 발생하는 빌드 에러다. React Native Firebase 의 iOS Notification Images 를…]]></description><link>https://ricale.kr/blogposts/230121-react-native-build-error-5</link><guid isPermaLink="false">https://ricale.kr/blogposts/230121-react-native-build-error-5</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Fri, 20 Jan 2023 15:00:00 GMT</pubDate><content:encoded>
## iOS

### 1. Command ValidateEmbeddedBinary failed with a nonzero exit code

iOS 에서 발생하는 빌드 에러다. React Native Firebase 의 [iOS Notification Images](https://rnfirebase.io/messaging/ios-notification-images) 를 적용한 후 간헐적으로 발생한다.

구글링하면 [이 글](https://stackoverflow.com/questions/68760126/m1-command-validateembeddedbinary-failed-with-a-nonzero-exit-code-archiving-er)이 가장 위에 나오는데 우리랑 그다지 맞는 상황은 아닌 것 같다.

왜 위에 &quot;간헐적으로 발생&quot;한다고 썼냐면, 정말로 발생할 때도 있고 발생하지 않을 때도 있기 때문이다. 지금까지는 _재부팅_ 직후에는 항상 에러 없이 성공했다. 그러니 해당 에러를 본다면 재부팅을 해보자. (..)

### 2. Library not loaded: /opt/homebrew/opt/icu4c/lib/libicui18n.70.dylib

에러 전문은 다음과 같다

```sh
dyld[4737]: Library not loaded: /opt/homebrew/opt/icu4c/lib/libicui18n.70.dylib
  Referenced from: \&lt;577D4D03-3CB0-3278-8BEF-121EFA8ABCBE\&gt; /opt/homebrew/Cellar/node/18.2.0/bin/node
  Reason: tried: &apos;/opt/homebrew/opt/icu4c/lib/libicui18n.70.dylib&apos; (no such file), &apos;/System/Volumes/Preboot/Cryptexes/OS/opt/homebrew/opt/icu4c/lib/libicui18n.70.dylib&apos; (no such file), &apos;/opt/homebrew/opt/icu4c/lib/libicui18n.70.dylib&apos; (no such file), &apos;/usr/local/lib/libicui18n.70.dylib&apos; (no such file), &apos;/usr/lib/libicui18n.70.dylib&apos; (no such file, not in dyld cache), &apos;/opt/homebrew/Cellar/icu4c/71.1/lib/libicui18n.70.dylib&apos; (no such file), &apos;/System/Volumes/Preboot/Cryptexes/OS/opt/homebrew/Cellar/icu4c/71.1/lib/libicui18n.70.dylib&apos; (no such file), &apos;/opt/homebrew/Cellar/icu4c/71.1/lib/libicui18n.70.dylib&apos; (no such file), &apos;/usr/local/lib/libicui18n.70.dylib&apos; (no such file), &apos;/usr/lib/libicui18n.70.dylib&apos; (no such file, not in dyld cache)
/Users/ricale/Library/Developer/Xcode/DerivedData/Frism-dgzfyqoaoiwbhpetiazaoylzkbxf/Build/Intermediates.noindex/Frism.build/Debug-iphoneos/Frism.build/Script-00DD1BFF1BD5951E006B06BC.sh: line 7: 4737 Abort trap: 6 ../node_modules/@sentry/cli/bin/sentry-cli react-native xcode ../node_modules/react-native/scripts/react-native-xcode.sh
Command PhaseScriptExecution failed with a nonzero exit code
```

icu4c 라는 라이브러리에 대해 현재 NPM 에서 사용하려는 버전과 실제 내 컴퓨터에 설치된 버전이 달라서 생기는 버그라고 한다. 최근에 OS 를 업데이트했는데 그 때 뭔가 영향을 끼친 것 같다. 방법은 npm 의 버전을 올리거나 npm 이 현재 설치된 버전의 icu4u 를 사용하도록 해주면 된다고 한다. 나는 전자를 선택했다.

```sh
$ brew upgrade npm
```

#### 참고

- [[react 설치 중 오류] dyld: Library not loaded: /usr/local/opt/icu4c/lib/libicui18n.67.dylib](https://choisee02.tistory.com/91)
- [Node.js와 npm 실행시 icu4c 관련 오류 해결하기](http://paikwiki.github.io/2018/06/icu4c-issue-of-nodejs)
- [dyld: Library not loaded: /usr/local/opt/icu4c/lib/libicui18n.62.dylib error running php after installing node with brew on Mac](https://stackoverflow.com/questions/53828891/dyld-library-not-loaded-usr-local-opt-icu4c-lib-libicui18n-62-dylib-error-run)
</content:encoded></item><item><title><![CDATA[Gatsby 블로그 만들기 3 - 시리즈 기능 구현]]></title><description><![CDATA[이전 글에서는 Gatsby 기본 기능을 구현을 위한 튜토리얼을 소개했고 태그 기능을 구현했으며, MDX 글 안에 인라인 이미지와 테이블을 삽입했다. 오늘은 시리즈 기능을 구현해보자.

시리즈 기능은 여러 글들을 하나로 묶어주는 기능이다. 카테고리와…]]></description><link>https://ricale.kr/blogposts/230119-gatsby-3-series</link><guid isPermaLink="false">https://ricale.kr/blogposts/230119-gatsby-3-series</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Wed, 18 Jan 2023 15:00:00 GMT</pubDate><content:encoded>
이전 글에서는 Gatsby [기본 기능을 구현을 위한 튜토리얼을 소개했고 태그 기능을 구현](https://ricale.kr/blog/posts/230111-gatsby-1/)했으며, [MDX 글 안에 인라인 이미지와 테이블을 삽입](https://ricale.kr/blog/posts/230112-gatsby-2/)했다.

오늘은 시리즈 기능을 구현해보자.

# 1. 개요

시리즈 기능은 여러 글들을 하나로 묶어주는 기능이다. 카테고리와 유사한 기능이지만, 같은 종류의 글을 묶는 카테고리와 달리 이어지는 글들을 하나로 묶어주는 기능이라고 보면 된다. 이전에 사용하던 블로그 서비스인 velog 에서 해당 기능을 확인할 수 있다.

![](./velog-screenshot.png)

Gatsby 의 GraphQL 과 mdx, gatsby-node 기능을 사용해 시리즈를 구현해보겠다.

# 2. 구현

구현을 위해 해야 할 일은 아래와 같다.

1. mdx 파일에 시리즈 정보 넣기
2. 시리즈 목록 페이지 구현
3. 시리즈 상세 페이지 구현
4. 글 상세 페이지에 해당 글이 속한 시리즈의 글 목록 추가

## 2.1. mdx `frontmatter` 에 시리즈 필드 추가

mdx 파일에 시리즈를 위한 필드를 추가하자. 이름은 `series` 로 하겠다. 이제 같은 시리즈로 포함시킬 글들은 `series` 필드에 같은 이름을 넣어주면 된다.

```
---
title: # ...
date: # ...
slug: # ...
tags: # ...
series: &quot;Gatsby 블로그 만들기&quot;
---
```

## 2.2. 시리즈 목록 페이지 구현

시리즈 목록을 위한 페이지를 `src/pages/series/index.tsx` 에 만들어보자.

### 2.2.1. 기본 페이지 추가

기본 구현은 [태그 목록을 위한 페이지 구현](https://ricale.kr/blog/posts/230111-gatsby-1/) 방법과 같다.

```tsx
// src/pages/series/index.tsx

import * as React from &quot;react&quot;;
import { graphql, Link, PageProps } from &quot;gatsby&quot;;
import Layout from &quot;../../components/Layout&quot;;
import Seo from &quot;../../components/Seo&quot;;

type SeriesPageData = {
  allMdx: {
    group: {
      fieldValue: string;
      totalCount: number;
    }[];
  };
};
const SeriesPage = ({ data }: PageProps&lt;SeriesPageData&gt;) =&gt; {
  const series = data.allMdx.group;
  return (
    &lt;Layout&gt;
      &lt;h1&gt;시리즈&lt;/h1&gt;
      &lt;ul&gt;
        {series.map((sr) =&gt; (
          &lt;li key={sr.fieldValue}&gt;
            &lt;Link to={`/series/${sr.fieldValue}/`}&gt;{`${sr.fieldValue}`}&lt;/Link&gt;{&quot; &quot;}
            &lt;small&gt;{sr.totalCount}&lt;/small&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/Layout&gt;
  );
};

export const query = graphql`
  query {
    allMdx(limit: 2000) {
      group(field: { frontmatter: { series: SELECT } }) {
        fieldValue
        totalCount
      }
    }
  }
`;

export const Head = () =&gt; &lt;Seo title=&quot;시리즈 목록&quot; /&gt;;

export default SeriesPage;
```

이렇게 구현하면 시리즈 목록 페이지가 완성된다.

하지만 완성된 모습이 다소 허전하다. velog 의 시리즈 목록 페이지를 보면 해당 시리즈의 썸네일과 마지막 작성글 날짜까지 보인다. 하지만 우리가 만든 페이지에는 시리즈들의 이름과 글 수만 덩그러니 있을 뿐이다.

우리도 썸네일과 마지막 작성글 날짜를 추가해보자.

### 2.2.2. GraphQL 쿼리 수정

쿼리에 `edges` 를 추가하자. 이렇게 하면 시리즈별로 시리즈에 속한 글들을 (모두) 가져올 수 있다.

```tsx
// src/pages/series/index.tsx

export const query = graphql`
  query {
    allMdx(limit: 2000) {
      group(field: { frontmatter: { series: SELECT } }) {
        fieldValue
        totalCount
        edges {
          node {
            frontmatter {
              title
              originalDate: date
              date(formatString: &quot;YYYY. M. D.&quot;)
              heroImageAlt
              heroImage {
                childImageSharp {
                  gatsbyImageData
                }
              }
            }
          }
        }
      }
    }
  }
`;
```

### 2.2.3. 데이터 정렬 및 시리즈별 마지막 글 선택

아쉽게도 GraphQL 쿼리로 해당 시리즈에 속한 글 중 최신글만 골라서 가져올 수는 없다. (정말 불가능한 건지는, GraphQL 을 잘 몰라서 확실치 않다.)

또한 GraphQL 의 group 쿼리에는 정렬을 적용할 수 없다. (이것 또한, GraphQL 의 한계인지 Gatsby 의 한계인지는 잘 모르겠다.)

따라서 가져온 데이터를 코드로 직접 정렬하고, 시리즈별로 마지막 글만을 골라내야 한다.

```tsx
// src/pages/series/index.tsx

const SeriesPage = ({ data }: PageProps&lt;SeriesPageData&gt;) =&gt; {
  const series = data.allMdx.group
    .map(({ edges, ...sr }) =&gt; ({
      ...sr,
      // 시리즈별로 가장 최신 글만 골라서 `node` 필드에 넣자
      node: edges.sort((a, b) =&gt;
        b.node.frontmatter.originalDate.localeCompare(
          a.node.frontmatter.originalDate
        )
      )[0].node,
    }))
    // 최신 글의 작성일 기준으로 시리즈를 내림차순 정렬하자.
    .sort((a, b) =&gt;
      b.node.frontmatter.originalDate.localeCompare(
        a.node.frontmatter.originalDate
      )
    );
  // ...
```

### 2.2.4. 뷰 업데이트

데이터를 가져왔으니 뷰를 업데이트 해보자.

```tsx
// src/pages/series/index.tsx
import SeriesItem from &quot;../../components/SeriesItem&quot;;

// ...

const SeriesPage = ({ data }: PageProps&lt;SeriesPageData&gt;) =&gt; {
  // ...

  return (
    &lt;Layout&gt;
      &lt;h1&gt;시리즈&lt;/h1&gt;
      &lt;SeriesList&gt;
        {series.map((sr) =&gt; (
          // 코드가 길어져서 별도의 컴포넌트로 분리
          &lt;SeriesItem key={sr.fieldValue} {...sr} /&gt;
        ))}
      &lt;/SeriesList&gt;
    &lt;/Layout&gt;
  );
};
```

```tsx
// src/components/SeriesItem.tsx
import { GatsbyImage, getImage } from &quot;gatsby-plugin-image&quot;;
import { navigate } from &quot;gatsby&quot;;

// ...

function SeriesItem({ fieldValue, totalCount, node }: SeriesItemProps) {
  const { date, heroImage, heroImageAlt } = node.frontmatter;

  const image = heroImage ? getImage(heroImage) : null;

  return (
    // 링크를 연결하고
    &lt;Container onClick={() =&gt; navigate(`/series/${fieldValue}`)}&gt;
      &lt;ThumbnailWrapper&gt;
        {/* 썸네일이 있으면 썸네일을 그리고 */}
        {!!image &amp;&amp; &lt;ThumbnailImage image={image} alt={heroImageAlt ?? &quot;&quot;} /&gt;}
        {/* 시리즈에 포함된 글 수를 표시하고 */}
        &lt;small&gt;{`${totalCount}`}&lt;/small&gt;
      &lt;/ThumbnailWrapper&gt;
      &lt;Info&gt;
        {/* 시리즈 이름을 보여주고 */}
        &lt;h3&gt;{fieldValue}&lt;/h3&gt;
        {/* 마지막 글의 작성일을 표시한다 */}
        &lt;small&gt;{`~ ${date}`}&lt;/small&gt;
      &lt;/Info&gt;
    &lt;/Container&gt;
  );
}

// ...

const ThumbnailImage = styled(GatsbyImage)`
  width: 100%;
  height: 100%;
  object-fit: cover;
`;

// ...
```

그럼 이제 시리즈 목록 페이지는 완성이다. 아래처럼 보일 것이다.

![](./ricalekrblog-screenshot-1.png)

### 2.2.5. 상세 코드

위 코드 조각들은 생략된 부분이 있으므로, 코드 전문을 보고 싶다면 아래를 참고하자.

- [src/pages/series/index.tsx](https://github.com/ricale/blog/blob/0106af9fd1f92b86c0f1b486a0b687e538dbc282/src/pages/series/index.tsx)
- [src/components/SeriesItem.tsx](https://github.com/ricale/blog/blob/0106af9fd1f92b86c0f1b486a0b687e538dbc282/src/components/SeriesItem.tsx)

## 2.3. 시리즈 상세 페이지 구현

시리즈 상세 페이지도 구현해보자.

(이건 이전에 작성했던 [Gatsby 블로그 만들기 1 - 기본 구현 및 태그 기능 구현](https://ricale.kr/blog/posts/230111-gatsby-1/) 글에서 태그의 상세 페이지를 만드는 방법과 동일하다.)

빌드 타임에 현재 존재하는 모든 시리즈 이름을 GraphQL 로 가져와서, 시리즈 별로 상세 페이지를 만들어 줄 것이다. 상세 페이지에는 해당 시리즈에 속한 글들이 작성일자 순으로 정렬되어 보일 것이다.

이것을 위해 페이지를 만들 때 쓰일 템플릿을 만들고, 빌드 타임에 실행될 스크립트를 작성하자.

### 2.3.1. 탬플릿 작성

```tsx
// src/templates/SeriesDetailPageTemplates.ts
import * as React from &quot;react&quot;;
import { graphql, Link, PageProps } from &quot;gatsby&quot;;
import Layout from &quot;../components/Layout&quot;;

type SeriesDetailPageTemplateData = {
  // ...
};
type SeriesDetailPageTemplateContext = {
  series: string;
};
const SeriesDetailPageTemplate = ({
  // `pageContext` 에는 gatsby-node.ts 의 createPages 에서 넘겨주는 값들이 들어있다.
  pageContext,
  // `data` 에는 아래 쪽에 있는 pageQuery 쿼리의 결과값이 들어있다.
  data,
}: PageProps&lt;
  SeriesDetailPageTemplateData,
  SeriesDetailPageTemplateContext
&gt;) =&gt; {
  const { series } = pageContext;
  const { totalCount, edges } = data.allMdx;

  return (
    &lt;Layout&gt;
      &lt;h1&gt;{`시리즈 &quot;${series}&quot;`}&lt;/h1&gt;
      &lt;ol&gt;
        {edges.map(({ node: { frontmatter } }) =&gt; (
          &lt;li key={frontmatter.slug}&gt;
            &lt;Link to={`/posts/${frontmatter.slug}`}&gt;{frontmatter.title}&lt;/Link&gt;
          &lt;/li&gt;
        ))}
      &lt;/ol&gt;
    &lt;/Layout&gt;
  );
};

// $series 는 gatsby-node.ts 의 createPages 로부터 넘겨받는다.
export const pageQuery = graphql`
  query ($series: String) {
    allMdx(
      limit: 2000
      sort: { frontmatter: { date: ASC } }
      filter: { frontmatter: { series: { in: [$series] } } }
    ) {
      totalCount
      edges {
        node {
          frontmatter {
            title
            slug
          }
        }
      }
    }
  }
`;

export default SeriesDetailPageTemplate;
```

### 2.3.2. `gatsby-node.ts` 의 `createPages` 수정

`gatsby-node.ts` 의 `createPages` 함수에서는 빌드 타임에 페이지를 생성할 수 있다. 만약 기존에 해당 함수를 구현한 적이 없었다면, 아래 코드를 `gatsby-node.ts` 에 그대로 추가해주면 된다. 만약 해당 함수가 이미 있다면, 아래 내용의 함수 안 코드를 기존의 `createPages` 안에 적당히 끼워넣어주자.

```ts
// gatsby-node.ts
export const createPages: GatsbyNode[&quot;createPages&quot;] = async ({
  actions,
  graphql,
  reporter,
}) =&gt; {
  // 존재하는 모든 시리즈를 가져온다.
  const result = await graphql&lt;TagGroupsQueryData&gt;(`
    {
      seriesGroup: allMdx(limit: 2000) {
        group(field: { frontmatter: { series: SELECT } }) {
          fieldValue
        }
      }
    }
  `);

  if (result.errors || !result.data) {
    reporter.panicOnBuild(`Error while running GraphQL query.`);
    return;
  }

  // 상세 페이지 생성에 쓰일 템플릿 컴포넌트의 경로를 가져온다.
  const seriesTemplatePath = path.resolve(
    &quot;src/templates/SeriesDetailPageTemplate.tsx&quot;
  );

  const { seriesGroup } = result.data;

  // 시리즈 별로 페이지를 생성한다.
  // `context` 를 통해 시리즈 이름을 템플릿에 넘겨주자.
  seriesGroup.group.forEach((series) =&gt; {
    actions.createPage({
      path: `/series/${series.fieldValue}/`,
      component: seriesTemplatePath,
      context: { series: series.fieldValue },
    });
  });
};
```

이제 개발 서버를 껐다 켜면, 시리즈 상세 페이지가 잘 생성된 것을 확인할 수 있다.

![](./ricalekrblog-screenshot-2.png)

취향에 따라 스타일을 바꾸고 글의 썸네일이나 작성일 등을 넣어주자. (나중에 진행할 예정)

### 2.3.3. 상세 코드

위 코드 조각들의 원문을 보고 싶다면 아래를 참고하자.

- [src/templates/SeriesDetailPageTemplate.tsx](https://github.com/ricale/blog/blob/0106af9fd1f92b86c0f1b486a0b687e538dbc282/src/templates/SeriesDetailPageTemplate.tsx)
- [gatsby-node.ts](https://github.com/ricale/blog/blob/0106af9fd1f92b86c0f1b486a0b687e538dbc282/gatsby-node.ts)

## 2.4. 글 상세 페이지에 해당 글이 속한 시리즈의 글 목록 추가

글이 특정 시리즈에 속해있다면, 해당 글의 상세 페이지 상단에 시리즈의 글 목록을 넣어주자.

상세 페이지(`src/pages/posts/{mdx.frontmatter__slug}.tsx`)에서 해당 글이 속한 시리즈의 글 목록을 얻기 위해, 일단 `gatsby-node.ts` 를 또 수정할 것이다.

### 2.4.1. `gatsby-node.ts` 의 `createResolvers` 수정

`createResolvers` 에서는 GraphQL 쿼리에서 사용할 수 있는 필드를 추가할 수 있다. 우리는 `sameSeriesPosts` 필드를 추가할 것이다.

```tsx
// gatsby-node.ts

export const createResolvers: GatsbyNode[&quot;createResolvers&quot;] = ({
  createResolvers,
}) =&gt; {
  createResolvers({
    Mdx: {
      sameSeriesPosts: {
        type: [&quot;Mdx&quot;],
        resolve: async (source, args, context, info) =&gt; {
          if (!source.frontmatter.series) {
            return;
          }

          const { entries } = await context.nodeModel.findAll({
            query: {
              filter: {
                frontmatter: {
                  series: {
                    eq: source.frontmatter.series,
                  },
                },
              },
            },
            type: &quot;Mdx&quot;,
          });

          //  공식 문서에 의하면 createResolvers 내에서
          // GraphQL 기능으로 정렬하는 건 불가능하다고 한다.
          // 스크립트 코드로 직접 정렬해주자
          return [...entries].sort((a, b) =&gt;
            a.frontmatter.date.localeCompare(b.frontmatter.date)
          );
        },
      },
    },
  });
};
```

이제 GraphQL 쿼리로 시리즈의 글 목록을 가져올 수 있다.

### 2.4.2. 글 상세 페이지에 시리즈의 글 목록 추가

```tsx
// src/pages/posts/{mdx.frontmatter__slug}.tsx
import SameSeriesPosts from &quot;../../components/SameSeriesPosts&quot;;

// ...

const PostDetailPage = ({ data, children }: PageProps&lt;PostDetailPageData&gt;) =&gt; {
  const {
    frontmatter,
    //  아까 `createResolvers` 에서 추가한 필드인
    // `sameSeriesPosts` 를, GraphQL 쿼리로 가져올 수 있다.
    sameSeriesPosts,
  } = data.mdx;
  const { title, slug, date, tags, series, heroImage, heroImageAlt } =
    frontmatter;
  const image = heroImage ? getImage(heroImage) : null;

  return (
    &lt;Layout&gt;
      &lt;Header&gt;
        &lt;h1&gt;{title}&lt;/h1&gt;
        &lt;WrittenDate&gt;{date}&lt;/WrittenDate&gt;
        &lt;Tags&gt;
          {tags.map((tag) =&gt; (
            &lt;li key={tag}&gt;
              &lt;Link to={`/tags/${tag}`}&gt;{tag}&lt;/Link&gt;
            &lt;/li&gt;
          ))}
        &lt;/Tags&gt;
      &lt;/Header&gt;

      {/* 뷰 상세 코드는 생략 */}
      &lt;SameSeriesPosts name={series} data={sameSeriesPosts} current={slug} /&gt;

      {!!image &amp;&amp; &lt;ThumbnailImage image={image} alt={heroImageAlt ?? &quot;&quot;} /&gt;}
      &lt;MdxContent&gt;{children}&lt;/MdxContent&gt;
      &lt;Comments /&gt;
    &lt;/Layout&gt;
  );
};

// ...

export const query = graphql`
  query ($id: String) {
    mdx(id: { eq: $id }) {
      # ... 다른 필드는 생략 ...
      # 이렇게 가져오면 된다.
      sameSeriesPosts {
        frontmatter {
          title
          slug
        }
      }
    }
  }
`;
```

이렇게 하면 아래처럼 글 상세 페이지에 시리즈의 글 목록을 넣을 수 있다.

![](./ricalekrblog-screenshot-3.png)

### 2.4.3. 상세 코드

위 코드 조각들은 생략된 부분이 있으므로, 코드 전문을 보고 싶다면 아래를 참고하자.

- [gatsby-node.ts](https://github.com/ricale/blog/blob/0106af9fd1f92b86c0f1b486a0b687e538dbc282/gatsby-node.ts)
- [src/pages/posts/\{mdx.frontmatter\_\_slug\}.tsx](https://github.com/ricale/blog/blob/0106af9fd1f92b86c0f1b486a0b687e538dbc282/src/pages/posts/%7Bmdx.frontmatter__slug%7D.tsx)

# 3. 다음

이로서 시리즈 기능을 구현해보았다. 다음으로 구현 및 정리할 것들은 아래와 같다.

- 댓글 기능 구현
- 코드블록 문법 하이라이팅 기능 구현
- 글의 목차 기능 구현
- 임시글 기능 구현
- GitHub Pages 배포
- 등등

순서는 미정이다.

# 4. 참고

- Gatsby Docs
  - [Gatsby Node APIs - createResolvers](https://www.gatsbyjs.com/docs/reference/config-files/gatsby-node/#createResolvers)
  - [GraphQL Query Options](https://www.gatsbyjs.com/docs/graphql-reference/#intro)
  - [Customizing the GraphQL Schema - Custom query fields](https://www.gatsbyjs.com/docs/reference/graphql-data-layer/schema-customization/#custom-query-fields)
- [Rename Fields by Using Aliases in GraphQL](https://devinschulz.com/rename-fields-by-using-aliases-in-graphql/)
</content:encoded></item><item><title><![CDATA[Gatsby 블로그 만들기 2 - MDX 글 안에 인라인 이미지, 테이블 삽입]]></title><description><![CDATA[이전 글에서는 Gatsby 기본 기능을 구현을 위한 튜토리얼을 소개했고 태그 기능을 구현했다. 오늘은 MDX 글 안에 인라인 이미지와 테이블을 삽입해보자. 정적 이미지는 gatsby-plugin-image 플러그인과 StaticImage 컴포넌트로…]]></description><link>https://ricale.kr/blogposts/230112-gatsby-2</link><guid isPermaLink="false">https://ricale.kr/blogposts/230112-gatsby-2</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Wed, 11 Jan 2023 15:00:00 GMT</pubDate><content:encoded>
이전 글에서는 Gatsby 기본 기능을 구현을 위한 튜토리얼을 소개했고 태그 기능을 구현했다. 오늘은 MDX 글 안에 인라인 이미지와 테이블을 삽입해보자.

# 1. 이미지 삽입

정적 이미지는 `gatsby-plugin-image` 플러그인과 `StaticImage` 컴포넌트로 적용한다. 페이지 컴포넌트에 들어가는 동적 이미지는 `gatsby-transformer-sharp` 플러그인과 `GatsbyImage` 컴포넌트로 적용한다. 그렇다면 MDX 본문 안에 들어가는 이미지는 어떻게 적용할까?

[공식 문서](https://www.gatsbyjs.com/docs/how-to/images-and-media/working-with-images-in-markdown/)에도 잘 나와있지만 그럼에도 불구하고 적용에 살짝 애를 먹었기 때문에 기록해두도록 하겠다.

## 1.1. `gatsby-remark-images` 플러그인 적용

일단 플러그인을 설치하자.

```sh
$ npm i gatsby-remark-images
```

그리고 `gatsby-config.ts` 를 수정하자.

```ts
// gatsby-config.ts
import type { GatsbyConfig } from &quot;gatsby&quot;;

const config: GatsbyConfig = {
  // ...
  plugins: [
    // ...
    // &quot;gatsby-plugin-mdx&quot;, // &lt;- 이렇게 문자열 형식으로 gatsby-plugin-mdx 를 쓰고 있었다면, 이 줄은 삭제하자.
    {
      resolve: &quot;gatsby-plugin-mdx&quot;,
      options: {
        gatsbyRemarkPlugins: [
          {
            resolve: &quot;gatsby-remark-images&quot;,
            options: {
              maxWidth: 800,
              backgroundColor: &quot;none&quot;,
            },
          },
        ],
      },
    },
    // ....
  ],
};

export default config;
```

## 1.2. MDX 에 인라인 이미지 사용

```
![Alt message](./screenshot.png)
```

# 2. 인라인 테이블 문법 적용

Markdown 은 원래 아래와 같은 문법으로 테이블을 삽입할 수 있다.

```
| 호스트명     | IP 주소         |
| ------------ | --------------- |
| mydomain.com | 111.111.111.222 |
| mydomain.com | 111.111.222.111 |
| mydomain.com | 111.222.111.111 |
| mydomain.com | 222.111.111.111 |
```

...있는 줄 알았다. 그런데 알고 보니 이 문법은 원래 마크다운 기본 문법이 아니라 GitHub 에서 만든 [GitHub Flavored Markdown](https://github.github.com/gfm/)(GFM) 스펙에서 지원하는 문법이었다. 당연히 MDX 에서도 기본적으로 적용되지 않는다. 하지만 다행히도 Gatsby 에서 GFM 을 적용할 수 있는 방법을 제공한다.

## 2.1. `remark-gfm` 플러그인 적용

일단 플러그인을 설치하자.

```sh
$ npm i remark-gfm@^1
```

여기서 버전 1을 설치하는 이유는 Gatsby 가 ESM 을 아직 지원하지 않는데, remark-gfm 버전 2부터는 ESM 이기 때문이다. [공식 문서](https://www.gatsbyjs.com/plugins/gatsby-plugin-mdx/#mdxoptions)에도 잘 설명되어 있다. (mdxOptions 섹션의 Please Note 부분을 보자.)

그리고 `gatsby-config.ts` 에 플러그인을 적용하자.

```ts
import type { GatsbyConfig } from &quot;gatsby&quot;;

const config: GatsbyConfig = {
  // ...
  plugins: [
    // ...
    {
      resolve: &quot;gatsby-plugin-mdx&quot;,
      options: {
        mdxOptions: {
          remarkPlugins: [require(&quot;remark-gfm&quot;)],
        },
        // ...
      },
    },
    // ...
  ],
};

export default config;
```

## 2.2. MDX 에 테이블 사용

```
| 호스트명     | IP 주소         |
| ------------ | --------------- |
| mydomain.com | 111.111.111.222 |
| mydomain.com | 111.111.222.111 |
| mydomain.com | 111.222.111.111 |
| mydomain.com | 222.111.111.111 |
```

| 호스트명     | IP 주소         |
| ------------ | --------------- |
| mydomain.com | 111.111.111.222 |
| mydomain.com | 111.111.222.111 |
| mydomain.com | 111.222.111.111 |
| mydomain.com | 222.111.111.111 |
</content:encoded></item><item><title><![CDATA[Gatsby 블로그 만들기 1 - 기본 구현 및 태그 기능 구현]]></title><description><![CDATA[쓰던 블로그 서비스가 안드로이드 모바일에서 광고를 삽입하는 것을 발견했다. (광고는 다시 없어졌다. 아마 운영자의 테스트였던 것 같다.) 개인적으로 개인 개발 블로그에 광고가 들어가는 걸 원치 않으므로 서비스를 바꿔야 겠다는 생각이 들었다. 그리고…]]></description><link>https://ricale.kr/blogposts/230111-gatsby-1</link><guid isPermaLink="false">https://ricale.kr/blogposts/230111-gatsby-1</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Tue, 10 Jan 2023 15:00:00 GMT</pubDate><content:encoded>
# 0. 발단

쓰던 블로그 서비스가 안드로이드 모바일에서 광고를 삽입하는 것을 발견했다. (광고는 다시 없어졌다. 아마 운영자의 테스트였던 것 같다.) 개인적으로 개인 개발 블로그에 광고가 들어가는 걸 원치 않으므로 서비스를 바꿔야 겠다는 생각이 들었다. 그리고 그러던 와중에 GitHub Pages 에 정적 페이지 생성 프레임워크로 블로그를 운영하는 것도 괜찮겠다 싶었다.

Jekyll 과 Gatsby 두 서비스 중 고민하다가 Gatsby 를 선택했다. 자 그러면 천천히 하나씩 적용해보자.

# 1. 프로젝트 기본 구성

[공식 튜토리얼 문서](https://www.gatsbyjs.com/docs/tutorial/)가 잘 정리되어 있다. 튜토리얼에서는 아래 일곱가지 내용을 설명한다.

0. [개발 환경 구성하기](https://www.gatsbyjs.com/docs/tutorial/part-0/)
1. [로컬에서 프로젝트 생성 및 실행하고, Gatsby 클라우드에 배포하기](https://www.gatsbyjs.com/docs/tutorial/part-1/)
2. [React 로 페이지 구현하기](https://www.gatsbyjs.com/docs/tutorial/part-2/)
3. [플러그인 적용하기](https://www.gatsbyjs.com/docs/tutorial/part-3/)
   - gatsby-plugin-image 플러그인으로 정적 이미지를 사이트에 추가하기
4. [GraphQL 사용하기](https://www.gatsbyjs.com/docs/tutorial/part-4/)
   - 사이트의 메타 데이터 다루기
   - gatsby-source-filesystem 플러그인을 적용해 GraphQL 로 MDX 파일 목록 가져오기
5. [MDX 사용하기](https://www.gatsbyjs.com/docs/tutorial/part-5/)
   - MDX 로 블로그 컨텐츠 작성하기
   - gatsby-plugin-mdx 플러그인을 적용해 GraphQL 로 MDX 파일 내용 가져오기
6. [동적으로 페이지 생성하기](https://www.gatsbyjs.com/docs/tutorial/part-6/)
   - MDX 의 frontmatter 와 `{mdx.frontmatter__slug}.tsx` 형식의 파일명을 사용해 페이지 동적으로 생성하기
   - 생성된 페이지에 알맞는 MDX 데이터를 GraphQL 로 가져와 사용하기
7. [데이터에 따라 동적으로 이미지 추가하기](https://www.gatsbyjs.com/docs/tutorial/part-7/)
   - gatsby-transformer-sharp 플러그인을 적용해 MDX 의 frontmatter 에 따라 알맞는 이미지를 가져와 사용하기

본문이 훌륭하기 때문에 굳이 여기에 다시 정리하지는 않겠다. 위 과정을 모두 거치면 기본적인 글 작성이 가능한 블로그 사이트가 완성된다.

# 2. 태그 구현

태그 구현 또한 [공식 문서](https://www.gatsbyjs.com/docs/adding-tags-and-categories-to-blog-posts/)가 잘 정리되어 있다. 하지만 약간 옛날 버전인 듯 위 튜토리얼 문서와 과 맞지 않는 부분이 있어서 해당 부분을 정정할 겸 정리해보겠다.

## 2.1. MDX 에 태그 추가

MDX 파일의 frontmatter 영역에 tags 를 추가하자

```
---
title: &quot;Create React App 으로 GitHub Pages 적용하기&quot;
date: &quot;2021-05-03&quot;
slug: &quot;210503-create-react-app-github-pages&quot;
tags: [&quot;React&quot;, &quot;create react app&quot;, &quot;github pages&quot;] # 이렇게 추가하자
---
```

https://eneaxharja.com/add-tags-to-mdx-blog

## 2.2. 태그 페이지 템플릿 추가

태그 페이지에 쓰일 템플릿을 만들어보자.

여기서 `{mdx.frontmatter__slug}.tsx}` 형식의 파일을 만들지 않고 템플릿을 만드는 이유는 페이지가 MDX 파일의 정적 데이터(frontmatter 의 slug 필드)에 의해 만들어지는 것이 아니라, 동적인 데이터 (frontmatter 의 tags 정보를 수집) 에 의해 만들어져야 하기 때문이다.

```tsx
// src/templates/TagDetailPageTemplate.tsx
import * as React from &quot;react&quot;;
import { graphql, Link, PageProps } from &quot;gatsby&quot;;
import Layout from &quot;../components/Layout&quot;;

type TagDetailPageTemplateData = {
  allMdx: {
    totalCount: number;
    edges: {
      node: {
        frontmatter: {
          slug: string;
          title: string;
        };
      };
    }[];
  };
};
type TagDetailPageTemplateContext = {
  tag: string;
};
const TagDetailPageTemplate = ({
  pageContext,
  data,
}: PageProps&lt;TagDetailPageTemplateData, TagDetailPageTemplateContext&gt;) =&gt; {
  const { tag } = pageContext;
  const { totalCount, edges } = data.allMdx;

  return (
    &lt;Layout&gt;
      &lt;h1&gt;{`태그 &quot;${tag}&quot;`}&lt;/h1&gt;
      &lt;p&gt;{`글 ${totalCount}개`}&lt;/p&gt;

      &lt;ul&gt;
        {edges.map(({ node: { frontmatter } }) =&gt; (
          &lt;li key={frontmatter.slug}&gt;
            &lt;Link to={`/posts/${frontmatter.slug}`}&gt;{frontmatter.title}&lt;/Link&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/Layout&gt;
  );
};

export const pageQuery = graphql`
  query ($tag: String) {
    allMdx(
      limit: 2000
      sort: { frontmatter: { date: DESC } }
      filter: { frontmatter: { tags: { in: [$tag] } } }
    ) {
      totalCount
      edges {
        node {
          frontmatter {
            slug
            title
          }
        }
      }
    }
  }
`;

export default TagDetailPageTemplate;
```

## 2.3. `gatsby-node.ts` 작성

위에서 만든 템플릿으로 페이지를 만들기 위해서는 `gatsby-node.ts` 를 작성해야 한다. 이미 해당 파일을 만들었다면 `createPage()` 함수 안에 아래 내용을 적당히 끼워넣으면 된다.

```ts
// gatsby-node.ts
import { GatsbyNode } from &quot;gatsby&quot;;
import path from &quot;path&quot;;

type TagGroupsQueryData = {
  tagsGroup: {
    group: {
      fieldValue: string;
    }[];
  };
};

export const createPages: GatsbyNode[&quot;createPages&quot;] = async ({
  actions,
  graphql,
  reporter,
}) =&gt; {
  const result = await graphql&lt;TagGroupsQueryData&gt;(`
    {
      tagsGroup: allMdx(limit: 2000) {
        group(field: { frontmatter: { tags: SELECT } }) {
          fieldValue
        }
      }
    }
  `);

  if (result.errors || !result.data) {
    reporter.panicOnBuild(`Error while running GraphQL query.`);
    return;
  }

  const tagsTemplatePath = path.resolve(
    &quot;src/templates/TagDetailPageTemplate.tsx&quot;
  );

  result.data.tagsGroup.group.forEach((tag) =&gt; {
    actions.createPage({
      path: `/tags/${tag.fieldValue}/`,
      component: tagsTemplatePath,
      context: { tag: tag.fieldValue },
    });
  });
};
```

## 2.4. 태그 목록 페이지 추가

태그 목록 페이지를 추가하자.

```tsx
// src/pages/tags/index.tsx
import * as React from &quot;react&quot;;
import { graphql, Link, PageProps } from &quot;gatsby&quot;;
import Layout from &quot;../../components/Layout&quot;;
import Seo from &quot;../../components/Seo&quot;;

type TagsPageData = {
  allMdx: {
    group: {
      totalCount: number;
      fieldValue: string;
    }[];
  };
};
const TagsPage = ({ data }: PageProps&lt;TagsPageData&gt;) =&gt; {
  const tags = data.allMdx.group.sort((a, b) =&gt; b.totalCount - a.totalCount);
  return (
    &lt;Layout&gt;
      &lt;h1&gt;tags&lt;/h1&gt;
      &lt;ul&gt;
        {tags.map((tag) =&gt; (
          &lt;li key={tag.fieldValue}&gt;
            &lt;Link to={`/tags/${tag.fieldValue}/`}&gt;{`${tag.fieldValue}`}&lt;/Link&gt;{&quot; &quot;}
            &lt;small&gt;{`${tag.totalCount}`}&lt;/small&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/Layout&gt;
  );
};

export const query = graphql`
  query {
    allMdx(limit: 2000) {
      group(field: { frontmatter: { tags: SELECT } }) {
        fieldValue
        totalCount
      }
    }
  }
`;

export const Head = () =&gt; &lt;Seo title=&quot;태그 목록&quot; /&gt;;

export default TagsPage;
```

`graphql` 쿼리에서 바로 totalCount 로 정렬하고 싶었지만 (GraphQL 을 잘 몰라서) 방법을 찾지 못했다. 대신 `TagsPage` 컴포넌트 첫번째 줄에서 `.sort()` 를 사용해 정렬하고 있다.

# 3. 다음

다음 글에서는 글 내용 안에 이미지를 삽입하는 방법을 정리한다.
</content:encoded></item><item><title><![CDATA[읽은 글들 (~23.1.5)]]></title><description><![CDATA[메일링, 블로그, 구글링 등을 통해 읽은 좋은 글들을 모아놓은 글이다.]]></description><link>https://ricale.kr/blogposts/230105-read-writings</link><guid isPermaLink="false">https://ricale.kr/blogposts/230105-read-writings</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Wed, 04 Jan 2023 15:00:00 GMT</pubDate><content:encoded>
## React

### [CSS Variables for React Devs](https://www.joshwcomeau.com/css/css-variables-for-react-devs/)

React 와 CSS-in-JS 를 사용하면서 CSS variable 을 쓰는 것에 대한 장단점을 설명하는 글.

장점

- 자바스크립트 변수로 css 값을 지정하는 것 (예를 들면 styled-components 의 theme 기능을 사용하는 것) 보다 좀 더 선언적이고 가독성 있는 코드가 가능하다.
- media query 적용 및 관리에 있어 더 유리하다.
- CSS-in-JS 로 해결이 어려운 이슈들을 해결할 수 있다
  - 좀 더 다양한 애니메이션을 쉽게 적용할 수 있다
  - Dark Mode 깜빡임 현상을 해결할 수 있다
    단점
- 타입 지정이 안 된다 (= IDE 자동완성 기능을 쓸 수 없다)
- 특정 상황에서 (자바스크립트로 값을 지정하는 것보다) 덜 유연하다

평소에 생각해보지 않은 흥미로운 관점이다. 본문 글이 보다 상세하고 예제 코드들도 포함하고 있으니, 흥미롭다면 본문을 읽어보자.

### [Applying Design Patterns in React: Strategy Pattern](https://dev.to/itshugo/applying-design-patterns-in-react-strategy-pattern-enn)

React 컴포넌트를 구현할 때, 디자인 패턴 중 하나인 &quot;전략 패턴&quot;을 언제 적용하면 좋을지 예제 코드와 함께 설명한다.

이런 글을 볼 때마다 느끼는 건

1. “디자인 패턴“이라고 하지만 코드 자체가 특별히 색다르거나 훌륭하지 않다. 나도 이미 비슷한 형태로 구현한 적이 꽤 있을 것 같다. (실제로 그런 경우가 많다)
2. 하지만 그런 평범한 것을 규칙으로서 혹은 패턴으로서 접하게 되면 좀 더 기억에 잘 남는다.

- 앞으로 비슷한 상황이 생기면 적용해보고 싶다.
- (혹은) “아 이건 이래서 별로야 저래서 별로야” 하고 비판적으로 받아들이고 자신이 알고 있는 더 좋은/적절한 패턴을 다시 찾아보게 된다.

라는 것이다. 그런 의미에서 읽어볼만한 글이다. 글이 길지도 않아서 읽기 좋다.

### [How to Use Google Sheets as a Database with React and Serverless](https://thenewstack.io/how-to-use-google-sheets-as-a-database-with-react-and-ssr)

구글 스프래드시트를 Serverless DB 처럼 활용해, Next.js 와 Gatsby 로 웹앱을 만드는 것에 관한 글. 글에 포함된 예제는 투표 기능을 구현했다.

데이터가 시트에 저장되기 때문에 별도의 대시보드를 만들지 않고도 비개발자(기획자, 마케터 등)분들에게 쉽게 공유할 수 있다는 장점이 있다.

## CSS

### [CSS - :where()와 :is()를 사용해보자 [Selectors Level 4]](https://7942yongdae.tistory.com/73)

`:where()` 와 `:is()` 에 대한 설명글. 둘다 CSS 스타일 선언 시 중복 제거에 쓰인다.

```css
/* Level 1 */
section h1,
article h1,
aside h1 {
  font-size: 25px;
}
:where(section, article, aside) h1 {
  font-size: 25px;
}
:is(section, article, aside) h1 {
  font-size: 25px;
}
```

차이점은 `:where()` 가 명시성이 0이라는 것.

본문에는 아직 초안이라고 나와있지만 그건 해당 글이 21년도 글이라 그렇고, 현재는 [`:where()`](https://developer.mozilla.org/en-US/docs/Web/CSS/:where#browser_compatibility) 와 [`:is()`](https://developer.mozilla.org/en-US/docs/Web/CSS/:is#browser_compatibility) 둘 다 사용 가능하다.

## Etc

### [(번역) console.log()와 함께하는 재미](https://ykss.netlify.app/translation/fun-with-console-log/)

`console` 모듈의 다양한 사용법에 대한 설명글. 이미 많이 알려진 내용이지만, 알고 있는 사람도 리마인드 하기에 좋은 글이다.

### [TechBlogPosts](https://techblogposts.com/)

IT 회사들이 운영하는 기술 블로그들의 글을 모아서 (목록 및 링크만) 보여주는 블로그. 한 눈에 보여서 꽤 괜찮다.
</content:encoded></item><item><title><![CDATA[iOS 스타일 Picker 구현 - 3. Storybook + GitHub Pages]]></title><description><![CDATA[(이전 글들을 읽지 않았더라도 본문을 읽는 데에는 지장이 없다.) 이전 글들에서는 TypeScript 와 React 로 iOS 스타일 Date Picker 를 구현했고, 구현한 컴포넌트를 라이브러리로 만들어 NPM 에 배포했다.

이번에는 라이브러리의…]]></description><link>https://ricale.kr/blogposts/230104-ios-style-picker-3</link><guid isPermaLink="false">https://ricale.kr/blogposts/230104-ios-style-picker-3</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Tue, 03 Jan 2023 15:00:00 GMT</pubDate><content:encoded>
(이전 글들을 읽지 않았더라도 본문을 읽는 데에는 지장이 없다.)

[이전 글들](https://ricale.kr/blog/series/iOS%20%EC%8A%A4%ED%83%80%EC%9D%BC%20Date%20Picker%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%20%EA%B5%AC%ED%98%84/)에서는 TypeScript 와 React 로 _iOS 스타일 Date Picker_ 를 구현했고, 구현한 컴포넌트를 라이브러리로 만들어 NPM 에 배포했다.

이번에는 라이브러리의 데모 페이지를 만들어서 GitHub Pages 에 배포해보자.

# 1. Storybook 적용

데모 페이지는 [Storybook](https://storybook.js.org/docs/react/get-started/introduction) 으로 만든다. Storybook 은 프로젝트 내 UI 컴포넌트들의 예제 페이지를 손쉽게 만들어주는 툴이다.

프로젝트의 루트 디렉토리에서 아래 명령어를 실행하자.

```sh
$ npx storybook init
```

그러면 `package.json` 에 Storybook 을 위한 패키지들과 함께 명령어가 추가된다.

```js
{
  &quot;scripts&quot;: {
    // ...
    &quot;storybook&quot;: &quot;start-storybook -p 6006&quot;,
    &quot;build-storybook&quot;: &quot;build-storybook&quot;
  },
  // ...
  &quot;devDependencies&quot;: {
    // ...
    // 설치되는 패키지는 개발 환경 (React/Vue/TypeScript 사용 여부) 에 따라
    // 다를 수 있다.
    &quot;@babel/core&quot;: &quot;^7.20.7&quot;,
    &quot;@storybook/addon-actions&quot;: &quot;^6.5.15&quot;,
    &quot;@storybook/addon-essentials&quot;: &quot;^6.5.15&quot;,
    &quot;@storybook/addon-interactions&quot;: &quot;^6.5.15&quot;,
    &quot;@storybook/addon-links&quot;: &quot;^6.5.15&quot;,
    &quot;@storybook/builder-vite&quot;: &quot;^0.2.6&quot;,
    &quot;@storybook/react&quot;: &quot;^6.5.15&quot;,
    &quot;@storybook/testing-library&quot;: &quot;^0.0.13&quot;,
    &quot;babel-loader&quot;: &quot;^8.3.0&quot;,
  }
}
```

## 1.1. 파일 구조

Storybook 실행에 필요한 기본적인 파일들도 프로젝트에 아래처럼 추가된다.

```
ROOT_DIRECTORY
|- .stroybook/
|- src/
   |- stories/
      |- assets/
      |- button.css
      |- Button.stories.tsx
      |- Button.tsx
      |- header.css
      |- Header.stories.tsx
      |- Header.tsx
      |- Introduction.stories.mdx
      |- page.css
      |- Page.stories.tsx
      |- Page.tsx
```

### 1.1.1. `.storybook/`

Storybook 설정 파일들. 일반적인 사용에서는 수정할 필요가 거의 없다.

### 1.1.2. `src/stories/`

Storybook 에서는 UI 컴포넌트의 예제 겸 문서화 페이지를 story 라고 부른다. 이 디렉토리는 story 들이 위치할 디렉토리다.

기본적인 예제는 Storybook 에 의해 자동으로 생성되어 있다. 만약 해당 예제들을 봐도 어떻게 작성해야할지 감이 오지 않는다면 [공식 문서](https://storybook.js.org/docs/react/writing-stories/introduction)를 참고하자.

## 1.2. story 작성

우리의 UI 컴포넌트 (`DatePicker`) 를 위한 story 를 간단히 작성해보자. 기존 예제들은 필요 없으므로 `src/stories/` 디렉토리 내에 있던 기존 파일들은 삭제하고, `DatePicker.stories.tsx` 를 생성한 뒤 아래처럼 작성했다.

```tsx
import { Story } from &quot;@storybook/react&quot;;
import DatePicker, { DatePickerProps } from &quot;../components/DatePicker&quot;;
import enFormatter from &quot;../formatters/en&quot;;

export default {
  title: &quot;Example/DatePicker&quot;,
  component: DatePicker,
};

const Template: Story&lt;DatePickerProps&gt; = (args) =&gt; &lt;DatePicker {...args} /&gt;;

export const Default = Template.bind({});
export const Infinite = Template.bind({});
Infinite.args = {
  infinite: true,
};

// NOTE: 간단한 i18n 구현은 다음 글에서 이어진다.
export const English = Template.bind({});
English.args = {
  formatters: enFormatter,
};
```

## 1.3. 로컬에서 확인

아래 명령어를 실행해 로컬에서 Storybook 서버를 띄워보고

```sh
$ yarn storybook
```

아래 이미지처럼 잘 뜨는지 확인하자.

![](./1.png)

# 2. GitHub Pages 에 배포

Storybook 으로 간단하게 예제 페이지를 만들었으니 이제 그걸 GitHub Pages 에 배포해보자.

## 2.1. Storybook Deployer

Storybook 은 배포용 패키지도 따로 제공해준다. [@storybook/storybook-deployer](https://www.npmjs.com/package/@storybook/storybook-deployer) 다. (배포 타겟: Github Pages 혹은 AWS S3)

아래 명령어로 패키지를 설치하자.

```sh
$ yarn add --dev @storybook/storybook-deployer
```

그리고 package.json 에 아래 명령어를 추가해주자.

```js
{
  // ...
  &quot;scripts&quot;: {
    // ...
    &quot;deploy-storybook&quot;: &quot;storybook-to-ghpages&quot;
  }
}
```

추가한 명령어를 터미널에서 실행하면 배포가 진행된다.

```sh
$ yarn deploy-storybook
```

이제 자동으로 gh-pages 브랜치로 GitHub Pages 에 배포된다.

### 2.1.1. 서브도메인에 배포한다면?

만약 배포 도메인이 루트 도메인이라면 (예, https://ricale.github.io) 아무런 설정도 추가할 필요가 없다. 하지만 배포 도메인이 서브 도메인이라면 (예, https://ricale.github.io/ios-style-picker) `.storybok/main.cjs` 에 아래 설정을 추가해주어야 한다.

```js
module.exports = {
  // ...
  async viteFinal(config) {
    config.base = &quot;/ios-style-picker/&quot;;
    return config;
  },
};
```

`viteFinal()` 이 정확히 어떤 역할을 하는지는 [공식 문서](https://storybook.js.org/docs/react/builders/vite)를 참고하자.

## 2.2. GitHub Pages 설정

다 끝났다. 이제 GitHub 에서 설정만 확인해주면 된다. 빨간 네모 속 설정들을 스크린샷과 동일하게 해주자.

![](./2.png)

# 3. 확인

이제 배포한 페이지로 들어가보자. Storybook 대시보드가 잘 뜨는 걸 확인할 수 있다.

![](./3.png)

# 4. 다음

Storybook 과 GitHub Pages 로 예제 페이지를 간단히 만들어 배포했다. 이제 해야할 일들은 아래와 같다.

- 간단한 i18n 구현
- 몇몇 상황에서 애니메이션을 더 매끄럽게 처리
  - `variant=&quot;infinite&quot;` 일 때
  - PC 에서 사용할 때

다음 글에서는 &quot;간단한 i18n 구현&quot;을 다룬다.

# 5. 참고

- [Deploying Storybook in a subdirectory](https://github.com/storybookjs/storybook/discussions/17433?sort=new)
</content:encoded></item><item><title><![CDATA[iOS 스타일 Date Picker 구현 - 2. NPM 패키지로 배포]]></title><description><![CDATA[(이전 글을 읽지 않았더라도 본문을 읽는 데에는 지장이 없다.) 이전 글에서는 iOS 스타일 Date Picker 를 순수 자바스크립트로 구현한 오픈소스 코드 조각에 대해 코드 리뷰를 했다. 이후 (글로 정리하지는 않았지만) 약간의 리팩토링을 거쳐…]]></description><link>https://ricale.kr/blogposts/221225-ios-style-picker-2</link><guid isPermaLink="false">https://ricale.kr/blogposts/221225-ios-style-picker-2</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Sat, 24 Dec 2022 15:00:00 GMT</pubDate><content:encoded>
(이전 글을 읽지 않았더라도 본문을 읽는 데에는 지장이 없다.)

[이전 글](https://ricale.kr/blog/posts/221214-ios-style-picker-1/)에서는 iOS 스타일 Date Picker 를 순수 자바스크립트로 구현한 오픈소스 코드 조각에 대해 코드 리뷰를 했다. 이후 (글로 정리하지는 않았지만) 약간의 리팩토링을 거쳐 해당 오픈소스를 React 컴포넌트로 구현했다.

그러면 이제는 구현한 것을 라이브러리로 만들어 NPM에 올려보자.

# 1. 빌드 환경 구성

빌드 환경 구성에는 원래 Webpack 을 즐겨 사용했으나, 이번에는 [Vite](https://vitejs.dev/) 를 사용해보자.

## 1.1. Vite 설치 및 적용

아래 명령어를 사용하면 yarn 이 자동으로 Vite 프로젝트를 만들어준다.

```bash
$ yarn create vite ios-style-picker --template react-ts
```

프로젝트는 대강 아래의 형태로 구성된다.

```
ios-style-picker
|- public/
|- src/
|- .gitignore
|- index.html
|- package.json
|- tsconfig.json
|- tsconfig.node.json
|- vite.config.ts
```

여기서 Vite 설정은 `vite.config.ts` 에 작성한다. 생성된 기본 설정은 아래와 같다.

```ts
import { defineConfig } from &quot;vite&quot;;
import react from &quot;@vitejs/plugin-react&quot;;

export default defineConfig({
  plugins: [react()],
});
```

라이브러리 빌드를 위해서는 아래 설정들을 추가해야한다.

- 웹앱이 아니라 라이브러리를 빌드하도록 설정을 추가한다.
- `*.d.ts` 파일을 생성하게끔 설정을 추가한다.
- react 등 외부 디펜던시에 대한 설정을 추가한다.

### 1.1.1. `build.lib`

`build.lib` 설정은 라이브러리 빌드를 위해 Vite 에서 제공하는 설정이다. 이 설정도 추가해주자.

```ts
// ...
import path from &quot;path&quot;;

export default defineConfig({
  // ...
  build: {
    lib: {
      // 빌드 타겟
      entry: path.resolve(__dirname, &quot;src/index.ts&quot;),
      // `&apos;umd&apos;` 모듈이 전역 변수로 모듈을 내보낼때 쓰는 이름.
      // Vite 가 기본적으로 `&apos;es&apos;`, `&apos;umd&apos;` 두 형식으로 모듈을 만들어주므로
      // 설정해주어야 한다.
      name: &quot;IosStylePicker&quot;,
      // 빌드 결과 생성되는 소스코드의 파일명 형식
      fileName: (format) =&gt; `ios-style-picker.${format}.js`,
    },
  },
});
```

### 1.1.2. [vite-plugin-dts](https://github.com/qmhc/vite-plugin-dts)

라이브러리 사용자에게 타입을 제공해야 하므로, `*.d.ts` 파일을 만들어주는 플러그인을 설치하자.

```bash
$ yarn add --dev vite-plugin-dts
```

설치한 플러그인을 설정 파일에 추가해주자.

```ts
//...
import dts from &quot;vite-plugin-dts&quot;;

export default defineConfig({
  plugins: [react(), dts()], //&lt;- 여기에 추가해준다.
});
```

### 1.1.3. `build.rollupOptions`

`build.rollupOptions` 설정은 Vite 내부적으로 사용되는 번들러 [Rollup](https://rollupjs.org/guide/en/) 의 설정을 직접 지정할 수 있는 설정이다.

여기서는 React 를 외부 라이브러리로 지정하기 위해 (빌드 결과에 React 코드를 포함시키지 않기 위해) 사용한다.

```ts
import path from &quot;path&quot;;

export default defineConfig({
  // ...
  build: {
    // ...
    rollupOptions: {
      // 외부 라이브러리로 사용할 라이브러리들 이름.
      external: [&quot;react&quot;, &quot;react-dom&quot;],
      // 외부 라이브러리에 접근할 때 사용할 전역변수명.
      // `&apos;umd&apos;` 빌드 시 사용된다.
      output: {
        globals: {
          react: &quot;React&quot;,
          &quot;react-dom&quot;: &quot;ReactDOM&quot;,
        },
      },
    },
  },
});
```

## 1.2. `package.json`

`package.json` 도 수정해보자.

### 1.2.1. Entry Point

엔트리 포인트 관련 설정은 Vite 공식 문서에서 [권장하는 설정](https://vitejs.dev/guide/build.html#library-mode)이 있다. 아래와 같다. 우리도 그대로 넣어주자.

```js
{
  // ...
  &quot;type&quot;: &quot;module&quot;,
  &quot;files&quot;: [&quot;dist&quot;],
  &quot;main&quot;: &quot;./dist/ios-style-picker.umd.cjs&quot;,
  &quot;module&quot;: &quot;./dist/ios-style-picker.es.js&quot;,
  &quot;exports&quot;: {
    &quot;.&quot;: {
      &quot;import&quot;: &quot;./dist/ios-style-picker.es.js&quot;,
      &quot;require&quot;: &quot;./dist/ios-style-picker.umd.cjs&quot;
    }
  }
}
```

`module`, `exports` 속성은 [NPM 공식 문서](https://docs.npmjs.com/cli/v7/configuring-npm/package-json)에는 없는 속성이다. 속성 이름과 지정된 값을 보면 직관적으로 어떤 값일지 추정이 가능하지만, 왜 문서에 없는 값들을 쓰고 있는지는 [이 스택오버플로우 글](https://stackoverflow.com/questions/42708484/what-is-the-module-package-json-field-for)을 참고하자.

### 1.2.2. `types`

타입스크립트 타입 엔트리 포인트 정보다.

```js
{
  // ...
  &quot;types&quot;: &quot;dist/index.d.ts&quot;,
}
```

### 1.2.3. `peerDependencies`

이 라이브러리를 사용하기 위해서는 react 와 react-dom 을 반드시 별도로 설치해주어야 한다. 그런 디펜던시는 `peerDependencies` 에 따로 명시해주자.

```js
{
  // ...
  &quot;peerDependencies&quot;: {
    &quot;react&quot;: &quot;&gt;=17.0.0&quot;,
    &quot;react-dom&quot;: &quot;&gt;=17.0.0&quot;
  }
}
```

### 1.2.4. 기타 정보

NPM 패지키로 올리려는 만큼, 패키지와 관련된 세부 내용도 작성해주는 것이 좋다. 필드 이름과 값 모두 직관적이므로 따로 설명을 적진 않겠다.

```js
{
  &quot;name&quot;: &quot;ios-style-picker&quot;,
  &quot;version&quot;: &quot;0.0.3&quot;,
  &quot;author&quot;: {
    &quot;name&quot;: &quot;ricale&quot;,
    &quot;email&quot;: &quot;kim.kangseong@gmail.com&quot;
  },
  &quot;repository&quot;: {
    &quot;type&quot;: &quot;git&quot;,
    &quot;url&quot;: &quot;git+https://github.com/ricale/ios-style-picker.git&quot;
  },
  &quot;bugs&quot;: {
    &quot;url&quot;: &quot;https://github.com/ricale/ios-style-picker/issues&quot;
  },
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;keywords&quot;: [
    &quot;React date picker&quot;,
    &quot;React datepicker&quot;,
    &quot;iOS style datepicker&quot;,
    &quot;iOS style date picker&quot;
  ],
  &quot;homepage&quot;: &quot;https://github.com/ricale/ios-style-picker#readme&quot;,
  // ...
}
```

# 3. 빌드 및 배포

## 3.1. 빌드

아래 명령어를 실행하면

```bash
$ yarn build
```

`dist/` 디렉토리에 빌드 결과 소스파일이 추가된다.

`dist/` 디렉토리는 기본적으로 `.gitignore`에 포함되어있다. 하지만 우리는 빌드 결과를 프로젝트에 포함시켜야 하므로, `.gitignore` 에서 해당 내용을 삭제하거나 Vite 설정을 수정해 빌드 결과 소스파일이 저장될 위치를 변경해주어야 한다. (나는 전자를 선택했다.)

## 3.2. 배포 전 테스트

NPM 에 배포하기 전에 [로컬에서 설치를 테스트해볼 수 있다](https://docs.npmjs.com/creating-and-publishing-unscoped-public-packages#testing-your-package)고 한다.

테스트용 프로젝트를 하나 만들고, 아래 형식의 명령어로 구현중인 라이브러리를 추가해서 사용해보면 된다.

```bash
$ npm install path/to/my-package
```

하지만 나의 경우에는 테스트용 프로젝트에 설치 후 사용 시 [Invalid Hook Call](https://reactjs.org/warnings/invalid-hook-call-warning.html) 에러가 발생해서 사용해볼 수가 없었다. 아마 react 를 (라이브러리의 `devDependencies` 와 테스트 프로젝트의 `dependencies` 로부터) 중복 참조해서 생기는 일 같은데 끝내 해결하지 못했다.

([이 글](https://stackoverflow.com/questions/65259040/react-antd-rollup-component-library-error-invalid-hook-call-hooks-can-onl/65259365#65259365)에서는 `npm link` 명령어를 사용하면 임시로 해결 가능하다고 하는데 어디까지나 임시일 뿐이고 그다지 매끄럽지도 않다.)

하지만 이 테스트에 통과하지 못해도 상관 없다. NPM 배포 후에 배포된 패키지를 설치해보면 문제 없이 동작하는 걸 확인할 수 있다. 그러니 이 테스트 결과에 너무 목메이지 말자.

## 3.3. 배포

아래 명령어로 로그인 후 배포하자.

```bash
$ npm adduser # 회원가입 혹은 로그인
$ npm publish # 현재 디렉토리의 패키지를 배포
```

이제 배포가 완료되었다. 배포된 패키지는 `https://www.npmjs.com/package/패키지이름` 에서 확인할 수 있다. (이 패키지는 https://www.npmjs.com/package/ios-style-picker 에서 확인할 수 있다.) 만약 README.md 까지 작성해뒀다면 접속했을 때 아래 같은 형식으로 보일 것이다.

![](1.png)

## 3.4. 업데이트

업데이트를 하고 싶다면? `package.json` 에서 version 값을 올려준 뒤

```js
{
  // ...
  &quot;version&quot;: &quot;0.0.4&quot;
}
```

다시 빌드 및 배포를 실행하면 된다.

```bash
$ yarn build # 빌드
$ npm publish # 배포
```

# 4. 다음

내가 만든 iOS 스타일 Date Picker 를 NPM 에 올렸다. 이제 다음으로 해야할 일은 아래와 같다.

- 리팩토링한 내용 정리
- Storybook 으로 데모 페이지 간단 구현 및 배포
- i18n 구현 (현재는 한국어만 지원)
- 몇몇 상황에서 애니메이션을 더 매끄럽게 처리
  - `variant=&quot;infinite&quot;` 일 때

# 5. 참고

- [Building for Production - Library Mode](https://vitejs.dev/guide/build.html#library-mode)
- [What is the &quot;module&quot; package.json field for?](https://stackoverflow.com/questions/42708484/what-is-the-module-package-json-field-for)
- [React + Antd + Rollup Component Library &quot;Error: Invalid hook call. Hooks can only be called inside of the body of a function component&quot;](https://stackoverflow.com/questions/65259040/react-antd-rollup-component-library-error-invalid-hook-call-hooks-can-onl/65259365#65259365)
</content:encoded></item><item><title><![CDATA[iOS 스타일 Date Picker 구현 - 1. 기존 코드 리뷰]]></title><description><![CDATA[1. 발단 회사의 React 기반 웹앱 프로젝트에서, iOS 스타일의 Date Picker UI 를 사용해야 하는 일이 생겼다. 직접 구현하기에는 기능에 비해 주어진 시간이 많지 않았으므로 오픈소스 라이브러리를 찾아 설치하려고 했다. 그런데 의외로…]]></description><link>https://ricale.kr/blogposts/221214-ios-style-picker-1</link><guid isPermaLink="false">https://ricale.kr/blogposts/221214-ios-style-picker-1</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Tue, 13 Dec 2022 15:00:00 GMT</pubDate><content:encoded>
## 1. 발단

회사의 React 기반 웹앱 프로젝트에서, iOS 스타일의 Date Picker UI 를 사용해야 하는 일이 생겼다. 직접 구현하기에는 기능에 비해 주어진 시간이 많지 않았으므로 오픈소스 라이브러리를 찾아 설치하려고 했다. 그런데 의외로 원하는 스타일의 Date Picker 를 찾기 어려웠다. iOS 스타일의 스크롤되는 형식보다는 안드로이드 스타일의 달력 형식이 주류였다.

어찌저찌 찾기는 찾았다. 다만 라이브러리는 아니고 [Gist 에 올라와있는](https://gist.github.com/wjpeters/876a8fe4040a2bb4b4eb28d2270620a5), 순수 자바스크립트로 작성된 코드 조각이었다. (아래 이미지는 CodePen 에 올라와있는 해당 코드 조각 [실행 예제](https://codepen.io/gnauhca/pen/JrdpZZ)다.)

![](./1.png)

일단 확인해 본 예제가 마음에 들었기 때문에, 회사 프로젝트에서는 스타일을 좀 수정하고 React 컴포넌트로 래핑만 해서 사용했다. 잘 적용하고 돌아보니 이 코드를 React 컴포넌트로 만들어서 패키지로 만들고 싶은 욕심이 생겼다. (라이센스를 확인해보니 다행히 자유로운 사용이 가능했다.)

그래서 **_iOS 스타일의 Date Picker UI 를 라이브러리로 구현_**해보기로 하겠다. 물론 그 이전에 기존 코드에 대한 이해를 먼저 해야겠다.

## 2. 기존 코드 리뷰

기존 코드는 `IosSelector` 라는 클래스를 중심으로 이루어져있다.

![](./2.png)

해당 클래스만 450라인이 조금 넘는 정도고, 초기화를 돕는 나머지 유틸 함수들이 100라인 미만으로 존재한다.

(아래 이미지는 `IosSelector` 클래스 내부 메서드들의 콜 다이어그램이다.)

![](./3.png)

클래스 내에서 눈여겨볼만한 로직은 아래 세 가지 정도가 있다.

1. 엘리먼트 생성 및 이벤트 처리
2. 터치 이벤트 처리
3. 월별 일수가 다른 것 처리

하나씩 천천히 살펴보자.

### 2.1. 엘리먼트 생성 및 이벤트 처리

엘리먼트는 DOM 에 직접 접근해서 `innerHTML` 을 사용해 생성한다.

```js
this.elems.el.innerHTML = template
  .replace(&quot;{{circleListHTML}}&quot;, circleListHTML)
  .replace(&quot;{{highListHTML}}&quot;, highListHTML);
```

여기서 `template` 은 그냥 엘리먼트를 문자열로 하드코딩한 값이다.

```js
let template = `
  &lt;div class=&quot;select-wrap&quot;&gt;
    &lt;ul class=&quot;select-options&quot; style=&quot;transform: translate3d(0, 0, ${-this
      .radius}px) rotateX(0deg);&quot;&gt;
      {{circleListHTML}}
    &lt;/ul&gt;
    &lt;div class=&quot;highlight&quot;&gt;
      &lt;ul class=&quot;highlight-list&quot;&gt;
        {{highListHTML}}
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/div&gt;
`;
```

`circleListHTML`은 사용자가 스크롤하면 돌아갈 아이템들이다. 여기서 스크롤은 실제로 엘리먼트들이 스크롤되는 것이 아니라 `transfrom: rotateX translate3d()`를 활용한 애니메이션이다.

```js
for (let i = 0; i &lt; source.length; i++) {
  circleListHTML += `&lt;li class=&quot;select-option&quot;
    style=&quot;
      top: ${this.itemHeight * -0.5}px;
      height: ${this.itemHeight}px;
      line-height: ${this.itemHeight}px;
      transform: rotateX(${-this.itemAngle * i}deg) translate3d(0, 0, ${
    this.radius
  }px);
    &quot;
    data-index=&quot;${i}&quot;
    &gt;${source[i].text}&lt;/li&gt;`;
}
```

이 `transform` 은 추후에 애니메이션이 필요할 때마다 아래처럼 값이 변경된다.

```js
this.elems.circleList.style.transform =
  `translate3d(0, 0, ${-this.radius}px) ` +
  `rotateX(${this.itemAngle * scroll}deg)`;
```

`highListHTML`은 `circleListHTML`과 거의 동일하다. 다만 선택된 값을 표시하는 부분만 보이도록 처리되어, 선택된 값을 강조하는 용도로 사용된다.

### 2.2. 터치 이벤트 처리

평소에는 `touchstart`와 `touchend` 이벤트 리스너만 설정되어 있다.

- `touchstart` 이벤트가 발생하면 `touchmove` 리스너를 붙였다가,
  ```js
  this.elems.el.addEventListener(&quot;touchmove&quot;, this.events.touchmove);
  ```
- `touchend` 이벤트 발생 시 `touchmove` 리스너를 떼어낸다.
  ```js
  this.elems.el.removeEventListener(&quot;touchmove&quot;, this.events.touchmove);
  ```

#### `touchstart`

- &quot;이벤트 시작 지점 좌표&quot;를 저장해둔다.
- 혹시 애니메이션 중이었다면 중지시킨다.

#### `touchmove`

- `touchstart` 시점에 저장해놓은 &quot;이벤트 시작 지점 좌표&quot;와 &quot;현재 이벤트 발생 지점 좌표&quot;를 비교해 적절한 아이템까지 엘리먼트를 스크롤 시킨다.
- 그리고 `touchend` 에서 사용하기 위해, 이벤트 발생 시점 타임스탬프와 좌표를 따로 저장해둔다. (최대 다섯 개)
  ```js
  let eventY = e.clientY || e.touches[0].clientY;
  touchData.yArr.push([eventY, new Date().getTime()]);
  if (touchData.length &gt; 5) {
    touchData.unshift();
  }
  ```

#### `touchend`

- 마지막 `touchmove` 이벤트 두 건에 대한 정보 (타임스탬프, 좌표)로 반동 스크롤이 어디까지 가야할지 계산한다.

  ```js
  let startTime = touchData.yArr[touchData.yArr.length - 2][1];
  let endTime = touchData.yArr[touchData.yArr.length - 1][1];
  let startY = touchData.yArr[touchData.yArr.length - 2][0];
  let endY = touchData.yArr[touchData.yArr.length - 1][0];

  v = (((startY - endY) / this.itemHeight) * 1000) / (endTime - startTime);
  let sign = v &gt; 0 ? 1 : -1;

  v = Math.abs(v) &gt; 30 ? 30 * sign : v;
  ```

- 애니메이션을 한 번에 적용하는 게 아니라 작게 나눠서 `requestAnimationFrame` 을 반복해서 호출하는 방식으로 적용한다.

  - `touchstart` 이벤트가 치고 들어오면 언제든 `cancelAnimationFrame` 을 써서 중지할 수 있다

  ```js
  return new Promise((resolve, reject) =&gt; {
    this.moving = true;
    const tick = () =&gt; {
      pass = new Date().getTime() / 1000 - start;

      if (pass &lt; t) {
        this.scroll = this._moveTo(
          initScroll + easing[easingName](pass / t) * totalScrollLen
        );
        this.moveT = requestAnimationFrame(tick);
      } else {
        resolve();
        this._stop();
        this.scroll = this._moveTo(initScroll + totalScrollLen);
      }
    };
    tick();
  });
  ```

### 2.3. 월별 일수가 다른 것 처리

월을 표시하는 `IosSelector` 의 `onChange` 이벤트가 발생할 때마다 해당 년월에 선택하는한 일 범위를 계산해, 일을 표시하는 `IosSelector` 에게 전달한다.

```js
onChange: (selected) =&gt; {
  currentMonth = selected.value;

  daySource = getDays(currentYear, currentMonth);
  // `daySelector`: 일을 표시하는 `IosSelector` 인스턴스
  daySelector.updateSource(daySource);
};
```

## 3. 다음

이제 다음으로 해야할 일은 아래와 같다.

- 취향에 맞는 리팩토링
- vite 로 빌드 및 배포 환경 구성
- storybook 으로 데모 페이지 작성 및 배포
- npm 에 패키지 배포

이 글에서 모두 이야기하기에는 글이 길어질 것 같으므로, 나눠서 작성하도록 하겠다.
</content:encoded></item><item><title><![CDATA[읽은 글들 (~22.12.3)]]></title><description><![CDATA[메일링, 블로그, 구글링 등을 통해 읽은 좋은 글들을 모아놓은 글이다.]]></description><link>https://ricale.kr/blogposts/221203-read-writings</link><guid isPermaLink="false">https://ricale.kr/blogposts/221203-read-writings</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Fri, 02 Dec 2022 15:00:00 GMT</pubDate><content:encoded>
## JavaScript

### [자바스크립트에서 안전하게 난수 생성하는 방법](https://yceffort.kr/2021/09/javascript-random-number)

`Math.random()` 은 진짜 난수가 아닌 의사 난수를 생성하고, 이는 보안적으로 안전하지 않다. 따라서 안전한 난수를 생성하기 위해서는 [Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API) 를 사용해야 한다.

### [(번역) 자바스크립트에서 영역(realm)이란 무엇인가요?](https://velog.io/@sehyunny/what-is-realm-in-js)

자바스크립의 영역(Realm)에 대해 설명한 글.

영역은 별도의 전역 실행 환경과 전역 객체, 고유 객체, 그리고 자바스크립트 코드를 갖는 영역을 말한다. 글에서는 &quot;생태계&quot;라고 표현하고 있다.

브라우저는 기본적으로 하나의 고유한 영역을 갖지만 두 개 이상의 영역을 가질 때도 있다. iframe 을 사용했을 때가 대표적인 예로, 부모와 iframe 은 서로 다른 영역을 갖게 된다.

이 말은 각자 별도의 전역 실행 환경과 전역 객체, 고유 객체, 자바스크립트 코드를 갖는다는 말로, 그냥 봤을 때는 같아보이는 것이 다르게 판단될 수도 있다는 것이다.

글에 나온 인상적인 예 하나를 첨부한다.

```html
&lt;html&gt;
  &lt;iframe id=&quot;blue_buttons_iframe&quot;&gt;
    &lt;script&gt;
      window.top.createBlueButton = function (text) {
        const button = document.createElement(&quot;button&quot;);
        button.style.color = &quot;blue&quot;;
        button.value = text;
        return button;
      };
    &lt;/script&gt;
  &lt;/iframe&gt;
  &lt;body&gt;
    &lt;script&gt;
      const blueButton = window.createBlueButton(&quot;my blue button&quot;);
      if (!blueButton instanceof HTMLButtonElement) {
        // &lt;- 이 조건문의 결과는 true 다!
        throw new Error(
          &quot;blue button created does not seem to actually be a button element!&quot;
        );
      }
      document.body.appendChild(blueButton);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
```

### [Why We&apos;re Breaking Up with CSS-in-JS](https://dev.to/srmagura/why-were-breaking-up-wiht-css-in-js-4g9b)

CSS-in-JS (styled-components, emotionjs 같이 js 코드로 작성하는 CSS) 의 장단점을 소개하고, 글쓴이의 팀에서 왜 CSS-in-JS 를 버리고 CSS 로 갈아탔는지 설명하는 글.

글에 나온 장단점을 요약하자면 아래와 같다.

장점 (The Good)

- Locally-scoped 스타일
- 컴포넌트와 스타일을 한 파일에 묶어서 관리 (Colocation)
- CSS 에 자바스크립트 변수 사용 가능

단점 (The Bad)

- 런타임 오버헤드 - CSS-in-JS 를 CSS 로 변환해 document 에 삽입하는 과정 필요
- 번들 사이즈를 늘림 - emotionjs, styled-components 등이 포함되어야 하니까
- css() 를 사용하면 dev-tools 에서 확인할 때 컴포넌트 계층 구조가 지저분해짐

나쁜점 (The Ugly)

- 빈번한 CSS 삽입으로 인해 브라우저가 할 일이 늘어남
- SSR 에 완벽한 대응이 안 됨 (상황에 따라 초기화가 제대로 안 되는 이슈가 있을 수 있음)

결과적으로 글쓴이의 팀에서는 성능 때문에 CSS 로 갈아탔다고 하는데, 성능을 분석한 내용도 있으니 궁금하다면 본문을 참고하자.

## HTML

### [Should I put input elements inside a label element?](https://stackoverflow.com/questions/774054/should-i-put-input-elements-inside-a-label-element)

`&lt;input /&gt;`과 `&lt;label /&gt;` 을 조합할 때 어떤 형식을 많이 쓰는지 궁금해서 검색하다가 본글.

```html
&lt;!-- 1 --&gt;
&lt;label for=&quot;myinput&quot;
  &gt;My Text
  &lt;input type=&quot;text&quot; id=&quot;myinput&quot; /&gt;
&lt;/label&gt;
```

```html
&lt;!-- 2 --&gt;
&lt;label for=&quot;myinput&quot;&gt;My Text&lt;/label&gt;
&lt;input type=&quot;text&quot; id=&quot;myinput&quot; /&gt;
```

대부분은 2번을 선호하지만 id 를 생략할 수 있다는 이유로 1번을 쓰는 사람도 있는 모양이다.

## Etc

### [How we lost our slick new npm package name (and then got it back)](https://reactflow.dev/blog/reactflow-npm-package-name/)

npm 의 [비슷한 이름의 패키지는 등록할 수 없는 보안 정책](https://blog.npmjs.org/post/168978377570/new-package-moniker-rules) 때문에, 양도받은 패키지를 날려버릴 뻔한 경험을 공유한 글이다. 이미 등록된 패키지는 해당 보안 정책의 영향을 받지 않는데, 글쓴이가 양도받은 패키지를 unpublish 하는 바람에 패키지가 내려갔고, 그래서 이미 있는 다른 비슷한 이름의 패키지 때문에 보안 정책에 걸려서 재등록이 불가능해진 것이다. (결국에는 npm 쪽과 이야기해서 잘 해결했다고 한다.)

### [개발자 경험(Dex)이 주목받는 시대](https://yozm.wishket.com/magazine/detail/1436/)

다른 글을 읽다가 자꾸 &quot;DX&quot;라는 말을 쓰길래, &quot;DX&quot;가 대체 뭐지 하고 찾아본 글. 개발자 경험 (Developer Experience) 을 의미하며 개발자가 일하며 마주하는 여러가지 환경요소로 인해 얻게 되는 경험을 말한다. 사용자 경험 (UX) 의 개발자 버전으로, 좋은 개발자들의 이직을 막기 위해 좋은 경험을 제공해야 한다는 맥락에서 시작된 말 같다.

그냥 개발 문화에 대해 이야기한다고 봐도 될 것 같다.

글에 좀 더 자세한 설명이 쓰여있다.

### [Introducing the Overflow Offline project](https://stackoverflow.blog/2022/10/20/introducing-the-overflow-offline-project/)

네트워크 접속 환경이 열악한 지역을 위해 스택오버플로우가 비영리단체와 손잡고 오프라인 버전을 만들었다고 한다.
</content:encoded></item><item><title><![CDATA[React Native 빌드 에러 (4)]]></title><description><![CDATA[안드로이드 1. Execution failed for task ':app:lintVitalRelease'

여기서 lintVitalRelease 는 안드로이드 코드 (Java 혹은 Kotlin) 에 대한 lint 를 실행하는 태스크인 듯 싶다.

좀 더…]]></description><link>https://ricale.kr/blogposts/221107-react-native-build-error-4</link><guid isPermaLink="false">https://ricale.kr/blogposts/221107-react-native-build-error-4</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Sun, 06 Nov 2022 15:00:00 GMT</pubDate><content:encoded>
## 안드로이드

### 1. Execution failed for task &apos;:app:lintVitalRelease&apos;

여기서 `lintVitalRelease` 는 안드로이드 코드 (Java 혹은 Kotlin) 에 대한 lint 를 실행하는 태스크인 듯 싶다.

좀 더 자세한 에러 메시지를 알고 싶으면 Android Studio 에서 `lintVatalRelease` 를 직접 실행시키면 된다. 하지만 외부 라이브러리의 lint 에러일 가능성이 높으므로 직접 대응하기 힘들 가능성이 높다. (내 경우에도 외부 라이브러리에서 발생한 에러였다.) 물론 그럼에도 근본적인 원인을 찾아 해결하고 싶다면 확인해보자.

&quot;일단은 lint 에러라면 무시해도 되지 않을까?&quot; 라는 접근법으로 해결해보았다. `android/app/build.gradle` 에 아래 내용을 추가해주면 된다.

```
android {
    // ...
    lintOptions {
        checkReleaseBuilds false
    }
    // ...
}
```

#### 참고

- [Error: Execution failed for task &apos;:app: lintVitalRelease&apos; any one can solve it?](https://stackoverflow.com/questions/49286268/error-execution-failed-for-task-app-lintvitalrelease-any-one-can-solve-it)
- [안드로이드 스튜디오 4.2 Gradle View 에서 Task 목록이 안보일때](https://stove99.github.io/etc/2021/05/11/android-studio-4.2-not-showing-gradle-task-list/)

### 2. Execution failed for task &apos;:react-native-screens:compileDebugKotlin&apos;.

최근에 라이브러리를 업데이트한 적도 없고 건드린 적도 없(다고 생각되)는데 별안간 에러가 튀어나왔다. 메시지를 좀 더 길게 보자면 아래와 같다.

&gt; e: /Users/kangseong/workspace/dataknows/RichgoInvestment/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/events/StackFinishTransitioningEvent.kt: (14, 25): Class &apos;kotlin.Unit&apos; was compiled with an incompatible version of Kotlin. The binary version of its metadata is 1.6.0, expected version is 1.4.0.
&gt; The class is loaded from /Users/kangseong/.gradle/caches/transforms-3/252e845837c589e4d31b82ce412d387f/transformed/jetified-kotlin-stdlib-1.6.10.jar!/kotlin/Unit.class
&gt;
&gt; FAILURE: Build failed with an exception.
&gt;
&gt; \* What went wrong:
&gt; Execution failed for task &apos;:react-native-screens:compileDebugKotlin&apos;.

kotlin 버전 이야기가 나온다. 이상하다. 나는 관련해서 뭔가를 업데이트한 적이 없는(것 같은)데. 여하튼 고쳐보자. `android/build.gradle` 파일에서 kotiln 버전을 지정해줬다.

```gradle
// android/build.gradle
buildscript {
    ext {
        // ...
        kotlinVersion = &quot;1.6.10&quot;
    }
    // ...
```

수정하니까 일단 에러 메시지는 없어졌다. 그런데 다른 에러가 튀어나왔다.

#### Execution failed for task &apos;:app:mergeDebugNativeLibs&apos;.

좀 더 길게 보자

&gt; \* What went wrong:
&gt; Execution failed for task &apos;:app:mergeDebugNativeLibs&apos;.
&gt; \&gt; A failure occurred while executing com.android.build.gradle.internal.tasks.MergeJavaResWorkAction
&gt; \&gt; 2 files found with path &apos;lib/armeabi-v7a/libc++\_shared.so&apos; from inputs:

이 에러에 대해서는 구글링 결과 해결책이 두 개 발견되었다.

하나는 `android/app/build.gradle` 파일에 `packagingOptions` 를 추가하는 것이다.

```gradle
// android/app/build.gradle`
android {
    // ...
    packagingOptions {
        pickFirst &apos;lib/armeabi-v7a/libc++_shared.so&apos;
        pickFirst &apos;lib/x86/libfbjni.so&apos;
        pickFirst &apos;lib/x86/libc++_shared.so&apos;
        pickFirst &apos;lib/arm64-v8a/libfbjni.so&apos;
        pickFirst &apos;lib/arm64-v8a/libc++_shared.so&apos;
        pickFirst &apos;lib/x86_64/libfbjni.so&apos;
        pickFirst &apos;lib/x86_64/libc++_shared.so&apos;
        pickFirst &apos;lib/armeabi-v7a/libfbjni.so&apos;
    }
    // ...
```

이 방법으로 빌드 에러는 제거되었다. 그런데 앱을 실행하면 실행하자마자 죽는 문제가 있었다. 그래서 두 번째 방법을 쓰게 되었다.

두 번째 방법은 `android/build.gradle` 파일에 `resolutionStrategy` 항목을 추가하는 것이다.

```gradle
allprojects {
    // ...
    configurations.all {
        resolutionStrategy {
            force &apos;com.facebook.react:react-native:0.66.4&apos; // 설치되어있는 react-native 버전과 동일하게
        }
    }
}
```

이렇게 하니까 이제 앱이 잘 실행된다.

#### 참고

- [I can&apos;t install the react native screens and gesturehandler dependencies, it&apos;s returning a TASK error - &quot;React-native-screens:compileDebugJavaC](https://github.com/software-mansion/react-native-screens/issues/1493)
- [error: Execution failed for task &apos;:app:mergeDebugNativeLibs&apos;](https://stackoverflow.com/questions/74326839/error-execution-failed-for-task-appmergedebugnativelibs)
- [Execution failed for task &apos;:app:mergeDebugNativeLibs&apos;.](https://github.com/facebook/react-native/issues/35215)
</content:encoded></item><item><title><![CDATA[[읽은글] "클라우드 서비스를 떠나는 이유"]]></title><description><![CDATA[Why we're leaving the cloud Ruby on Rails 의 창시자 DHH 가 world.hey.com 에 글을 올렸다. 자신의 회사 37signals 가 왜 클라우드 서비스를 떠나려고 하는지를 정리한 글이다. (구글 번역의 큰…]]></description><link>https://ricale.kr/blogposts/221020-read-writing-why-were-leaving-the-cloud</link><guid isPermaLink="false">https://ricale.kr/blogposts/221020-read-writing-why-were-leaving-the-cloud</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Wed, 19 Oct 2022 15:00:00 GMT</pubDate><content:encoded>
### [Why we&apos;re leaving the cloud](https://world.hey.com/dhh/why-we-re-leaving-the-cloud-654b47e0)

Ruby on Rails 의 창시자 DHH 가 world.hey.com 에 글을 올렸다. 자신의 회사 [37signals](https://world.hey.com/dhh/why-we-re-leaving-the-cloud-654b47e0) 가 왜 클라우드 서비스를 떠나려고 하는지를 정리한 글이다. (구글 번역의 큰 도움을 받아서) 내용을 간추려보았다.

- 클라우드 서비스는 두 가지 경우에서 탁월하다
  - 첫번째는 매우 단순하고 트래픽이 적은 서비스일 때
  - 두번째는 트래픽이 일정하지 않아 심하게 요동치는 서비스일 때 (자신의 회사가 운영하는 서비스가 초반에 이 덕을 봤다)
- 현재 자신의 회사의 제품들은 두 가지 경우에 모두 해당하지 않는다.
  - 그런데 연간 50만달러의 비용을 지불하면서 클라우드 서비스를 사용하고 있다. 이 돈으로 서버를 직접 구성하는 게 낫다.
  - 유지보수는? 관리는? 이라고 말할 수 있지만, AWS 등은 그다지 단순한 서비스가 아니다. 생각만큼 관리에 큰 이점이 있지 않다.
- 또한 세계적으로 소수의 회사가 대부분의 서버를 소유하고 운영하는 것에 대해 불만이 있다.
  - 이 소수의 회사가 장애에 빠지면, 전세계 인터넷이 멈추게 된다.
- 따라서 우리는 대세를 거슬러 우리 서버를 직접 소유하고 전문가를 직접 채용하려고 한다.

최근 카카오 사태와도 맞물려 (카카오는 클라우드 서비스를 쓰진 않았다) 주목하게 되는 글이다. 결국 그의 회사가 자리를 잡은 규모 있는 회사이기에 가능한 도전이기도 하지만, 유행에 휘둘리지 않고 생각을 관철하는 것이 인상깊다.

([레딧](https://www.reddit.com/r/programming/comments/y7zz2u/dhh_why_we_are_leaving_the_cloud/)에도 공유되어있다.)
</content:encoded></item><item><title><![CDATA[읽은 글들 (~22.10.20)]]></title><description><![CDATA[메일링, 블로그, 구글링 등을 통해 읽은 좋은 글들을 모아놓은 글이다.]]></description><link>https://ricale.kr/blogposts/221020-read-writings</link><guid isPermaLink="false">https://ricale.kr/blogposts/221020-read-writings</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Wed, 19 Oct 2022 15:00:00 GMT</pubDate><content:encoded>
## JavaScript

### [Jake Archibald: In The Loop - setTimeout, micro tasks, requestAnimationFrame, requestIdleCallback, …](https://www.youtube.com/watch?v=cCOL7MC4Pl0)

이벤트루프와 연관된 것들의 동작 원리에 대해 설명한 유튜브 영상. 이만큼 잘 설명된 글 또는 영상을 본 적이 없는 것 같다.

### [Can JavaScript message queues be blocked?](https://stackoverflow.com/questions/73934092/can-javascript-message-queues-be-blocked)

메시지큐의 동작 원리가 도저히 이해되지 않아 직접 질문한 글. 답변은 &quot;메시지큐는 자바스크립트 스레드에서 실행되는 것이 아니라 브라우저에서 실행되는 것이며, 따라서 자바스크립트 코드와 비동기적으로 실행될 수 있다.&quot;

답변도 답변이지만 내가 잘못 이해하고 있던 것에 대해 자세하고 시원하고 답변해준다.

### [js13kGames 2022 winners](https://github.blog/2022-10-06-js13k-2022-winners/)

한 달 내에 주어진 주제로 13KB 미만의 게임을 만드는 대회의 수상작들. 게임들이 하나같이 다 재밌다. 놀랍다.

## React

### [[번역] 위젯 주도 개발](https://medium.com/@yujso66/%EB%B2%88%EC%97%AD-%EC%9C%84%EC%A0%AF-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C-b3e95b261c18)

위젯 주도 개발에 대한 설명 글.

위젯 주도 이전에는 컴포넌트 기반의 개발이 주류였으나, 컴포넌트 개발에는 몇 가지 문제가 존재했다.

- 중복적인 API 요청
- 비효율적인 데이터 관리 (중복 처리 및 일관성 유지 관련)

이것을 API 요청 및 데이터 관리를 전담하는 별도의 레이어를 만들어 컴포넌트와 분리하는 것이 위젯 주도 개발이다. &quot;별도의 레이어&quot;라 함은 react-query, rkt-query 등의 라이브러리를 생각하면 쉽다.

### [Deep dive: How do React hooks really work?](https://www.netlify.com/blog/2019/03/11/deep-dive-how-do-react-hooks-really-work/)

react 의 hooks 은 어떤 원리로 구현되어있을까? 에 대해 예제 코드를 점진적으로 작성하면서 설명하는 글. hooks 의 원리를 한 줄로 요약하자면 &quot;모듈 단위의 클로저와 배열의 조합&quot; 이라고 할 수 있겠다. 자세한 내용은 본 글을 참고.

### [Vanilla Javascript로 React UseState Hook 만들기](https://junilhwang.github.io/TIL/Javascript/Design/Vanilla-JS-Make-useSate-hook/)

자바스크립트에서 React 의 useState hook 을 직접 구현해보는 글. 이 글의 놀라운 점은 시리즈라는 것으로, 글의 작성자는 이미 이전 글들을 통해 [컴포넌트](https://junilhwang.github.io/TIL/Javascript/Design/Vanilla-JS-Component/), [상태관리 시스템](https://junilhwang.github.io/TIL/Javascript/Design/Vanilla-JS-Store/), [가상 DOM](https://junilhwang.github.io/TIL/Javascript/Design/Vanilla-JS-Virtual-DOM/) 을 직접 구현한 상태라는 것이다. 이전 글들부터 하나씩 차근차근 봐도 좋고, 이 글만 봐도 나쁘지 않다.

## CSS

### [(번역) Tailwind CSS의 장점과 단점](https://ykss.netlify.app/translation/the_pros_and_cons_of_tailwindcss/)

Tailwind 를 처음 봤을 때는 &quot;Bootstrap 같은 건가?&quot; 하고 그냥 넘겼는데 인기가 많은 모양이다. 장단점에 대해 설명해놓은 글이다.

내 취향은 아니다.

## Unity

요즘 취미로 유니티를 공부 중인데 공부하면서 도움을 받은 링크들이다. 이 글들은 깊이가 깊은 글들이라기보다는 정보 전달에 주력한 글들이니, 첨언하기보다는 목록으로 기록한다.

- [[유니티] Lerp 와 Slerp 의 차이 - 선형 보간, 구면 선형 보간](https://gnaseel.tistory.com/14)
- [[유니티 기초] 13. 충돌 이벤트](https://m.blog.naver.com/PostView.nhn?isHttpsRedirect=true&amp;blogId=gold_metal&amp;logNo=220499531497)
- [Clean(est) way to find nearest object of many (C#)](https://forum.unity.com/threads/clean-est-way-to-find-nearest-object-of-many-c.44315/)
- [유니티 - Time.deltaTime과 Time.fixedDeltaTime의 올바른 이해](https://rito15.github.io/posts/unity-deltatime-and-fixeddeltatime/)
- [Execute code every x seconds with Update()](https://answers.unity.com/questions/17131/execute-code-every-x-seconds-with-update.html)
</content:encoded></item><item><title><![CDATA[프로미스 관련 소소한 궁금증들]]></title><description><![CDATA[1. 프로미스는 Web API 인가? 자바스크립트는 정말 싱글 스레드인가? 글을 작성하다가 이상한 이미지를 발견했다.

프로미스가 Web API 에 포함되어 있는 그림이었다. 다른 어떤 글에서도 프로미스가 Web API 에 속해있다는 내용을 본 적이…]]></description><link>https://ricale.kr/blogposts/221003-things-about-promise</link><guid isPermaLink="false">https://ricale.kr/blogposts/221003-things-about-promise</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Sun, 02 Oct 2022 15:00:00 GMT</pubDate><content:encoded>
## 1. 프로미스는 Web API 인가?

[자바스크립트는 정말 싱글 스레드인가?](https://ricale.kr/blog/posts/220926-is-javascript-single-threaded/) 글을 작성하다가 이상한 이미지를 발견했다.

![](./1.png)

프로미스가 Web API 에 포함되어 있는 그림이었다. 다른 어떤 글에서도 프로미스가 Web API 에 속해있다는 내용을 본 적이 없었다. 그런데 그렇지 않다는 확신도 없었으므로, 이참에 확실히 하기 위해 찾아보았다.

결론은 프로미스는 [자바스크립트의 표준 API](https://velog.velcdn.com/images/ricale/post/39354cb5-e62f-4ac4-b6ec-e094acfeae62/image.png)라는 것이다. Web API 는 웹브라우저와 소통하기 위한 프로그래밍 인터페이스이므로, _프로미스는 Web API 에 속하지 않는다_.

## 2. 마이크로태스크큐?

프로미스는 Web API 와 비슷하게 실행된다. 본문의 실행이 완료되면 완료 콜백을 [메시지큐*MessageQueue*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#queue)에 밀어넣는 방식이다. 다만 Web API 와 다른 점은 프로미스가 사용하는 메시지큐가 우리가 일반적으로 알고 있는 메시지큐가 아니라, 마이크로태스크큐*MicrotaskQueue*라는 별도의 큐라는 점이다.

- 메시지큐 (= 매크로태스크큐*MacrotasksQueue*): Web API 가 사용
- 마이크로태스크큐: 자바스크립트가 프로미스 등을 위해 사용

마이크로태스크큐는 메시지큐보다 높은 우선순위를 갖고 있다. 콜스택이 비었을 때 마이크로태스크큐와 메시지큐가 모두 태스크를 갖고 있다면 자바스크립트는 마이크로태스크큐에 있는 태스크를 먼저 가져가 실행한다.

## 3. `&apos;unhandledrejection&apos;` 이벤트

프로미스에서 에러 핸들링을 하지 않았다면? (`.then()` 만 쓰고 `.catch()` 를 하지 않았다면? `await` 을 `try`/`catch` 로 감싸지 않았다면?) 앱이 죽을 가능성이 높다. 웹브라우저에서는 이런 핸들링되지 않은 프로미스를 위한 전역 에러 이벤트를 제공한다. 그것이 `unhandledrejection` 이벤트다.

```js
window.addEventListener(&quot;unhandledrejection&quot;, function (event) {
  console.log(event.promise);
  console.log(event.reason);
});

new Promise(function () {
  throw new Error(&quot;TestError&quot;);
});
```

([HTML 표준 스펙](https://html.spec.whatwg.org/multipage/webappapis.html#unhandled-promise-rejections)에 포함되므로, 어느 브라우저에서든 쓸 수 있다.)

## 4. References

- mdn web docs - [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
- mdn web docs - [Web APIs](https://developer.mozilla.org/en-US/docs/Web/API)
- [Microtasks](https://javascript.info/microtask-queue)
- [Error handling with promises](https://javascript.info/promise-error-handling)
- [자바스크립트는 어떻게 약속을 지킬까?](https://ui.toast.com/posts/ko_20220725)
</content:encoded></item><item><title><![CDATA[읽은 글들 (~22.9.29)]]></title><description><![CDATA[메일링, 블로그, 구글링 등을 통해 읽은 좋은 글들을 모아놓은 글이다.]]></description><link>https://ricale.kr/blogposts/220929-read-writings</link><guid isPermaLink="false">https://ricale.kr/blogposts/220929-read-writings</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Wed, 28 Sep 2022 15:00:00 GMT</pubDate><content:encoded>
## JavaScript

### [[JS] Javascript 동작 원리와 비동기처리](https://ingg.dev/js-work/)

자바스크립트 런타임 환경에서의 스레드 구성과 콜스택, 이벤트루프, 메시지큐, Web API 스레드가 어떻게 같이 동작하는지에 대해 설명하는 글. 이해하기 쉽게 잘 정리되어 있다.

### [Event Loop (이벤트 루프)](https://velog.io/@thms200/Event-Loop-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84)

바로 위의 글과 비슷한 주제이지만 좀 더 이벤트루프에 집중한 느낌이고 마이크로테스크큐, 애니메이션프레임*requestAnimationFrame* 등 몇 가지 개념을 더 언급한다.

### [Does Promise.all Execute in Parallel? How Promise.all Works in JavaScript](https://javascript.plainenglish.io/does-promise-all-execute-in-parallel-how-promise-all-works-in-javascript-fffc2e8d455d)

Promise.all 이 정말 평행적으로 실행되는가? 에 대한 글. 사실 직접 로그를 찍어보며 돌려도 알 수 있기는 한데, 그래도 다른 사람이 문장으로 정리된 것을 읽어보는 것도 의미는 있다.

### [node_modules로부터 우리를 구원해 줄 Yarn Berry](https://toss.tech/article/node-modules-and-yarn-berry)

yarn/npm 이 디펜던시를 관리하는 방법에서의 단점을 보완한 Yarn Berry 에 대한 소개글이다.

## React

### [When to break up a component into multiple components](https://kentcdodds.com/blog/when-to-break-up-a-component-into-multiple-components)

&gt; Breaking a single component into multiple components is what&apos;s called &quot;abstraction.&quot; Abstraction is awesome, but every abstraction comes with a cost, and you have to be aware of that cost and the benefits before you take the plunge

&quot;컴포넌트를 나누는 것 또한 비용이다. 그러니 나누기 전에 비용과 이점을 알아야 한다.&quot;

컴포넌트를 어떤 경우에는 나눠야 하는지 설명한다. 그리고 그 &quot;경우&quot;에 포함되지 않을 경우, 굳이 컴포넌트를 미리 나누지 말라고 말한다.

여러모로 조심스럽게 읽고 조심스럽게 받아들여야 하는 글이다.

### [How to use Forms in React](https://www.robinwieruch.de/react-form/)

React 에서 `&lt;form /&gt;` 을 어떻게 사용할 것인다. 여러 예제 코드와 함께 설명한다. 예제코드만 쓱 훓어보더라도 나쁘지 않은 글이다.

## Etc

### [웹 서비스 캐시 똑똑하게 다루기](https://toss.tech/article/smart-web-service-cache)

http 의 Cache-Control 헤더에 대한 설명과, 토스에서는 환경 및 리소스 종류에 따라 어떻게 캐시를 적용하고 있는지에 대한 글.

### [웹 표준 미니앱의 어려움](https://cho.sh/ko/blog/A370F3)

미니앱은 슈퍼앱의 앱 내부에서 돌아가는 서드파티 앱들의 총칭이다. 일반적으로 iframe 상에서 돌아간다. 어떻게하면 웹 표준을 잘 지키며 좋은 미니앱을 만들 수 있을지에 대한 글이다.

인상깊은 부분은 단일 스레드 문제를 해결하기 위해 WebWorker 에 fake DOM API 를 심어 멀티 스레드를 구현한다는 부분이었다. 이게 보편화될 수 있다면 프론트엔드 사이드에서 꽤나 혁신적인 일이 되지 않을까 싶다.
</content:encoded></item><item><title><![CDATA[자바스크립트는 정말 싱글 스레드인가?]]></title><description><![CDATA[자바스크립트는 싱글 스레드다. 하지만 우리는 setTimeout(), Promise 등을 통해 멀티 스레드와 유사한 경험을 한다. 이것이 어떻게 가능한 것일까? 1. 콜스택, 이벤트루프, 메시지큐

궁금증을 해결하기에 앞서 일단 자바스크립트의 가장…]]></description><link>https://ricale.kr/blogposts/220926-is-javascript-single-threaded</link><guid isPermaLink="false">https://ricale.kr/blogposts/220926-is-javascript-single-threaded</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Sun, 25 Sep 2022 15:00:00 GMT</pubDate><content:encoded>
[자바스크립트는 싱글 스레드다](https://developer.mozilla.org/en-US/docs/Web/JavaScript). 하지만 우리는 `setTimeout()`, `Promise` 등을 통해 멀티 스레드와 유사한 경험을 한다. 이것이 어떻게 가능한 것일까?

## 1. 콜스택, 이벤트루프, 메시지큐

궁금증을 해결하기에 앞서 일단 자바스크립트의 가장 기본적인 실행 단위인 함수 실행 방식에 대해 알아보자.

### 1.1. 콜스택

콜스택*CallStack*은 현재 실행 중인 함수들을 관리하는 스택이다. 간단히 설명하면 아래와 같다.

1. 자바스크립트는 함수가 호출되면 콜스택에 해당 함수를 추가*push*한 뒤, 함수의 내용을 실행한다.
2. 해당 함수를 실행하던 중 다른 함수를 호출하면 마찬가지로 그 함수도 스택에 추가*push*한다. 자바스크립트는 콜스택의 가장 위에 있는 함수를 실행한다.
3. 함수의 실행이 끝나면 해당 함수를 콜스택으로부터 제거*pop*한다. 콜스택에 아직 함수가 남아있다면, 스택의 가장 위에 있는 함수를 계속 실행한다.
4. 콜스택이 빌 때까지 2,3번을 반복한다.

```js
function c() {
  console.log(&quot;call c&quot;);
}
function b() {
  console.log(&quot;call b&quot;);
}
function a() {
  console.log(&quot;call a&quot;);
  b();
  c();
}
a();
```

위 코드로 예를 들어 설명하면 아래와 같다.

1. `a()` 가 실행되었다. 콜스택에 `a()` 가 추가된다.
   콜스택: `[a()]`
2. `b()` 가 실행되었다. 콜스캑에 `b()` 도 추가된다.
   콜스택: `[a(), b()]`
3. `b()` 의 실행이 끝난다. 콜스택에서 `b()` 를 제거한다.
   콜스택: `[a()]`
4. `c()` 가 실행되었다. 콜스택에 `c()` 도 추가된다.
   콜스택: `[a(), c()]`
5. 함수 `c()` 의 실행이 끝난다. 콜스택에서 `c()` 를 제거한다.
   콜스택: `[a()]`
6. 함수 `a()` 의 실행이 끝난다. 콜스택에서 `a()` 를 제거한다.
   콜스택: `[]`

### 1.2. 메시지큐, 이벤트루프

코드에 의해 직접 실행된 함수들은 위처럼 실행된다. 하지만 자바스크립트는 코드 상에서 직접 호출하는 함수 이외에도 호출되는 함수들이 있다. 바로 `setTimeout` 이나 DOM 이벤트에 의해 실행되는 콜백 함수들이다. 이 콜백 함수들은 해당 이벤트가 발생할 때마다 메시지큐*MessageQueue*라는 큐에 추가된다.

한편 자바스크립트에는 이벤트루프*EventLoop*라는 것이 존재하는데, 이벤트루프는 콜스택과 메시지큐를 계속 확인한다. 콜스택이 비어있으면서 메시지큐에 함수가 있다면, 해당 함수를 메시지큐로부터 콜스택으로 옮겨넣는다.

## 2. 자바스크립트는 싱글스레드라며?

그런데 여기서 의문점이 생긴다.

&gt; &quot;자바스크립트는 싱글 스레드라서 한 번에 한 가지 일밖에 처리를 못하는데, 어떻게 1. 콜스택에서 함수가 실행되고 있는 와중에 2. 메시지큐에 콜백 함수를 추가할 수 있는 거지? 이게 가능하려면 메시지큐에 콜백 함수를 추가하는 코드는 별도의 스레드에서 돌고 있어야 하는 거 아닌가? 그럼 자바스크립트는 멀티 스레드여야 하는데?&quot;

이 의문은 반은 맞고 반은 틀렸다.

자바스크립트는 싱글 스레드가 맞다. 하지만 _자바스크립트가 실행되는 런타임 환경은 싱글 스레드가 아니다._ 멀티 스레드이다. 여기서 말하는 *&quot;자바스크립트가 실행되는 런타임 환경&quot;*은 Node.js, 웹브라우저 등이 있다.

프론트엔드 엔지니어 관점에서 웹브라우저에만 집중하자면, 웹브라우저는 &quot;자바스크립트 실행 컨텍스트&quot;라는 스레드 이외에 브라우저의 스레드가 별도로 존재한다. 해당 스레드에서는 [Web API](https://developer.mozilla.org/en-US/docs/Web/API) 가 실행되는데, Web API 의 대표적인 기능은 아래와 같다.

- DOM
- ajax
- setTimeout 등 타이머 처리

브라우저 스레드는 Web API 에 의해 발생하는 이벤트의 콜백 함수들을 메시지큐에 밀어넣는다.

(브라우저 환경은 이외에도 웹워커*WebWorker*라는 별도의 스레드가 존재하며, 런타임 환경에 따라서 더 많은 스레드가 존재할 수 있다.)

## 3. [`Promise.all()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)

좋다. 자바스크립트는 싱글 스레드지만 자바스크립트 런타임 환경은 멀티 스레드라는 것을 알았다. Web API 실행을 위한 스레드가 하나 더 존재하며, 따라서 `setTimeout` 이나 DOM 이벤트, Promise 의 콜백들이 문제 없이 실행된다는 것을 알았다.

그렇다면 여기서 한 가지 의문이 든다.

&gt; &quot;`Promise.all()`은? 이 함수는 여러 Promise 들을 동시에 실행시켜주는 거 아니었어? 그런데 브라우저 스레드가 싱글 스레드면 말이 안 되잖아? 멀티 스레드인 거 아냐?&quot;

아래 코드를 보자.

```js
function func1() {
  console.log(&quot;func1 called&quot;);
  return new Promise((resolve) =&gt; {
    for (let i = 0; i &lt; 50000; i++) {
      if (i % 10000 === 0) {
        console.log(&quot;func1&quot;, i);
      }
    }
    resolve();
    console.log(&quot;func1 end&quot;);
  });
}
function func2() {
  console.log(&quot;func2 called&quot;);
  return new Promise((resolve) =&gt; {
    for (let i = 0; i &lt; 50000; i++) {
      if (i % 10000 === 0) {
        console.log(&quot;func2&quot;, i);
      }
    }
    resolve();
    console.log(&quot;func2 end&quot;);
  });
}
Promise.all([func1(), func2()]);

// 실행 결과
// func1 called
// func1 0
// func1 10000
// func1 20000
// func1 30000
// func1 40000
// func1 end
// func2 called
// func2 0
// func2 10000
// func2 20000
// func2 30000
// func2 40000
// func2 end
```

멀티 스레드에서 실행되지 않는 것을 알 수 있다. `Promise.all` 도 기존 Promise 와 동일한 방법으로 실행된다. 인자로 받은 함수들은 동기적으로 차례로 실행되며, 실행이 완료되었을 때 콜백을 메시지큐에 넣는다.

## 4. 결론

따라서 우리가 얻은 결론은 아주 간단하다.

**자바스크립트는 싱글 스레드다. 하지만 자바스크립트의 런타임 환경은 멀티 스레드다.**

## 5. 더 알아봐야 할 것들..

명쾌하게 해결된 궁금증도 있지만 아직도 모호하거나 오히려 새로 생긴 궁금증들이 있다. 잘 기록해두었다가 나중에 다시 조사해보자.

- 자바스크립트가 싱글 스레드라면, 그리고 메시지큐가 자바스크립트의 스레드에 포함된 녀석이라면, 어떻게 콜스택이 실행되고 있는 와중에 메시지큐는 메시지(함수)를 받을 수 있는 것일까?
  - (10월 10일 덧붙임): 자바스크립트는 스크립트가 실행되는 단일 스레드로만 이루어진 게 맞다. 이벤트루프와 메시지큐는 이 스레드에 속하지 않은, 별도의 스레드에서 실행되는 녀석들이다 (브라우저, nodejs 등이 지원). 따라서 자바스크립트가 싱글 스레드에서 실행되는 동안, 이벤트루프와 메시지큐는 개별적으로 실행될 수 있다. [참고](https://stackoverflow.com/questions/73934092/can-javascript-message-queues-be-blocked)
- [어떤 글](https://www.slideshare.net/koreakihoon/javascript-single-thread)에서는 Promise 가 Web API 스레드에서 실행된다고 하고, [어떤 글](https://dev.to/moyedx3/9-message-queue-and-event-loop-5092)에서는 자바스크립트 스레드에서 실행된다고 한다. 뭐가 맞는 것인가?
  - 자바스크립트 스레드일 가능성이 높아 보인다.
  - 이건 마이크로태스크큐*MicrotaskQueue*와 같이 정리하면 될 것 같다.
  - (10월 10일 덧붙임): Promise 는 자바스크립트 스레드에서 실행되는 게 맞다.
- ajax 콜은 여러 콜이 동시에 비동기적으로 실행된다는데, 이게 사실인가? 사실이라면 원리는 무엇인가?
  - &quot;겉보기에는 비동기적이지만 내부적으로는 동기적으로 실행된다.&quot;가 아니라 [실제로 비동기적으로 실행된다고 하는 글](https://stackoverflow.com/questions/22844441/is-promise-all-useful-given-that-javascript-is-executed-in-a-single-thread)이 있는데, 확인이 필요하다.
  - (10월 10일 덧붙임): ajax 콜은 브라우저에 의해 멀티 스레드에서 실행된다.

## 6. References

- [javascript 는 single thread 일까?](https://www.slideshare.net/koreakihoon/javascript-single-thread)
- [[JS] Javascript 동작 원리와 비동기처리](https://ingg.dev/js-work/)
- [Event Loop, Web API, Task Queue](https://intrepidgeeks.com/tutorial/event-loop-web-api-task-queue)
- [Event Loop (이벤트 루프)](https://velog.io/@thms200/Event-Loop-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84)
- [Does Promise.all Execute in Parallel? How Promise.all Works in JavaScript](https://javascript.plainenglish.io/does-promise-all-execute-in-parallel-how-promise-all-works-in-javascript-fffc2e8d455d)
- [MDN Web docs - Call stack](https://developer.mozilla.org/en-US/docs/Glossary/Call_stack)
</content:encoded></item><item><title><![CDATA[읽은 글들 (~22.8.23)]]></title><description><![CDATA[메일링, 블로그, 구글링 등을 통해 읽은 좋은 글들을 모아놓은 글이다.]]></description><link>https://ricale.kr/blogposts/220823-read-writings</link><guid isPermaLink="false">https://ricale.kr/blogposts/220823-read-writings</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Mon, 22 Aug 2022 15:00:00 GMT</pubDate><content:encoded>
## React

### [streamich/react-use 단위 테스트 코드](https://github.com/streamich/react-use/tree/master/tests)

[react-use](https://github.com/streamich/react-use) 는 다양한 React hook 들을 모아놓은 라이브러리다. 그리고 위 링크는, 해당 라이브러리 리포지토리의 단위 테스트 코드들이다. 여러 유형에 대한 hook 테스트 코드들이 모여있다.

### [Examples of large production-grade, open-source React apps](https://maxrozen.com/examples-of-large-production-grade-open-source-react-apps)

프로덕션 레벨의 React 오픈소스 프로젝트들을 모아놓은 글이다. React 로 처음 실무를 하던 그 시절에 정말 보고 싶었던 글인데, 이제서야 만나게 되었다. 여러가지 흥미로운 프로젝트들이 많다. 개인적으로 가장 눈에 띄는 것은 아래 세 개 정도이다.

- [Real World App by Cypress](https://github.com/cypress-io/cypress-realworld-app)
- [Simorgh by the BBC](https://github.com/bbc/simorgh)
- [Sentry by Sentry](https://github.com/getsentry/sentry)

### [Avoiding useEffect with callback refs](https://tkdodo.eu/blog/avoiding-use-effect-with-callback-refs)

아래처럼 컴포넌트 초기화 시 렌더링되지 않는 DOM 에 대해 ref 로 접근하고자 하는 경우, 의도한 대로 동작하지 않을 수 있다.

```jsx
const ref = useRef(null);

useEffect(() =&gt; {
  ref.current?.focus();
}, []);

return &lt;div&gt;{someConditionIsTrue &amp;&amp; &lt;input ref={ref} /&gt;}&lt;/div&gt;;
```

그러면 이 상황에서는 input 이 렌더링 되었을 때 ref 를 바로 사용할 수 있는 이상적인 방법은 무엇일까? 에 대한 글이다.

### [(번역) React는 컴포넌트를 언제 다시 리렌더링 할까요?](https://velog.io/@surim014/react-rerender)

- 자신 혹은 부모의 상태가 업데이트 될 때 컴포넌트는 리렌더링 된다.
- 리렌더링을 줄이기 위해서는
  - 상태값을 취급하는 곳을 상위 컴포넌트에서 하위 컴포넌트로 옮기는 방법과
  - `React.memo` 를 사용하는 방법이 있다.

라는, 이제는 다소 뻔한 내용의 글.

### [How to use React.memo() to improve performance](https://felixgerschau.com/react-performance-react-memo/)

`React.memo` 를 언제 어떻게 쓰는지에 대한 글. 다른 건 다 기본적인 내용이라 건너뛰고 글 후반에 나오는 &quot;Why not use React.memo by default?&quot; 부분만 읽어도 충분하겠다. `React.memo` 를 항상 쓰지 않는 이유는

- `React.memo` 의 최적화 방식은 캐싱이기 때문에 메모리 낭비가 발생할 수 있고
- 대상 컴포넌트의 prop 이 자주 바뀔 경우 최적화하는 비용이 비싸지기 때문이다.
- 또한 이미 React 가 기본적인 성능 최적화를 잘 해주고 있으므로, 성능 이슈가 없는 상황에서 굳이 먼저 `React.memo` 를 쓸 필요가 없다.

## CSS

### [Do you know about overflow: clip?](https://kilianvalkhof.com/2022/css-html/do-you-know-about-overflow-clip/)

`overflow: clip;` 속성에 관한 설명.

## Etc

### [What&apos;s the name for hyphen-separated case?](https://stackoverflow.com/questions/11273282/whats-the-name-for-hyphen-separated-case)

camelCase, ClassCase, snake_case, 그렇다면 대시로 이어진 네이밍 컨벤션의 이름은? [Kebab case](https://www.theserverside.com/definition/Kebab-case) 라고 한다. 몰랐다. 왜 몰랐을까...?

### [(번역) V8 함수 최적화](https://junghan92.medium.com/%EB%B2%88%EC%97%AD-v8-%ED%95%A8%EC%88%98-%EC%B5%9C%EC%A0%81%ED%99%94-21b274cf1a5)

V8 엔진의 함수 최적화에 관한 설명.

V8 은 객체의 형식을 Shape 라는 형태의 캐시로 캐싱한다. 객체가 실제로 갖고 있는 값이 다르더라도 형식이 같다면 (동일한 키값을 갖는다면) 같은 Shape 캐시를 갖는다. 하지만 형태가 같더라도 어떻게 초기화하냐에 따라 Shape 캐시가 여러 개 생성될 수 있다.

- 초기화할 때 `x`, `y` 키 값을 모두 갖고 있었는지,
- 혹은 초기화 할 때는 키 값이 하나도 없었다가 `x`, `y` 키 값을 하나씩 하나씩 추가해준 것인지,

당연히 후자가 더 비효율적으로 캐싱한다.

V8 은 함수 또한 캐싱하는데, 같은 함수라 할 지라도 호출 당시 인자의 Shape 에 따라 캐싱이 갈린다. 즉, 같은 Shape 의 인자를 계속 쓰면 캐싱된 함수를 사용하기 때문에 성능에 유리하다.

라는 내용의 글이다. 보다 상세한 설명은 원글을 참고하자.
</content:encoded></item><item><title><![CDATA[[독후감] 프로그래머로 사는 법]]></title><description><![CDATA[# 책 "프로그래머로 사는 법"은 좋은 프로그래머가 되려면 어떻게 해야 할까? 에 대한 책이다. 학생, 취준생 시절부터 신입, 리더, 거물, 선지자, 대표 까지 프로그래머로서 거칠 수 있는 모든 단계에 대해 이야기한다. 한 책에서 말하기에는 너무나도…]]></description><link>https://ricale.kr/blogposts/220810-book-review-programming-life</link><guid isPermaLink="false">https://ricale.kr/blogposts/220810-book-review-programming-life</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Tue, 09 Aug 2022 15:00:00 GMT</pubDate><content:encoded>
![](./bookcover.jpg)

\#

책 &quot;프로그래머로 사는 법&quot;은 좋은 프로그래머가 되려면 어떻게 해야 할까? 에 대한 책이다. 학생, 취준생 시절부터 신입, 리더, 거물, 선지자, 대표 까지 프로그래머로서 거칠 수 있는 모든 단계에 대해 이야기한다. 한 책에서 말하기에는 너무나도 많은 이야기이다 보니 깊이를 기대하기는 어렵지만, 맥락을 얻기에는 나쁘지 않다.

저자는 미국 대기업 (IBM) 에서 디렉터까지 역임한 사람이다. 스타트업 같은 작은 기업에 다닌 경력은 거의 없는 것 같아 보이는데, 왜냐면 이 책이 어느 정도 규모 있는 회사의 프로그래머 관점에서만 쓰였기 때문이다. 따라서 (나처럼) 대기업에 다녀보지 못한 사람은 와닿지 않을 내용들이 꽤 많다. 게다가 &quot;10년 전&quot; &quot;미국&quot; 대기업이기 때문에, 우리나라 대기업과는 또 다르지 않을까 하는 느낌도 받았다.

\#

한편 이 책에는 소프트웨어 업계의 유명인사 (제임스 고슬링, 리누스 토발스, 스티브 워즈니악 등) 17명의 인터뷰도 담고 있다. 이 일을 어떻게 시작하게 되었는지, 성공의 비결이 무엇인지, 시간 관리는 어떻게 하는지, 10~15년 뒤의 미래에는 업계가 어떤 식으로 흘러갈 것 같은지, 새로 커리어를 시작하는 프로그래머에게 해주고 싶은 조언은 무엇인지 등을 묻는다.

흥미로운 내용이 많은 인터뷰들이지만 제일 인상적인 것은 모든 인터뷰이들이 한결같이 말하는 것이 있다는 것이다. &quot;하고 싶은 일, 즐거운 일을 해라.&quot; 일이 많고 고된 업계인 만큼 그렇지 않으면 견뎌내기 힘들다는 것이다. 인터뷰이 대부분은 출세하겠다는 목표가 있었다기 보다는 자신이 하고 싶은 일 즐거운 일을 하다 보니 보상이 따라왔다고 말한다.

\#

이외에도 기억에 남는 이야기가 몇 개 있다.

인적 네트워크의 중요성을 대단히 강조한다. 아무리 대단한 사람이라도 혼자서는 한계가 있기 때문이다.

또 업무 시간과 사적인 시간을 확실히 분리하라고도 말한다. 휴식과 영감을 얻기 위해, 그리고 가족들과의 시간을 보내기 위해서다.

그리고 승진을 위한 구체적인 목표를 잡으라는 것도 신기했다. 승진을 목표로 하는 것이 이기적이거나 나쁜 것이 아니므로, 상사에게도 적극적으로 의견을 물으라고 말한다. 개인적으로는 승진을 목표로 해 본 적이 없으므로, 주변에서도 그다지 접한 적이 없으므로 (나의 인적 네트워크는 좁다..) 색다른 의견으로 다가왔다.

\#

어떻게 보면 뻔한 내용들이라고 할 수도 있다. 하지만 뻔한 내용일지라도 정리된 문장으로 접하는 것은 의미가 있다. 비판적으로 수용하면서 내 생각을 정리할 수 있기 때문이다. 그런 의미에서 좋은 책이다.
</content:encoded></item><item><title><![CDATA[읽은 글들 (~22.7.24)]]></title><description><![CDATA[메일링, 블로그, 구글링 등을 통해 읽은 좋은 글들을 모아놓은 글이다.]]></description><link>https://ricale.kr/blogposts/220724-read-writings</link><guid isPermaLink="false">https://ricale.kr/blogposts/220724-read-writings</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Sat, 23 Jul 2022 15:00:00 GMT</pubDate><content:encoded>
## JavaScript

### [spread operator vs array.concat()](https://stackoverflow.com/questions/48865710/spread-operator-vs-array-concat)

spread 연산자 (`[...arr]`)로 배열을 합치는 것과 `.concat()` 메서드를 사용해 배열을 합치는 것 중 어느 것의 성능이 더 나은가? 에 관한 글. 결론만 말하자면 `.concat()` 이 성능적으로 더 유리하다.

### [ES2022 Features!](https://h3manth.com/ES2022/)

ES2022 에 새로 도입되는 문법/함수들을 소개하는 글. 개인적으로 Top-Level await 와 클래스 쪽에 추가된 문법들이 눈에 들어온다.

## React

### [토스ㅣSLASH 22 - Effective Component 지속 가능한 성장과 컴포넌트](https://www.youtube.com/watch?v=fR8tsJ2r7Eg) (영상)

지속 가능한 컴포넌트 개발을 위한 방법론? 소개 세션. 여기서 말하는 &quot;지속 가능한&quot;은 유지보수와 재사용성 측면을 이야기한다.

- Headless UI 로 구현하자.
  - UI 와 로직, 이벤트 처리 등 각각의 역할을 각각의 모듈로 분리해 개발하는 것을 말한다.
- 컴포넌트는 하나의 역할만 하거나, 하나의 역할만 하는 컴포넌트들의 조합이어야 한다.
- 도메인을 분리해야 한다.

모두 공감가는 내용이며 대부분 (완벽하지는 않지만) 실천하고 있는 내용이기도 하다. 설령 알고 있던 내용일지라도 세션이 내용 정리를 잘 해주고 있기 때문에, 들어볼만 하다.

## React Native

### [토스ㅣSLASH 22 - 미친 생산성을 위한 React Native](https://www.youtube.com/watch?v=b_6CjuvVg8o) (영상)

토스에서 토스 글로벌 앱 구현을 위해 네이티브에서 RN 으로 전환했던 경험을 소개하는 세션.

- 도입 전 Flutter 와도 비교해보았다고 하는데, React Native 의 낮은 진입 장벽과 코드 푸시 기능 때문에 RN 을 선택했다고 한다.
- 코드 푸시 기능을 굉장히 강조한다. 각 스토어의 심사 후 배포라는 느린 프로세스에 스트레스를 많이 받았던 것 같다.
- 네이티브 개발자들도 RN 에서 같이 개발을 했다고 한다. 네이티브 이슈 대응에서 매우 유리했을 것 같다. (네이티브 개발자들의 JavaScript/React 학습 소요가 발생하긴 했다.)
  - iOS 개발자는 Swift 로 개발하는 것 보다 RN 으로 개발하는 게 생산성이 훨씬 좋았다고 말한다. 특히 핫 리로딩 (Swift 도 제공하긴 하지만 RN 의 기능이 더 조핬다고 한다) 기능을 언급했다.

## Algorithm

### [플로이드의 토끼와 거북이 알고리즘(Floyd&apos;s Tortoise &amp; Hare Algorithm) / 증명 / leetcode 287번 / 파이썬](https://fierycoding.tistory.com/45)

&quot;링크드 리스트가 cycle 을 갖고 있는지 알아내라고? 좋다. Two Pointer 를 사용하면 쉽게 알 수 있으니까. 엥? 그런데 cycle 이 시작하는 지점을 찾아내라고? 그건 어떻게 하는 건데?&quot;

끙끙대다가 결국 답을 찾아봤는데 **_플로이드의 순환 탐색 알고리즘_** 을 쓰라고 한다. 해당 알고리즘을 쓰니 너무 쉽게 풀 수 있었다. 그런데 도대체 이 알고리즘의 원리가 뭔데? 아무리 생각을 해봐도, 설명한 글을 찾아봐도 이해되지가 않았다.

결국 찾아낸 이 글이, 해당 알고리즘을 가장 쉽게 설명한 글이다. 수학 공식을 삽화와 같이 몇 번이고 반복해서 본 뒤에야 겨우겨우 이해할 수 있었다.

### [Redis SKIP List of ZSETS (SORTED SETS)](http://redisgate.kr/redis/configuration/internal_skiplist.php)

Redis 의 sorted set 의 구현 알고리즘에 대해 정리한 글. 그냥 삽입될 때마다 정렬하는 거 아냐? 라고 우습게 생각했던 나 자신을 반성하게 되었다. 인메모리 DB 임에도 속도를 위해서는 이 정도 알고리즘을 써야 한다는 것이 놀랍다.

## Etc

### [토스에서의 시간을 돌아보며](https://evan-moon.github.io/2022/05/07/toss-retrospective/)

토스에서 일했던 엔지니어의 회고. 큰 주제는 아래와 같다.

- 토스가 어떻게 빨리 일할 수 있는가, 토스의 의사 결정 구조와 방식
- 급성장한 프론트엔드 엔지니어 그룹을 이끌기 위한 여러가지 시도와 일화

읽어 볼만한 글이다.
</content:encoded></item><item><title><![CDATA[읽은 글들 (~22.6.29)]]></title><description><![CDATA[메일링, 블로그, 구글링 등을 통해 읽은 좋은 글들을 모아놓은 글이다.]]></description><link>https://ricale.kr/blogposts/220629-read-writings</link><guid isPermaLink="false">https://ricale.kr/blogposts/220629-read-writings</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Tue, 28 Jun 2022 15:00:00 GMT</pubDate><content:encoded>
## JavaScript

### [Processing Arrays non-destructively: for-of vs. .reduce() vs. .flatMap()](https://2ality.com/2022/05/processing-arrays-non-destructively.html)

제목에 나온대로 `for-of`, `.reduce()`, `.flatMap()` 이 같은 상황에서 어떻게 다르게 쓰이는지를 설명한다. 많은 예제 코드가 있으므로 이해하기는 쉬울 것이다.

숙련된 프로그래머라면, 글쎄, 굳이 정독할 필요가 있나 싶다. 초심자를 대상으로 쓴 글 같다.

### [Why, Oh Why Was This Added?](https://zigamiklic.com/why-oh-why/)

&gt; &quot;이 이벤트 핸들러에 `event.stopPropagation()`를 왜 추가했더라?&quot;

라는 질문에 대한 글이다.

명확한 설명도 문맥도 없이 추가된 코드는 계속해서 남아있게 된다. 지우기 찝찝해서, 이유가 있을 거라 생각해서. 심지어는 비슷한 코드를 작성할 때는 복사해서 그대로 가져가기까지 한다. 그러한 모호함이 계속되지 않도록, 코드를 추가한 이유에 대해 주석을 달자는 내용이다.

글은 `event.stopPropagation()` 에 초점을 맞추고 있지만, 다른 비슷한 케이스가 많이 있을 것이다. 코드의 문맥 만으로 설명되지 않는 코드를 추가할 때는 주석을 달아 놓는 습관을 갖자.

## React

### [React 18 useEffect Double Call for APIs: Emergency Fix](https://javascript.plainenglish.io/react-18-useeffect-double-call-for-apis-emergency-fix-724b7ee6a646)

React 18 의 개발 모드에서는 [`useEffect` 가 두 번 실행](https://www.techiediaries.com/react-18-useeffect/)된다. 웬만한 경우에는 큰 문제가 없지만, `useEffect` 내에서 API 콜을 할 경우 중복 요청이 된다는 문제가 생긴다. 이 현상을 어떻게 막을 것인가? 에 대한 글이다. 정리하면 네 가지 방법이 있다.

1. 프로덕션 모드를 사용한다.
2. [`StrictMode`](https://reactjs.org/docs/strict-mode.html) 를 사용하지 않는다.
3. [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) 를 사용한다.
4. API 콜에 대한 캐시 기능을 사용한다. (직접 구현하든, [React Query](https://react-query.tanstack.com/) 나 [RTK Query](https://redux-toolkit.js.org/rtk-query/overview) 같은 라이브러리를 사용하든.)

제목에 Emergency Fix 라고 나와있듯 근본적인 해결책은 아니다. 하지만 AbortController 라는 키워드도 알 수 있었고, &quot;근본적인&quot; 해결책이 없다는 걸 간접적으로 알 수 있었으니 됐다.

## Etc

### [New from Anaconda: Python in the Browser](https://www.anaconda.com/blog/pyscript-python-in-the-browser)

파이썬을 자바스크립트처럼 HTML 에서 사용할 수 있는 프레임워크. 엔진이 브라우저에 포함되어 있기 때문에 사용자는 설치할 필요가 없다. 그저 `&lt;py-script /&gt;` 태그를 `&lt;script /&gt;` 태그처럼 사용하면 된다.

아직 알파 단계라고는 하지만, 이제 프론트엔드도 백엔드처럼 여러 언어로 개발할 수 있는 날이 머지 않은 것 같다. 공부할 게 많아진다는 점에서 변화는 썩 달갑지 않다. 하지만 거부할 수도 없다.

### [모던 프론트엔드 프로젝트 구성 기법 - 모노레포 개념 편](https://d2.naver.com/helloworld/0923884)

&quot;모노레포&quot;는 여러 모듈/프로젝트를 하나의 소스코드 저장소에서 관리하는 것을 의미한다. 이 글에서는 &quot;모노레포&quot;의 기본 개념과, 프론트엔드 프로젝트에서는 어떻게/왜 모노레포 프로젝트를 구성하는지에 대해 설명한다.

### [GitHub Copilot - Your AI pair programmer](https://github.com/features/copilot)

GitHub 의 서비스. 함수를 작성할 때 함수의 이름을 작성하는 것만으로 함수의 내용을 자동 완성 시켜주는 서비스. 딥러닝으로 구현된 것으로 보인다. 가격은 60일 트라이얼에 한 달 10달러 정도. 정확도가 얼마나 좋을지는 모르겠으나, 이런 서비스가 이미 유료로 운영되고 있다는 사실에 놀랐다.

지난 24일에는 Amazon 에서도 비슷한 서비스를 출시하기도 했다. [Amazon launches CodeWhisperer, a GitHub Copilot-like AI pair programming tool
](https://techcrunch.com/2022/06/23/amazon-launches-codewhisperer-its-ai-pair-programming-tool/)

옛날에는 AI로 인해 모든 직업이 사라지더라도 프로그래머만은 남을 거라고 막연히 생각했는데, 알파고 이후에 쏟아져나오는 많은 기술과 서비스들을 보고 있노라면 프로그래머도 안전 구역이 아니라는 생각이 든다.
</content:encoded></item><item><title><![CDATA[읽은 좋은 글들 (~22.5.23)]]></title><description><![CDATA[메일링, 블로그, 구글링 등을 통해 읽은 좋은 글들을 모아놓은 글이다.]]></description><link>https://ricale.kr/blogposts/220523-read-writings</link><guid isPermaLink="false">https://ricale.kr/blogposts/220523-read-writings</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Sun, 22 May 2022 15:00:00 GMT</pubDate><content:encoded>
## JavaScript

### [Stop mocking fetch](https://kentcdodds.com/blog/stop-mocking-fetch)

테스트를 작성할 때 fetch 를 mocking 하지 말고, 대신 MSW 라는 툴을 사용해 네트워크 요청 자체를 mocking 하라는 글. MSW 는 서비스 워커를 통해 모든 네트워크 요청을 가로채 원하는 가짜 응답을 내려줄 수 있는 툴이다. 비단 테스트 뿐만 아니라 개발 시 아직 구현되지 않은 API 에 대한 mocking 용도로도 사용 가능하다.

MSW 에 관해서는 한국어로 작성된 글도 많이 있다. (예, [Mock Service Worker로 만드는 모의 서버](https://blog.rhostem.com/posts/2021-03-20-mock-service-worker))

## React

### [useEffect vs useLayoutEffect](https://kentcdodds.com/blog/useeffect-vs-uselayouteffect)

useEffect 와 useLayoutEffect 의 차이를 정리한 글. 다른 건 다 알고 있는 내용이었지만 [One Special Case](https://kentcdodds.com/blog/useeffect-vs-uselayouteffect#one-special-case) 는 언뜻 들어본 적만 있고 정확히는 몰랐는데, 잘 정리되어있다.

### [What the useEvent React hook is (and isn&apos;t)](https://typeofnan.dev/what-the-useevent-react-hook-is-and-isnt/)

새로 추가될 `useEvent` hook 을 설명하는 글. `useCallback` 과 유사하지만 별도의 디펜던시 리스트 없이 항상 같은 레퍼런스이면서 항상 최신 state, props 에 접근할 수 있다는 차이점이 있다.

구현 원리를 알고 싶은데 [RFC 문서](https://github.com/reactjs/rfcs/pull/220)에서도 찾기 어려워서 조금 아쉽다.

### [React key attribute: best practices for performant lists](https://www.developerway.com/posts/react-key-attribute)

`key` 어트리뷰트에 대해 설명한 글. 글 말미에도 나와있지만 요약하면 아래와 같다.

- 랜덤한 값은 절대 `key` 로 쓰지 마라
- 유니크 아이디를 `key` 로 쓰는 것은 순서 변경이 가능한 목록에서 좋다.
- 배열의 인덱스 값을 `key` 로 쓰는 것은
  - 순서 변경이 가능한 목록에서는 안 좋다
  - 페이지네이션되는 목록에서는 유니크 아이디를 쓰는 것보다 좋다.
  - 자동완성 목록 같은 다이나믹 데이터만 처리하는 목록에서도 유니크 아이디를 쓰는 것보다 좋다.

이유와 자세한 설명은 해당 글 본문에서 확인하자.

## Style / Design

### [Flexibly Centering an Element with Side-Aligned Content](https://meyerweb.com/eric/thoughts/2022/04/26/flexibly-centering-an-element-with-side-aligned-content/)

엘리먼트 안은 `text-align: left;` 이되, 그 엘리먼트는 부모의 가운데에 위치하도록 하게 하는 스타일 방법을 정리한 내용. 부모 엘리먼트의 스타일도 변경할 수 있다면 flex 스타일로 쉽게 해결되지만, 부모에 스타일을 줄 수 없을 경우에는 어떻게 할 것인지 알려준다.

핵심만 말하자면 `max-inline-size: max-content;` 를 사용하면 된다. 자세한 내용은 원글을 참고하자.

### [Design Tokens in Your React Design System — The Right Way](https://javascript.plainenglish.io/design-tokens-in-a-react-component-design-system-the-right-way-f55d392fb540)

&quot;디자인 시스템을 구성할 때 디자인 토큰을 사용하면 composable 한 컴포넌트 및 앱을 구성할 수 있다&quot;는 내용. 여기서 말하는 디자인 토큰이란 backgroundColor, primaryColor 등 디자인 시스템에서 일관되게 사용하는 값들을 말한다.

최근 회사에서 새로 시작한 프로젝트에서 이 디자인 토큰을 적극적으로 활용하고 있는데, 디자인 일관성 유지와 코드 유지보수 측면에서 만족하고 있다.

이런 (토큰을 포함한) 디자인 시스템을 구성하고 사용하는 데에는 디자이너 뿐만 아니라 프로그래머, PM 의 협조도 필요하다. 시스템을 구축할 때 소요가 작지는 않지만, 일단 구축하면 들인 소요에 비해 장점이 훨씬 크다.

이런 개념에 익숙하지 않은 사람들이라면 읽어볼만한 글이다.
</content:encoded></item><item><title><![CDATA[책 "스크럼" 요약: 3장 - 스크럼의 실천법]]></title><description><![CDATA[서론 이 글은 스크럼 - 팀의 생산성을 극대화시키는 애자일 방법론 책의 3장 "스크럼의 실천법" 의 내용을 요약한 책이다.

말이 요약이지 읽으면서 밑줄 친 내용을 그대로 옮겨놓은 것에 불과하다. 스스로 리마인드하기 위해 기록해둔 내용이기 때문에…]]></description><link>https://ricale.kr/blogposts/220523-book-review-scrum-3</link><guid isPermaLink="false">https://ricale.kr/blogposts/220523-book-review-scrum-3</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Sun, 22 May 2022 15:00:00 GMT</pubDate><content:encoded>
## 서론

이 글은 [스크럼 - 팀의 생산성을 극대화시키는 애자일 방법론](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9788991268470&amp;orderClick=LET&amp;Kc=) 책의 3장 &quot;스크럼의 실천법&quot; 의 내용을 요약한 책이다.

말이 요약이지 읽으면서 밑줄 친 내용을 그대로 옮겨놓은 것에 불과하다. 스스로 리마인드하기 위해 기록해둔 내용이기 때문에, 본문을 읽지 않고 아래 내용만 읽어서는 내용이 매끄럽게 이해되지 않을 수 있다.

**원문을 읽어보기를 강력하게 권한다.**

---

## 1. 스크럼 마스터

- 스크럼 마스터는 사람들이 스크럼의 가치, 실천법과 규칙들을 받아들이고 실천하게 할 책임이 있다.
- 스크럼 마스터는 경영진에게는 팀의 입장을, 팀에게는 경영진의 입장을 대변한다.
- 스프린트 목표와 이전 일일 스크럼 회의에서의 예측을 바탕으로 예상 진도와 실제 진도를 비교한다.
- 스크럼 마스터는 팀의 속도를 측정하려고 노력한다.
- 제품 책임자 및 스크럼 팀과 함께 스프린트를 위한 제품 백로그를 만들고 스크럼 팀과는 스프린트를 계획, 진행한다.
- 모든 일일 스크럼 회의를 주관하고 장애 요소를 즉시 제거하여 결정이 신속하게 내려지도록 해야 한다.
- 관리자와 함께 진척도를 측정하고, 중요도가 낮은 백로그를 제거할 책임이 있다.
- 스크럼 마스터는 어떻게 팀이 가능한 최고 수준의 생산성을 유지하게 할 수 있을까? 스크럼 마스터는 주로 결정을 내리고 장애 요소를 제거하는 방식으로 그와 같이 할 수 있다.
- 일일 스크럼에서 어떤 결정을 내려야 할 필요가 있다면, 스크럼 마스터는 (심지어는 정보가 불충분한 상황이라도) 즉시 결정을 내릴 책임이 있다.
- 아무 결정도 내리지 않는 것보다 어떤 결정이든 내리는 것이 더 유익하다는 사실을 알게 되었다.
- 스크럼 마스터는 스크럼 팀에 필요한 것이 무엇인지 집중하며, 그것을 위해서라면 단호하게 행동해야 한다. 더구나 장애물 제거에는 결단력과 불굴의 의지가 필요하다.

## 2. 제품 백로그

- 제품 백로그는 제품이나 프로세스에 관심이 있는 사람이 필요하다고 생각하거나 혹은 제품에 있으면 좋을 것 같다고 생각하는 모든 것을 말한다.
- 제품 백로그는 우선순위에 따라 나열된다. 최우선 제품 백로그가 당면한 개발 활동을 결정한다. 백로그의 우선순위가 높을수록 더 시급히 처리해야 하고 더 많이 숙고해야 하며, 그 가치에 대해서 더 많은 합의를 이끌어 내야 한다.

### 제품 책임자 한 사람만이 제품 백로그를 관리한다.

- 오직 한 사람만이 제품 백로그를 관리하고 통제할 권한을 가지며, 그 사람을 제품 책임자라고 한다.
- 제품 책임자는 위원회가 아니라 단 한 사람이다. 제품 책임자에게 조언을 하거나 영향을 끼칠 위원회가 존재할 수도 있지만, 어떤 사람이나 집단이 백로그 항목의 우선순위를 바꾸고자 한다면 그럴 권한을 가진 제품 책임자를 설득해야만 한다.
- 제품 책임자가 제 역할을 다하려면 조직의 모든 사람들이 그의 결정을 존중해야만 한다. 그를 제외하고는 어느 누구도 스크럼 팀에게 다른 우선순위에 따라서 작업하라고 할 수 없으며, 스크럼 팀은 제품 책임자가 아닌 다른 사람의 말을 따라서는 안 된다.
- 제품 책임자가 내린 모든 결정은 제품 백로그의 우선순위로 반영되어 있기 때문에 매우 명백해야 한다. 프로젝트의 가시성을 확복하기 위해서는 제품 책임자가 최선을 다해야 하며, 이것이 제품 책임자의 역할에서 가장 힘든 부분임과 동시에 보람 있는 부분이다.

### 백로그를 개발하는 데 필요한 노력 추정하기

- 백로그가 만들어지면 제품 책임자는 다른 사람들과 함께 그것을 개발하는 데 얼마나 걸릴지 추정한다.
- 추정이 얼마나 정확한지는 제품 책임자와 팀이 얼마나 추정에 능숙하냐에 달려있다. 다시 말해서, 팀이 추정에 익숙해질 때까지 추정은 정확하지 않고 오락가락할 수 있다.
- 만약 제품 책임자가 어떤 최우선 백로그에 대해서 명확하고 신뢰할만한 추정치를 얻을 수 없다면 해당 백로그 항목을 재정의하거나 우선순위를 낮추거나 작업 사항이 아닌 문제 사항으로 변경해야 한다.
- 추정치는 &apos;이 기능을 추정한 시간 안에 반드시 개발해내여 한다.&apos;라는 의미가 아니다. 추정치는 출발점이며 현시점에서 정담에 가까운 추측일 뿐이다.

## 3. 스크럼 팀

- 스크럼 팀은 선별된 제품 백로그를 작동하는 제품으로 만들기 위해 헌신하며, 매 스프린트마다 이를 반복한다. 팀은 이를 위해 필요한 것이라면 무엇이든지 할 수 있는 권한을 갖는다. 오직 회사의 표준과 관행만이 이 권한을 제약할 수 있다.

### 역동적인 팀

- 팀은 목표에 헌신적이기 때문에 자신들의 헌신과 기대를 꺾는 일이 발생하면 종종 좌절하곤 한다. 그러나 스크럼은 경험주의적이므로 팀은 해당 스프린트에 개발할 기능을 줄여서 목표를 달성할 수 있고, 관리자는 해당 스프린트 끝에 인도된ㄷ 제품 증분을 바탕으로 조정할 수 있다.
- 스크럼 마스터로서 나는 가끔 팀 내부의 문제 해결에 도움을 주고 싶다는 유혹에 시달리곤 한다. 그러나 그래서는 안 된다는 것을 경험을 통해 배웠다. 팀원들은 목표를 향해 최선을 다해 주었다. 내가 팀원들 사이의 문제를 중재한다면 이는 팀원들이 할 일을 빼앗는 꼴이 될 것이다. 팀원들이 지금까지 최선을 다해왔다면 어떻게 목표를 달성할 수 있을지는 능력껏 스스로 알아낼 것이다.

### 팀의 크기

- 만약 8명 이상의 인력을 쓸 수 있다면 나는 그 팀을 여러 개의 작은 팀들로 쪼개기를 강력히 권한다.

### 팀의 구성

- 스크럼은 분석가, 설계자, 품질 관리자, 코딩 엔지니어로 구성된 수직적인 형태의 티이 되는 것을 피해야 한다.
- 팀은 제품 백로그의 분량을 결정하고, 스프린트 목표를 수립하다.
- 스크럼에서는 어떤 제 3자도 팀원이나 팀에게 이래라 저래라 할 수 없다.
- 스프린트 동안 팀은 자신이 개발한 것을 테스트해야만 한다.
- 팀의 구성과 상관없이 분석에서부터 설계, 코딩, 테스트 및 사용자 문서 작성에 이르기까지 필요한 일을 팀 스스로 해내야 한다.
- 스크럼 팀에는 직위가 없다.
- 팀의 모든 사람은 스프린트 목표 달성에 필요한 것이라면 무엇이든지 가리지 않고 하고, 어떻게 처리해야 하는지 모를 경우에는 그 방법을 배우는 데 다 함께 참여해서 최선을 다 한다.

### 팀의 책임과 권한

- 스크럼을 시행하는 동안에는 오직 팀만이 자신의 업무를 규정할 권한을 갖게 해야 한다.
- 어떤 팀들은 자신들의 권한을 깨닫기까지 약간의 시간이 걸린다. 그런 팀들에게는 이런 사실이 너무 충격적이고 의심스러운 나머지, 어느 누구도 자신들에게 무엇을 하라고 시키지 않는다는 사실에 당혹스러워 한다.
- 만약 팀이 목표 달성을 위해 필요한 권한을 충분히 갖고 있지 못하다고 느낀다면, 팀은 비정상적인 스프린트의 중단을 요청할 수 있다.

### 작업 환경

- 개방된 업무 환경을 활용하라. 개방된 환경은 사람들 간의 의사소통을 더 원활하게 만들고 쉽게 어울리도록 하며 자기 조직화를 촉진한다.
- 침묵은 불길한 징조다.
- 칸막이가 쳐진 사무실에 들어가면 종종 너무나도 조용한데, 이것은 상호작용의 부재를 가리킨다.
- 나는 회의실이 충분하지 않은 회사의 경우에는 여러 개의 사무실을 하나의 팀룸으로 둔갑시켰다. 팀이 이 새로운 방으로 이사하자마자 생산성이 극적으로 증가하였다.
- 약간의 제약이 필요하긴 하지만 스크럼 팀은 업무 시간을 스스로 규정할 수 있다. (...) 물론 팀원들은 다른 팀원들이 함께 있는 시간에 일을 해야 한다.

## 4. 일일 스크럼 회의

- 15분짜리 현황 파악 회의
- 지난 회의 이후로 무엇이 달성되었고, 다음 회의까지는 무엇을 할 예정이며, 무엇이 진행을 방해하고 있는지 서로 알게 한다.
- 내가 계속해서 듣는 장애 요소는 팀원들이 다른 현황 회의에도 참석해야 한다는 것이다. 나는 팀에게 다른 현황 회의에 참석하지 말라고 한다. 프로젝트가 어떻게 진행되고 있는지 알고 싶은 사람은 일일 스크럼 회의에 참석해서 들을 수 있기 때문이다.
- 스크럼 마스터는 일일 스크럼 회의를 성공적으로 주관할 책임이 있다.

### 회의실 만들기

- 스크럼 마스터는 일일 스크럼의 시간과 장소를 마련해야 한다.
- 이 방에는 (회의 중에 닫아 놓을) 문, (원격으로 참석할 팀원들을 위한) 스피커폰, 탁자와 팀원들이 둘러앉을 만큼 충분한 의자 및 (이슈들과 장애 요소들을 기록하고, 일일 스크럼 후의 일반적인 브레인스토밍을 위한) 화이트보드가 갖추어져 있어야 한다.

### 닭과 돼지

&gt; 닭과 돼지가 함께 모여 있을 때, 닭이 &quot;식당을 시작하자!&quot;고 제안했다. 돼지가 잠깐 생각을 하더니 물었다. &quot;그러면 식당 이름은 뭐로 하지?&quot; 이에 닭이 대답하길, &quot;햄과 달걀은 어때?&quot; 그러자 돼지가 말했다. &quot;그건 안 되겠는데. 너는 그저 (달걀이나 제공하는 것으로) 참여할 뿐이지만, 나는 (내 살을 베어내는) 희생을 해야 한단 말이지!&quot;

- 팀원 = 돼지, 그외나머지사람들 = 닭
- 닭들은 일일 스크럼에 참석할 수 있지만 주변에 머물러 있어야만 한다. 어떤 식으로도 회의를 방해해서는 안 된다. 여기에는 어떤 말을 하거나 어떤 몸짓을 하거나 어떤 소음을 내는 것도 모두 포함된다. 닭들은 손님으로 온 것이기 때문에 스크럼의 규칙을 따라야 한다.
- 일일 스크럼 회의 참관자들은 최소로 유지하라.

### 회의 시작하기

- 스크럼 마스터는 회의 중간에 주의가 산만해지는 것을 최소화해서 사람들이 회의에 집중하고 회의가 늘어지지 않도록 한다.
- 회의를 서서 하면 회의가 좀더 빨리 끝난다는 것을 아는 팀은 서서 하기도 한다.
- 희의는 누가 있든지 없든지 간에 예정된 시간에 시작한다.

### 일일 스크럼의 형식

- 한 번에 한 사람씩 돌아가면서 발표한다. 한 사람이 자신의 현황을 보고하는 동안 나머지 사람은 그의 이야기에 귀 기울여야 한다.
- 잡담은 허용되지 않는다.
- 팀원들은 이 세가지 질문에 요점만을 간추려서 간결하게 말해야 한다.
  - &quot;지난 일일 스크럼 이후로 무엇을 했는가?&quot;
    - 팀원들은 오직 자신의 팀과 이번 스프린트에 관련하여 자신이 한 것들에 대해서만 언급한다.
    - 만약 팀원이 이번 스프린트에서 자신들이 하기로 계획한 일이 아닌 다른 일을 하고 있다면, 그 다른 일을 장애 요소로 취급해야 한다. 팀의 업무와 관련이 없는 것은 무엇이나 장애 요소가 된다.
  - &quot;지금부터 다음 일일 스크럼까지 무엇으 하려고 하는가?&quot;
    - 팀원이 하려고 하는 일은 반드시 팀이 하기로 계획한 것에 부합해야 한다. 만약 팀원이 다른 일을 하려고 한다면 반드시 그 이유를 확인해야 한다.
    - 이 질문에 대한 대답을 보면서 팀과 관리자는 일이 계획에 맞게 제대로 진행되고 있는지 아니면 변경이 필요한지를 판단할 수 있다.
  - &quot;업무를 하는데 무엇이 방해되는가?&quot;
    - 개별 팀원들의 발목을 붙잡아서 팀 전체의 속도를 저하시키는 것은 무엇인가?
- 도움이 필요하다는 것을 강조하려는 경우를 제외하고 해당 업무가 어떻게 완료되었거나 될 것인지에 대해서 미사여구를 동원하거나 장황하게 설명해서는 안 된다.
- 일일 스크럼 회의는 설계 회의가 아니며 작업 회의처럼 돌변해서도 안 된다. 설계에 대해서 논하거나 그 자리에서 문제를 해결하려 들지 말라.

### 장애 요소 식별하기

- 스크럼 마스터는 그 장애 요소들을 기록하고 제거할 책임이 있다.
- 만약 스크럼 마스터가 그 장애요소를 제대로 이해하지 못했다면, 스크럼 회의가 끝난 후에 해당 장애 요소를 보고한 사람을 만나서 좀더 자세히 듣도록 한다.
- 만약 팀원이 스크럼 마스터에게 이것만 해결되면 자신의 생산성이 올라갈 것 같다고 말한다면, 스크럼 마스터는 그것을 해야만 한다.
- 장애 요소가 제거되지 않았는데도 팀원들이 장애 요소에 대해서 보고하지 않는 것은 좋지 않은 조짐이다.
- 어떠한 이유로든 장애 요소를 제거하지 못했다면 스크럼 마스터는 다음 일일 스크럼에서 이 사실을 보고 해야만 한다.
- 만약 화이트 보드에 적힌 미해결 장애 요소가 계속 늘어나기만 한다면 회사에서 팀을 충분히 지원하지 않고 있다는 것을 의미한다. 이 경우, 스크럼 마스터는 스프린트를 취소할 수도 있다.
  - _(회사의 상태가 중요한 것이 아니라)_ 스크럼 마스터는 많은 장애 요소들을 목격했고, 관계자가 그 장애 요소들을 제거하길 원치 않거나 제거할 능력이 없다는 사실이 중요하다.

### 의사결정

- 팀은 최선의 결정을 내리고 최선의 결과를 내기 위해 필요한 것이라면 예산이 허락하는 한도 내에서 무엇이든지 할 수 있다.
- 어떤 팀원은 미결정사항을 장애물로 여길 수 있다. (예를 들면 &quot;저는 이걸 할지, 저걸 할지 모르겠어요.&quot;) 그럴 경우, 스크럼 마스터는 (가능하다면 즉시 그 자리에서) 결정을 내릴 책임이 있다.
- 스크럼을 처음 시행하는 팀의 경우 스크럼 마스터가 팀을 위해서 너무 많은 결정을 내리지 않도록 조심해야 한다. 대부분의 조직에서는 의사결정을 위임하는 것이 낯설기 때문에 스크럼 마스터는 팀이 목표를 완수하기 위해 스스로 결정을 내릴 수 있도록 도와야 한다.
- 팀이 외부인에 의존해서 결정하면 할수록 자신들의 목표에 대한 통제권이 약해질 것이다.
- 대부분의 경우, 재빠른 결정이 다른 누군가가 결정해주기를 기다리면서 일을 뭉개고 있는 것보다 낫다. _(결정으로 인해 나온 결과가)_ 최악의 경우라도 아무 것도 하지 않는 것보다는 낫다.
- 때때로 잘못한 의사결정에 따라서 엉뚱한 기능이 만들어지거나, 기술을 부적절하게 적용하는 경우도 발생한다. (...) 만약, 검토회의에서 잘못된 의사결정 사항이 보이지 않는다면 그건 중요하지 않은 것일 것이다.
- 만약 일일 스크럼 회의에서 결정을 내릴 수 없다면, 스크럼 마스터는 일일 스크럼이 끝나고 한 시간 이내에 결정을 내려서 팀에게 전파해야 한다.

### 후속 회의 개최하기

- 작업에 관련된 회의는 (...) 모두 가치 있을 뿐만 아니라 꼭 필요하다. 단지 일일 스크럼이 끝난 다음에 벌어져야 할 뿐이다. 일일 스크럼과 실제 작업에 관련된 모든 회의는 명확히 구분하도록 해야 한다.

## 5. 스프린트 계획 회의

### 스프린트 계획 회의의 개요

- 스프린트 계획 회의는 사실상 두 개의 연속된 회의로 구성된다.
- 첫 번째 회의에서 팀은 제품 책임자, 관리자 그리고 사용자를 만나 어떤 기능을 개발할 것인가를 결정한다.
- 두 번째 회의에서는 다음 스프린트 동안 그 기능을 어떻게 제품 증분으로 만들 것인가를 팀 스스로 결정한다.

### 다음 스프린트 목표 선정과 제품 백로그 확정

- 제품 책임자가 최우선 제품 백로그를 발표하는 것으로 회의를 시작한다.
- 팀은 제품 책임자, 관리자, 고객과 함께 제품 백로그 중 다음 스프린트 동안 개발 가능하다고 믿는 것들을 선별한다.
- 스프린트 목표란, 선정된 제품 백로그의 구현을 통해 달성되는 어떤 목표로서 선정된 제품 백로그를 바탕으로 결정된다.

&gt; 스프린트 목표(예): 선별된 고객 서비스 트렌젝션들이 뒷단의 데이터베이스에 접속할 수 있도록 표준화된 미들웨어 메커니즘을 제공한다.

- 스프린트 목표를 설정하는 이유는 해당 스프린트 동안 개발할 기능에 관해서 팀에게 융통성을 발휘할 여유를 주기 위해서다.
- 작업이 팀이 예상한 것보다 어렵다고 판명나면, 팀은 그 기능의 일부만을 구현할 수도 있다.
- 스프린트 동안에 스프린트 목표를 어떻게 달성할 것인가는 어디까지나 팀이 스스로 결정한다.

### 스프린트 목표에 맞게 스프린트 백로그 정의하기

- 스프린트 목표를 설정하고 나면 목표 달성을 위해서 어떤 작업들을 완수할 것인가를 결정한다. 이 사항을 결정할 때에는 모든 팀원이 참석해야 한다. (...) 이 회의에서 경영진이나 사용자는 팀의 결정을 방해할 어떤 행동이나 말을 해서는 안 된다.
- 팀은 스프린트 목표 달성을 위해 필요한 태스크들의 목록을 작성한다. (...) 각 태스크는 대략 4시간에서 16시간 안에 완료할 수 있을 만큼 충분히 자세하게 명시되어 있어야 한다.
- 때로는 스프린트 백로그의 일부밖에 작성할 수 없을 때가 있다. (...) 이와 같은 경우 팀은 사전 조사, 설계 및 아키텍처 작업을 가능한 자세히 정의하고, 그 작업들이 완료되었을 때 뒤이어 수행해야 할 업무들을 남겨두어야 한다. 그때가 되면 해당 업무들에 대한 이해가 깊어지면서 업무를 보다 상세화하기 위한 또다른 회의를 소집할 수도 있다.
- 팀은 스프린트 기간 내내 스프린트 백로그를 수정한다. (...) 새로운 업무가 필요해지면 스프린트 백로그에 추가한다. 태스크를 착수하거나 완료할 때마다 각 태스크 완료까지 남은 시간의 추정치를 계속 갱신한다. 만약 어떤 태그크들이 불필요하다고 판단되면 그것들을 제거할 수도 있다.
- 스프린트 동안에는 오직 팀만이 스프린트 백로그를 변경할 수 있다.
- 때로는 스크럼 팀은 자신들이 너무 많은 제품 백로그를 선택했다는 사실을 깨닫기도 한다. 이런 일이 벌어질 경우 스크럼 마스터는 즉시 제품 책임자와 스크럼 팀을 한 자리에 모은 다음 제거하더라도 스프린트 목표 달성에 지장이 없는 제품 백로그를 모두 함께 선정해야 한다. 제거가 어렵다면 개발 범위를 줄일 수 있는 기능은 어떤 것이 있는지 알아본다.

## 6. 스프린트

- &quot;시행착오는 귀중한 학습 경험으로서 언제나 긍정적으로 받아들여지게 될 것이다.&quot;

### 제품 증분은 혼돈의 산물이다.

- 팀은 복잡한 요구사항과 예측 불가능한 기술을 제품 증분으로 만들기 위해 최선을 다 해야 한다. 또한 혼돈을 길들이고 보잡성을 예측 가능한 제품으로 바꾸어 놓아야 한다.

### 방해 금지, 난입 금지, 잡상인 금지

- 팀 외부의 어느 누구도 팀이 스프린트 동안 하고 있는 업무의 범위나 성격을 바꿀 수 없으며 새로운 기능이나 기술을 추가해서도 안 된다. 팀의 업무 방식에 대한 간섭도 금지된다.

### 스프린트의 동작 메커니즘

- 스프린트 기간 동안 팀은 전권을 행사한다. _(업무 시간이나 회의 모두 팀 마음대로)_
- 스프린트동안 팀이 반드시 지켜야 할 사항이 두 가지 있다. 일일 스크럼 회의와 스프린트 백로그다.
  - 일일 스크럼 회의에는 모든 팀원이 직접 참석하든 전화를 이용하든 반드시 참석하도록 유도해야 한다. 이메일이나 팩스와 같은 간접적인 현황 보고는 금지된다.
  - 스프린트 백로그는 반드시 최신 상태로 유지해야 하고 팀의 활동을 정확하게 반영해야 하며, 이를 통해서 진화하는 팀과 팀의 업무를 정확하게 그려내야 한다.
- 일일 빌드는 팀의 진척도를 측정하는 훌륭한 수단이다.

### 비정상적인 스프린트 중단

- 기존의 스프린트 목표가 쓸모없게 되면 경영진이 스프린트를 취소할 수 있다.
  - 스프린트의 길이가 (30일로) 매우 짧기 때문에 경영진이 스프린트를 취소하는 게 좋다고 생각하는 경우는 거의 없다.
- 스프린트 도중에 자신들이 이번 스프린트 목표를 달성할 수 없다는 사실을 깨닫게 될 수도 있다. 업무에 대한 팀의 생각이 바뀌지 않았다 하더라도 팀이 심각한 난관에 직면했다면 스프린트를 취소할 수 있다.
- 팀이 스프린트를 취소할 수 있는 권한을 갖는 것은 매우 중요하다. 누군가가 업무의 성격이나 범위를 변경하려고 하면 팀이 스프린트를 중단할 수 있기 때문에 업무에 집중하는 것이 가능하다.
- 스프린트 중단을 자원을 낭비하는 행위다.

## 7. 스프린트 검토

- 팀은 스프린트가 끝날 무렵에 팀이 어느 위치에 있게 될 것인지를 추정하고, 그에 따라 항로를 설정한다.
- 팀은 자신들이 개발한 제품 증분을 선보인다. 경영진, 고객들, 사용자들과 함께 제품 책임자는 제품 증분을 평가하고 이번 스프린트 동안 팀이 겪은 이야기에 귀를 귀울인다.
- 스크럼 마스터는 스프린트 검토 회의의 진행과 조율을 책임진다.
- 회의를 준비하면서 팀은 이번 스프린트 동안 자신들이 개발한 것을 이해시키기 위해 참석자들에게 무엇을 보여줄 것인가를 고려한다. 팀은 모든 사람이 가능한 제품 증분의 다양한 측면을 이해하길 원한다.
- 스프린트 목표와 제품 백로그를 해당 스프린트의 실제 결과와 비교해서 그 차이점을 토론한다.
- 제품 아키텍처를 간략한 다이어그램으로 보여주고 설명할 수도 있다. 가장 효과적인 아키택처 다이어그램은 기술적인 아키텍쳐와 기능적인 아키텍처 두 개를 동시에 보여주는 것이다.
- 시연을 통해서, 팀은 참석자들이 해당 제품 증분의 강점과 약점 그리고 팀이 겪었던 난관들과 성공들을 이해할 수 있도록 힘써야 한다.
- 어느 누구도 스프린트 검토 회의 준비에 많은 시간을 투자하지 않도록 해야 한다. 이를 우해 파워포인트 프레젠테이션 혹은 그 유사한 것들은 모두 금지시킨다.
- 이 회의는 비평을 하거나 어떤 행동을 취하기 위한 것이 아니라 정보 교환을 위한 것이라는 점을 명심해야 한다.
</content:encoded></item><item><title><![CDATA[React Native 빌드 에러 (3)]]></title><description><![CDATA[Mac OS 를 쓰면서 마주한 React Native 빌드 에러에 대해 정리한다. M1 프로세서를 사용 중인데 이것이 원인 중 하나인지는 명확하지 않다.

iOS
1. Undefined symbol: _OBJC_CLASS…]]></description><link>https://ricale.kr/blogposts/220516-react-native-build-error-3</link><guid isPermaLink="false">https://ricale.kr/blogposts/220516-react-native-build-error-3</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Sun, 15 May 2022 15:00:00 GMT</pubDate><content:encoded>
Mac OS 를 쓰면서 마주한 React Native 빌드 에러에 대해 정리한다.

M1 프로세서를 사용 중인데 이것이 원인 중 하나인지는 명확하지 않다.

## iOS

### 1. Undefined symbol: \_OBJC_CLASS\_$_StockNewsdmManager

앱 보안 및 무결성을 위해, 외부 보안 솔루션을 사용한다. 해당 솔루션을 프로덕션 환경에만 적용해놨는데, 개발 환경 컴파일 때 해당 솔루션의 파일이 포함되면서 발생된 에러다.

컴파일에 포함되면 안 되는 파일은 Build Settings 에서 `excluded_source_file_names` 항목에 추가해주면 된다. 환경별로 따로 설정도 가능하다.

![](./1.png)

### 2. mach-o file, but is an incompatible architecture (have &apos;x86_64&apos;, need &apos;arm64e&apos;)

[@react-native-seoul/kakao-login](https://github.com/react-native-seoul/react-native-kakao-login) 를 사용해 카카오 로그인 연동 시 발생한 에러다. 상세 내용은 아래와 같다.

&gt; [!] CocoaPods could not find compatible versions for pod &quot;KakaoSDKUser&quot;:
&gt;
&gt; In Podfile:  
&gt; kakao-login (from `../node_modules/@react-native-seoul/kakao-login`) was resolved to 4.0.0, which depends on  
&gt; KakaoSDKUser (~&gt; 2.9.0)
&gt;
&gt; None of your spec sources contain a spec satisfying the dependency: `KakaoSDKUser (~&gt; 2.9.0)`.
&gt;
&gt; You have either:
&gt;
&gt; - out-of-date source repos which you can update with `pod repo update` or with `pod install --repo-update`.
&gt; - mistyped the name or version.
&gt; - not added the source repo that hosts the Podspec to your Podfile.

에러 내용을 자세히 안 봐서 좀 해멨는데 결국 repo update 를 해주면 될 일이었다.

```
$ pod install --repo-update
```

앗 그래도 에러가 나네?

&gt; LoadError - dlopen(/Library/Ruby/Gems/2.6.0/gems/ffi-1.15.5/lib/ffi_c.bundle, 0x0009): tried: &apos;/Library/Ruby/Gems/2.6.0/gems/ffi-1.15.5/lib/ffi_c.bundle&apos; (mach-o file, but is an incompatible architecture (have &apos;x86_64&apos;, need &apos;arm64e&apos;)), &apos;/usr/lib/ffi_c.bundle&apos; (no such file) - /Library/Ruby/Gems/2.6.0/gems/ffi-1.15.5/lib/ffi_c.bundle

그럼 아래처럼 해주면 되겠다. (아마도 M1 프로세서 한정)

```
$ arch -x86_64 pod install --repo-update
```

## 안드로이드

### 1. Error: Unexpected token name «\_890_340», expected punc «,»

자바스크립트는 긴 숫자의 가독성을 위해 [1_890_340 같은 형식의 문법을 제공](https://v8.dev/features/numeric-separators)한다. 그런데 이게 RN 안드로이드 환경에서는 에러를 발생시킨다.

&quot;\_&quot;를 지우니 에러가 발생하지 않았다. 내 더미 데이터의 가독성은 떨어졌지만 어차피 더미 데이터니까, 빨리 프로젝트에서 삭제할 날이 오기를 기도하기로 하자.
</content:encoded></item><item><title><![CDATA[Prettier 2.6 적용 및 자동화]]></title><description><![CDATA[원래는 Prettier 를 사용하지 않는다. 이유는 그들이 독선적인 코드 포맷터(Opinionated Code Formatter) 를 표방하기 때문이다. 설정 옵션을 최소화해서 스타일을 강제하고, 그럼으로써 (정답이 없는) 코드 스타일 논쟁을 원천…]]></description><link>https://ricale.kr/blogposts/220514-apply-prettier</link><guid isPermaLink="false">https://ricale.kr/blogposts/220514-apply-prettier</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Fri, 13 May 2022 15:00:00 GMT</pubDate><content:encoded>
원래는 [Prettier](https://prettier.io/) 를 사용하지 않는다. 이유는 그들이 **독선적인 코드 포맷터(Opinionated Code Formatter)** 를 표방하기 때문이다.

설정 옵션을 최소화해서 스타일을 강제하고, 그럼으로써 (정답이 없는) 코드 스타일 논쟁을 원천 봉쇄한다, 불필요한 논쟁이 없기 때문에 생산성이 향상된다, 이것이 그들의 철학이다.

나는 그 철학 자체는 동의하지만, 스타일은 동의할 수 없었다. 내가 타협할 수 없는 스타일이 있었으니, 그것은 아래 두 가지였다.

1. 함수 컴포넌트 선언부의 props 가 한 줄에 하나의 항목만 표시

   ```typescript
   // 내 스타일
   function SomeComp({ value, onChange }: SomeCompProps) {
     // ...
   }
   // Prettier 의 스타일
   function SomeComp({ value, onChange }: SomeCompProps) {
     // ...
   }
   ```

2. JSX 구문에서, 컴포넌트의 props 가 한 줄에 하나의 항목만 표시

   ```tsx
   // 내 스타일
   &lt;SomeComp
     value={someValue}
     onChange={handleChange}
   /&gt;
   // Prettier 의 스타일
   &lt;SomeComp value={someValue} onChange={handleChange} /&gt;
   ```

둘 중 하나만 되더라도 타협할 수 있었겠지만 Prettier 는 둘 다 되지 않았다. 오로지 글자수로만, `printWidth` 라는 옵션에 의해서만 props 를 한 줄에 모두 표시할지, 한 줄에 하나씩 표시할지를 판단했다.

그래서 마음에 들지 않아 쓰지 않고 있었다.

## 1. Single Attribute Per Line 옵션

그런데 드디어 22년 4월에 공개된 2.6.0 버전부터 &quot;JSX 구문에서, 컴포넌트의 props 가 한 줄에 하나의 항목만 표시&quot;하는 기능을 지원하기 시작했다. 그것이 이 [`singleAttributePerLine`](https://prettier.io/docs/en/options.html#single-attribute-per-line) 옵션이다.

얼마 전 우연히 옵션을 확인하고 나서야, 드디어 Prettier 와 타협할 마음이 생겼다. 자, 타협을 하였으니 적용해보자.

## 2. Prettier 2.6 설치

위에서 언급한 `singleAttributePerLine` 옵션을 사용하기 위해서는 2.6.0 이상의 버전을 설치해야 한다.

### 2.1. Prettier 새로 설치

Prettier 가 설치되어있지 않은 프로젝트는 아래 명령어로 설치해주면 된다.

```
yarn add --dev prettier
```

### 2.2. Prettier 버전 업그레이드

Prettier 가 설치되어있다면 버전을 올려줘야 한다.

Prettier 를 직접 설치해 사용하고 있었다면 아래 명령어를 실행해주면 된다.

```
yarn upgrade prettier@^2.6.2
```

#### 2.2.1. Prettier 가 설치한 다른 라이브러리의 디펜던시로 포함되어 있었다면

[@react-native-community/eslint-config](https://www.npmjs.com/package/@react-native-community/eslint-config) 처럼 Prettier 를 디펜던시로 포함하고 있는 라이브러리를 사용하고 있다면 Prettier 를 직접 설치한 적이 없더라도 설치되어 있을 것이다.

설치가 되어있는지 확실히 알아보려면 yarn.lock 파일에서 `prettier@` 로 검색해보자. 설치되어 있다면 아래와 같은 구문을 찾을 수 있다.

```
prettier@^2.0.2:
  version &quot;2.5.1&quot;
  resolved &quot;https://registry.yarnpkg.com/prettier/-/prettier-2.5.1.tgz#fff75fa9d519c54cf0fce328c1017d94546bc56a&quot;
  integrity sha512-vBZcPRUR5MZJwoyi3ZoyQlc1rXeEck8KgeC9AwwOn+exuxLxq5toTRDTSaVrXHxelDMHy9zlicw8u66yxoSUFg==
```

만약 `version` 부분이 2.6.0 이상이면 제대로 설치되어 있는 것이므로 업그레이드를 할 필요가 없다. 그 이전 버전이라면, 버전을 올려줘야 한다.

어떻게 업그레이드 할까? `yarn upgrade prettier@^2.6.2` 로 해주면 될까? 해당 명령어를 실행하면 package.json 파일에는 prettier 가 추가되고

```js
// package.json
{
  &quot;prettier&quot;: &quot;^2.6.2&quot;
}
```

yarn.lock 파일은 아래처럼 바뀐다.

```
prettier@^2.0.2:
  version &quot;2.5.1&quot;
  resolved &quot;https://registry.yarnpkg.com/prettier/-/prettier-2.5.1.tgz#fff75fa9d519c54cf0fce328c1017d94546bc56a&quot;
  integrity sha512-vBZcPRUR5MZJwoyi3ZoyQlc1rXeEck8KgeC9AwwOn+exuxLxq5toTRDTSaVrXHxelDMHy9zlicw8u66yxoSUFg==

prettier@^2.6.2:
  version &quot;2.6.2&quot;
  resolved &quot;https://registry.yarnpkg.com/prettier/-/prettier-2.6.2.tgz#e26d71a18a74c3d0f0597f55f01fb6c06c206032&quot;
  integrity sha512-PkUpF+qoXTqhOeWL9fu7As8LXsIUZ1WYaJiY/a7McAQzxjk82OF0tibkFXVCDImZtWxbvojFjerkiLb0/q8mew==
```

이 상태로 Prettier 를 실행했을 때 2.6 버전이 잘 적용된다면 다음 항목으로 넘어가면 된다.

하지만 내 경우에는 위처럼 해도 2.5.1 버전이 적용되고 2.6 버전의 기능이 적용되지 않았다. node_modules 디렉토리를 다 지우고 다시 설치해도 해결되지 않았다. (이유는 불명)

결국 내가 선택한 방법은 yarn.lock 에서 2.5.1 버전을 제거하는 것이었다.

직접 새로 설치 혹은 업그레이드한 Prettier 는 지우고 (`yarn remove prettier`) yarn.lock 을 아래처럼 직접 편집했다.

```
prettier@^2.0.2:
  version &quot;2.6.2&quot;
  resolved &quot;https://registry.yarnpkg.com/prettier/-/prettier-2.6.2.tgz#e26d71a18a74c3d0f0597f55f01fb6c06c206032&quot;
  integrity sha512-PkUpF+qoXTqhOeWL9fu7As8LXsIUZ1WYaJiY/a7McAQzxjk82OF0tibkFXVCDImZtWxbvojFjerkiLb0/q8mew==
```

수정한 뒤 다시 `yarn` 을 실행한 후 Prettier 를 실행하니 2.6.2 버전이 잘 적용되었다.

## 3. 옵션 설정

`singleAttributePerLine` 이외에도 Prettier 는 20여가지의 옵션을 제공한다. [공식 문서](https://prettier.io/docs/en/options.html)에 잘 설명되어있기 때문에 여기서 부언하지는 않겠다.

옵션은 프로젝트의 최상단 디렉토리의 `.prettierrc.js` 파일에 작성하면 된다.

```js
// .prettierrc.js
module.exports = {
  printWidth: 95,
  singleQuote: true,
  arrowParens: &quot;avoid&quot;,
  singleAttributePerLine: true,
};
```

js 파일로 작성하고 싶지 않다면 JSON, YAML 등 다른 형식으로도 가능하다. 자세한 방법은 [공식 문서](https://prettier.io/docs/en/configuration.html)를 참고하시라.

## 4. 자동화

이런 툴은 자동화가 필수다. 필요할 때마다 직접 실행한다면 생각보다 번거롭고 까먹기도 쉽기 때문이다.

자동화를 하는 방법에는 두 가지가 있다. 하나는 git 의 pre-commit 훅을 이용하는 것이고, 다른 하나는 에디터의 기능을 이용하는 것이다.

### 4.1. pre-commit 훅을 사용해 자동화

pre-commit 훅은 커밋 명령어 실행 시 커밋 직전에 실행되는 스크립트다.

pre-commit 훅을 사용해 자동화하는 방법은 일전에 작성한 [ESLint 적용 및 자동화](https://ricale.kr/blog/posts/210325-apply-eslint/) 글에서 확인할 수 있다.

Prettier 를 ESLint 플러그인으로 사용하고 있는 경우에는 해당 글과 똑같이 하면 된다. 만약 단독으로 사용하고 있다고 해도 방법이 크게 다르지 않으니 해당 글을 참고하시라.

### 4.2. 에디터 기능을 사용해 자동화

에디터를 사용해 소스코드를 저장할 때마다 Prettier 를 적용할 수도 있다. 개인적으로 Prettier 는 pre-commit 훅을 사용하는 것보다는 이 방식을 선호한다. 왜냐하면 ESLint 는 ESLint 가 자동으로 고칠 수 없는 에러들이 존재하지만, Prettier 는 그렇지 않기 때문이다.

현재 VSCode 를 사용하고 있기 때문에 VSCode 를 기준으로 방법을 설명하겠다.

#### 4.2.1. 먼저 [Prettier - Code formatter](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode) 익스텐션을 설치해준다.

![](./4-2-1.png)

#### 4.2.2. 그리고 설정에서 Default formatter 를 방금 설치한 익스텐션으로 설정해준다.

![](./4-2-2.png)

#### 4.2.3. 마지막으로 Format on save 설정을 켜준다.

![](./4-2-3.png)

이 설정까지 완료하면 js/ts 파일을 저장할 때마다 Prettier 가 자동으로 적용된다.

## 5. 플러그인: prettierX

Prettier 의 지나치게 적은 옵션이 불만이라면 [prettierX](https://github.com/brodybits/prettierx) 를 고려하는 것도 좋은 선택이 될 수 있다.

이 라이브러리는 Prettier 의 fork 프로젝트로 Prettier 보다 더 많은 옵션을 제공한다. 단독으로 쓸 수도 있고 Prettier 의 플러그인 형태로도 쓸 수 있다.

(개인적으로는 딱히 필요한 옵션이 없어서 쓰지 않고 있다.)

## 참고

- [Prettier 공식 문서](https://prettier.io/docs/en/index.html)
- [ESLint 적용 및 자동화](https://ricale.kr/blog/posts/210325-apply-eslint/)
</content:encoded></item><item><title><![CDATA[읽은 좋은 글들 (~22.5.10)]]></title><description><![CDATA[메일링, 블로그, 구글링 등을 통해 읽은 좋은 글들을 모아놓은 글이다.]]></description><link>https://ricale.kr/blogposts/220510-read-writings</link><guid isPermaLink="false">https://ricale.kr/blogposts/220510-read-writings</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Mon, 09 May 2022 15:00:00 GMT</pubDate><content:encoded>
이 글은 메일링, 블로그, 구글링 등을 통해 읽은 좋은 글들을 모아놓은 글이다.

## JavaScript

### [JavaScript Symbol의 근황](https://meetup.toast.com/posts/312)

`Symbol` 에 대한 간략한 소개. 지나가다가 `Symbol.iterator`만 몇 번 본 적 있지 `Symbol` 그 자체에 대해서는 무지했는데, 이 글을 통해 간략하게나마 알게 되었다. 훑어보기에 좋은 글이다.

### [How return await can slow down your code](https://arthur.place/the-cost-of-return-await)

`return await someAsyncFunc()` 형식의 사용이 성능 상 좋지 않은 점에 대해 설명하는 글.

```js
// 1
async function doWait() {
  return await work();
}

// 2
async function dontWait() {
  return work();
}

// 3
function justReturn() {
  return work();
}
```

세 코드 모두 결과는 같다. 다만 퍼포먼스 관점에서는 3번이 제일 낫다. 왜냐하면 1, 2번 코드는 `work()` 가 하는 일이 promise 이든 non-promise 이든, 무조건 이벤트 루프를 타기 때문이다.

(사실 2번은 좀 명확하지 않다. 본문의 벤치마크 결과에서 `async () =&gt; await work()` 가 느린 건 명확하게 나왔는데, 뜬금없이 다른 예를 `() =&gt; await work()`라고 표시하고 있기 때문이다. 문맥상 `async () =&gt; work()` 의 오기일 것 같긴 하다.)

본문에는 위 내용에 더해 벤치마크 방법과 결과, 에러 핸들링 방식, eslint 로 1,2번 형식을 방지하는 방법 등이 나와있다. 읽어보기를 권한다.

## React

### [Testing Overview - React](https://reactjs.org/docs/testing.html)

React 에서 테스트를 하고 싶다고? 그렇다면 멀리 갈 필요 없다. 공식 문서에 너무나도 잘 정리가 되어있다. 해당 문서인 오버뷰는 물론 하위 문서들도, 짧지만 알차게 작성되어 있다.

- [Testing Recipes](https://reactjs.org/docs/testing-recipes.html)
- [Testing Environments](https://reactjs.org/docs/testing-environments.html)

그동안 &quot;javascript test framework&quot; 등으로 구글링만 하며 공식 문서를 무시했었던 과거를 반성해본다.

덧붙여 React Native 를 위한 공식 문서도 따로 있다.

- [Testing - React Native](https://reactnative.dev/docs/testing-overview)

### [File-based routing with React Router](https://omarelhawary.me/blog/file-based-routing-with-react-router)

Next.js 없이 file-based 라우팅을 구현하는 글. 문제는 CRA나 Webpack dev server 없이, [Vite](https://vitejs.dev/) 라는 툴을 사용해야 하는 것 정도.

Vite 의 [Glob Import](https://vitejs.dev/guide/features.html#glob-import) 기능이 주요하게 쓰인다. Vite 없이 이 기능만 쓸 수 없나 하고 구글링을 좀 해보았는데 찾지 못했다. 그나마 비슷한 게 [import-glob](https://github.com/terpiljenya/import-glob) 정도. 이 코드를 참고해 Webpack loader 를 직접 구현해야 하지 않을까 싶다.

이 글은 시리즈 중 첫 편이다. 시리즈의 다른 글들도 천천히 살펴 볼 생각이다.

### [use-clamp-text](https://github.com/drenther/use-clamp-text)

여러 줄의 문자열을 원하는 줄 수 만큼만 보여주고 생략처리를 해주는 라이브러리(hook). 코드가 길지 않아서 (173라인) 천천히 읽어봐도 괜찮다. 내부적으로 이진 탐색을 사용했다.

## Etc

### [웹프론트엔드 개발자의 Rust 돌려까기](https://boostbrothers.notion.site/Rust-aefb960939804ef898f07a944651d23c)

Rust 를 사용?학습?해 본 프론트엔드 개발자의 후기. GC 가 없고 소유권이라는 개념을 사용하며 진입장벽이 높다고 한다. 나중에 한 번 학습해봐야겠다.

### [Refresh Token과 Sliding Sessions를 활용한 JWT의 보안 전략](https://blog.ull.im/engineering/2019/02/07/jwt-strategy.html)

JWT 토큰을 사용해 세션을 관리할 때 전략 별로 어떤 장단점이 있는지 정리한 글이다. 글에서 분류한 전략은 네 가지가 있다.

- Access Token 사용
- Sliding Session 전략 + Access Token 사용
- Access Token + Refresh Token 사용
- Sliding Session 전략 + Access Token + Refresh Token 사용

각 전략의 장단점은 본문에 잘 나와있다. 결론은 적용하려는 서비스의 특성에 맞게 올바른 전략을 사용해야 한다는 것이다.

### [[TIL] Why need refresh token?](https://leonkong.cc/posts/til-jwt-and-refresh-token.html)

Refresh Token 그 자체는 Access Token 과 같은 토큰일 뿐이다. Access Token 보다 보안상 우위에 있을 수는 없다. Refresh Token 의 보안은 서버 측에서 안전한 DB/store 에 저장하면서 관리해야지만 의미가 있다.

라는 내용이다.
</content:encoded></item><item><title><![CDATA[프론트엔드 테스트 코드를 도입하자 - 1. 어떤 것을 해야 하나]]></title><description><![CDATA[회사에서 한두 달 전에 새로 시작한 프론트엔드 프로젝트에 테스트를 도입하기로 했다. 고백하자면, 테스트를 적용한 경험은 적다. 기껏해야 간단한 유틸 함수들에 대한 유닛 테스트가 전부다. 통합 테스트는 고사하고 뷰 테스트, 컴포넌트 테스트 등도 해 본…]]></description><link>https://ricale.kr/blogposts/220509-frontend-test-code-1</link><guid isPermaLink="false">https://ricale.kr/blogposts/220509-frontend-test-code-1</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Sun, 08 May 2022 15:00:00 GMT</pubDate><content:encoded>
회사에서 한두 달 전에 새로 시작한 프론트엔드 프로젝트에 테스트를 도입하기로 했다.

고백하자면, 테스트를 적용한 경험은 적다. 기껏해야 간단한 유틸 함수들에 대한 유닛 테스트가 전부다. 통합 테스트는 고사하고 뷰 테스트, 컴포넌트 테스트 등도 해 본 적 없다.

하지만 언제까지 이렇게 테스트를 외면할 수는 없다. 애자일한 프로그래머를 지향하는 자, 테스트를 멀리할 수 없다. 아직 프로젝트가 초기 단계인 지금이 기회라고 생각하고 하나하나 차근차근 적용해 보려고 한다.

그럼 일단 프론트엔드 소프트웨어 테스트에는 어떤 것들이 있는지, 어떻게 도입하면 좋을지부터 간단히 정리해보겠다.

(진행하고 있는 프로젝트가 React Native 프로젝트이기 때문에 React Native 관점에서 작성한다. 하지만 사용하는 세부 라이브러리들만 다를 뿐, 개념적으로는 React 및 기타 다른 프론트엔드 프로젝트에도 적용 가능하다.)

### 목차

1. 테스트해야 할 것들
2. 결론
3. 참고 자료

# 테스트해야 할 것들

테스트를 고려할 수 있는 것은 크게 다섯 가지가 있다.

0. 선행할 것들
1. 단위 테스트
2. React 테스트
3. API 콜 테스트
4. 통합 테스트
5. 기타 테스트

각각 어떤 것이 중요한지, 어떻게 적용하면 좋을지 간단히 살펴보자.

## 0. 선행할 것들

본격적인 테스트 코드를 작성하기 전에 선행하면 좋을 것들이 있다.

### 0.1. linter or/and prettier

코드 퀄리티 유지를 위해서 linter 혹은/그리고 [Prettier](https://prettier.io/) 가 필수다.

linter 는 [ESLint](https://eslint.org/) 와 [Git 의 pre-commit hook](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks) 과 결합해 프로젝트에 [적용](https://ricale.kr/blog/posts/210325-apply-eslint/)해두었다.

Prettier 또한 vscode 의 format on save 기능을 활용해 적용해두었다.

### 0.2. type checking

마찬가지로 코드 퀄리티 유지를 위해 [Flow](https://flow.org/) 혹은 [TypeScript](https://www.typescriptlang.org/) 를 사용하면 좋다. 우리 프로젝트에선 이미 TypeScript 를 사용하고 있다.

## 1. 단위 테스트

### 1.1. 대상 및 원칙

단위 테스트는 가장 작은 단위의 함수에 대한 테스트를 의미한다. 일단 단위 테스트 코드를 작성하기에 앞서 함수들을 testable 하게 작성하는 것이 중요하다.

testable 한 코드에는 많은 특성이 있겠지만, 아래 두 특성이 제일 중요하다고 생각한다.

- [순수](https://en.wikipedia.org/wiki/Pure_function)하다.
- 함수와 비즈니스 로직과 분리되어 있다.

모든 함수에 대해 단위 테스트를 작성할 필요는 없다.

- 일단 testable 하지 않은 코드들은 리팩토링이 선행되어야 할 것이다.
- 특정 모듈에 대해 사용자가 사용할 가능성이 없는 메서드 (예를 들면 private 멤버) 도 생략해도 된다.
- 처음부터 커버리지 백퍼센트를 노리기보다는 함수의 크기/중요도에 따라 단계적으로 적용하는 게 좋다.

### 1.2. 네이밍 컨벤션

각 테스트 케이스에 대해 이름을 잘 짓는 것도 중요하다. 보편적인 네이밍 컨벤션으로는 &quot;It Should&quot; 형식 혹은 &quot;Given/When/Then&quot; 형식이 있다. 각 컨벤션에 대해서 어떤 형식이 좋을지는 아래 글들을 참고하자.

- [Naming Your Unit Tests: It Should vs. Given/When/Then](https://markus.oberlehner.net/blog/naming-your-unit-tests-it-should-vs-given-when-then/)
- [GivenWhenThen](https://martinfowler.com/bliki/GivenWhenThen.html)
- [A guide to unit testing in JavaScript](https://github.com/mawrkus/js-unit-testing-guide)

(개인적으로 &quot;It Should&quot; 형식을 선호한다.)

### 1.3. 툴

&quot;javascript test framework&quot; 혹은 &quot;javascript unit test&quot; 라고 구글링하면 많은 프레임워크가 검색된다. 그 중 검색순위가 높기도 하면서 React 및 React Native 에 기본적으로 내장되어있는 [Jest](https://jestjs.io/) 를 사용할 예정이다.

### 1.4. 적용 방안

일단 testable 하면서 단순한 유틸성 함수들을 대상으로 적용해 볼 예정이다. 네이밍은 &quot;It should&quot; 방식으로 한다. 오늘 언급하는 테스트 중 유일하게 경험이 있는 테스트이므로 어려움이 있을 것 같지는 않다.

## 2. React 테스트

React 에서는 테스트를 할 항목이 크게 두 가지가 있는 것으로 보인다. 하나는 커스텀 hooks, 다른 하나는 컴포넌트다.

### 2.1. Custom Hooks

[React hooks](https://reactjs.org/docs/hooks-intro.html) 는 testable 한 코드가 아니다. [closure](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures) 를 활용하면서 dependency 에 의한 사이드 이펙트를 일으키는 함수다. 따라서 일반적인 단위 테스트 코드로는 테스트가 어렵다.

다행히도 React hooks 를 위한 테스팅 라이브러리가 존재한다 ([react-hooks-testing-library](https://github.com/testing-library/react-hooks-testing-library)). 해당 라이브러리에서는 hook 테스팅 원칙을 아래처럼 제안한다.

&gt; 언제 이 라이브러리를 사용하는가
&gt;
&gt; - 당신이 컴포넌트와 직접적으로 연결되지 않은 커스텀 훅을 작성했을 때
&gt; - 당신이 작성한 훅이 컴포넌트의 인터렉션 테스트만으로는 테스트하기 어려울 때
&gt;
&gt; 언제 이 라이브러리를 사용하지 않는가
&gt;
&gt; - 당신이 작성한 훅이 컴포넌트와 나란히 정의되어있고 그 컴포넌트에서만 쓰일 때
&gt; - 당신이 작성한 훅을 사용한 컴포넌트를 테스트하는 것으로 당신의 훅이 테스트될 수 있을 때

이러한 원칙대로라면 사실 테스트할 hook 이 많지 않긴 하다. 그래도 있기는 하므로, 살펴보고 작성해 볼 가치는 있다.

### 2.2. 컴포넌트

컴포넌트를 테스트하기 위한 관점은 두 가지가 존재한다. 하나는 컴포넌트를 사용하는 사용자의 관점에서 하는 interaction 테스트, 다른 하나는 어떻게 렌더링되는지에 대한 render 테스트다.

#### 2.2.1. interaction 테스트

interaction 테스트는 어디까지나 사용자의 사용 관점에서 테스트를 한다. 따라서 state 혹은 props 값에 대한 테스트는 하지 않고 사용자가 보는 것과 발생할 이벤트에 대해 초점을 맞춰서 진행한다.

아래 예제 코드([출처](https://reactnative.dev/docs/testing-overview#testing-user-interactions))를 보면 대략 감이 올 것이다.

```js
test(&quot;given empty GroceryShoppingList, user can add an item to it&quot;, () =&gt; {
  const { getByPlaceholder, getByText, getAllByText } = render(
    &lt;GroceryShoppingList /&gt;
  );

  fireEvent.changeText(getByPlaceholder(&quot;Enter grocery item&quot;), &quot;banana&quot;);
  fireEvent.press(getByText(&quot;Add the item to list&quot;));

  const bananaElements = getAllByText(&quot;banana&quot;);
  expect(bananaElements).toHaveLength(1); // expect &apos;banana&apos; to be on the list
});
```

이 테스트 코드는 Jest 에서는 기본적으로 제공하지 않기 때문에, [React Native Testing Library](https://callstack.github.io/react-native-testing-library/) 를 써야만 한다.

#### 2.2.2. render

render 테스트는 컴포넌트가 렌더링된 결과에 대한 테스트다. 그런데 그 테스트 방식이 다소 당황스럽다.

&gt; The snapshot test then creates a snapshot and saves it to a file in your repo as a reference snapshot. The file is then committed and checked during code review. (출처: [Testing Rendered Output](https://reactnative.dev/docs/testing-overview#testing-rendered-output))

&gt; A typical snapshot test case renders a UI component, takes a snapshot, then compares it to a reference snapshot file stored alongside the test. (출처: [Snapshot Testing](https://jestjs.io/docs/snapshot-testing))

정리하자면 컴포넌트의 렌더링 결과를 jsx-like 문자열로 생성한 뒤에 해당 문자열을 **미리 작성해 둔 jsx-like 문자열과 비교**하거나 **동료에게 코드 리뷰 요청**해야 한다는 것이다.

일단 개인적으로 &quot;코드 리뷰를 요청&quot;하는 방법은 테스트 코드의 범주를 벗어난다고 생각된다. 따라서 사용하지 않는다.

&quot;미리 작성해 둔 jsx-like 문자열과 비교&quot;하는 방법 또한, 변화가 잦은 프로젝트 초기에 도입할 내용은 아니라고 생각한다. 따라서 render 테스트도 _당장은_ 도입하지 않을 것이다.

도입하지는 않지만 나중에 생각이 바뀔 수도 있으므로, 어떤 툴을 써야하는지는 정리해두자. render 테스트는 Jest 와 [react-test-renderer](https://reactjs.org/docs/test-renderer.html) 의 조합으로 작성할 수 있다.

### 2.2.3. mock-up

데이터 목업 또한 필요하다. 데이터 독립적인, 비즈니스 로직에 대해 독립적인 컴포넌트를 테스트할 때야 문제 없지만, 모든 컴포넌트를 데이터 독립적으로 작성할 수는 없다. fetch 콜 등 데이터와 결합된 컴포넌트도 테스트할 때가 올 것이다.

다행히 멀리 갈 것 없이 [React Testing Library](https://testing-library.com/docs/react-testing-library/intro)에서 [목업](https://testing-library.com/docs/react-testing-library/example-intro#mock)을 제공한다.

### 2.3. 적용 방안

React 테스트는 hooks 테스트와 interaction 테스트를 적용해볼 예정이다. render 테스트는 당장 염두에 두지 않는다.

## 3. API 콜 테스트

API 콜에 대한 테스트 코드를 작성해보고 싶은 마음이 있다. 하지만 이 테스트를 프론트엔드에서 하는 것이 맞는지 의문이다. 백엔드 엔지니어가 당연히 각각의 API 콜에 대한 테스트 코드를 작성할텐데, 프론트엔드에서 똑같은 API 콜에 대해 테스크 코드를 작성한다면 단순히 코드 중복일 뿐이기 때문이다. 거기다가 프론트엔드의 테스트 때문에 API 콜 요청 수가 늘어나면 서버 리소스도 낭비된다.

&quot;javascript fetch testing&quot; 으로 구글링하면 fetch 테스트에 대한 내용은 거의 없고 뷰/컴포넌트 테스트를 위해 fetch 를 mock-up 하는 방법들이 대부분인 것도 이런 이유가 아닐까 싶다.

일단 구글링도 더 해보고 백엔드 엔지니어 분들의 의견도 들어봐야 할 것 같지만, 작성하지 않을 가능성이 크다.

## 4. 통합 테스트

통합 테스트는 앱의 여러 부분이 같이 동작하는 것을 테스트하는 것을 의미한다. 말그대로 사용자 관점에서 테스트를 한다고 생각하면 이해하기 쉽다. 예를 들면 &quot;사용자가 사이트에 접속해 로그인을 완료하기까지의 과정&quot;을 하나의 시나리오로 잡고 테스트 케이스를 만들 수 있다.

통합 테스트를 직접 해 본 적은 없지만 몇 년 전 상급자가 사용하는 것을 본 적은 있다. [Selenium](https://www.selenium.dev/)과 [Capybara](https://github.com/teamcapybara/capybara)를 [조합해서](https://medium.com/airbnb-engineering/integration-testing-with-selenium-and-capybara-3cfbf3d1b5b1) 쓰셨던 걸로 기억하는데, 오랜 시간이 지나서 잘 기억나지 않음에도, 상급자가 매우 고생했던 것은 기억에 남는다. 테스트 코드를 구성하는 것도 쉽지 않고, Selenium 이 내부적으로 브라우저 엔진을 띄워서 그 위에서 테스트 코드를 실행했으므로 테스트 실행 시간 또한 짧지 않았다.

좋은 테스트 시나리오를 만들기도 쉽지 않은 데다가, 대부분의 프로덕트는 살아있으므로 업데이트를 할 때마다 시나리오가 (조금이라도) 바뀌는 경우가 많아 유지보수하는데도 신경 쓸 것이 많았던 걸로 기억한다.

일단 다른 테스트들이 성공적으로 도입된 이후에, 그리고 프로젝트가 어느정도 안정기에 들어선 다음에 도입을 고려해야겠다.

## 5. 기타 테스트

추가적으로 신경써야 할 테스트들은 아래와 같다.

- Redux store
- routing 혹은 navigation

이 항목들은 사용하는 라이브러리에 따라 테스트 코드 작성 방식도 변경될 수 있으므로 추가적인 리서치가 필요할 것으로 보인다. 최소한 **2. React 테스트** 정도는 끝낸 뒤에야 도입을 고려할 듯 싶다.

# 결론

일단 **1. 단위 테스트**와 **2. React 테스트**에 중점을 두고 테스트를 도입해 볼 예정이다. 두 항목에 대해 어느정도 궤도에 올랐을 때 **5. 기타 테스트**에서 언급한 테스트들을 살펴볼 것이다. **3. API 콜 테스트**와 **4. 통합 테스트**에 대해서도 계속 알아보긴 하겠지만, 도입하지 않거나 최후에야 도입할 것 같다.

1. 단위 테스트: 도입 중
2. React 테스트: 도입 예정
3. API 콜 테스트: 도입하지 않을 가능성이 높음
4. 통합 테스트: 도입한다면 가장 마지막에
5. 기타 테스트: 1,2번이 어느정도 도입되면 도입 시작

도입 과정은 블로그에 계속해서 남겨 볼 생각이다.

# 참고 자료

다른 글들도 참고하긴 했지만, 아래 두 문서 (및 두 문서에 연결된 문서들) 의 내용을 주로 참고해 작성하였다.

- [Testing Overview - React](https://reactjs.org/docs/testing.html)
- [Testing - React Native](https://reactnative.dev/docs/testing-overview#component-tests)
</content:encoded></item><item><title><![CDATA[읽은 좋은 글들 (~22.5.3)]]></title><description><![CDATA[메일링, 블로그, 구글링 등을 통해 읽은 좋은 글들을 모아놓은 글이다.]]></description><link>https://ricale.kr/blogposts/220503-read-writings</link><guid isPermaLink="false">https://ricale.kr/blogposts/220503-read-writings</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Mon, 02 May 2022 15:00:00 GMT</pubDate><content:encoded>
## JavsScript

### [JavaScript function composition: What’s the big deal?](https://jrsinclair.com/articles/2022/javascript-function-composition-whats-the-big-deal/)

함수 합성(Function composition)에 관한 글. 함수 합성이 무엇이며, 어떻게 구현하며, 함수 합성을 사용하지 않는 다른 구현과는 어떻게 다른가를 설명한다.

글쓴이는 구현 자체보다는 생각/발상의 전환이 가장 큰 장점이라고 말한다. 그 말이 인상깊었다.

&gt; But the real beauty of composition isn’t in the code, but in how it changes us. How it gives us new ways of thinking about code.

### [자바스크립트는 왜 프로토타입을 선택했을까](https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42)

자바스크립트의 `prototype` 의 존재 이유를, 서양의 철학적인 배경을 기반으로 설명하는 글. ES6 부터 프론트엔드 개발자로 입문했다면, 그래서 `prototype` 을 써 본 적이 없는 사람이라면 이해하는데 도움이 될지도 모르겠다.

## TypeScript

### [How Microsoft Wants To Change TypeScript](https://betterprogramming.pub/how-microsoft-wants-to-destroy-typescript-1f1a53b18de6)

MS의 타입스크립트 개발진이, 자바스크립트에 타입을 적용하는 제안서를 TC39에 제출했다고 한다. 그 이슈에 대한 의견을 담은 글이다.

일단 MS 개발진이 제안한 타이핑은 기존 코드에 영향이 가지 않도록 주석 형태로 타이핑을 하는 것이라고 한다.

글쓴이는 주석 타이핑으로는 TypeScript 의 모든 기능을 대체할 수는 없으며, 때문에 타이핑은 JavsScript 와 독립적으로 관리되어야 한다고 주장한다.

간략한 타입스크립트 역사와 함께 이슈가 정리되어있어 읽어볼 만 한 글이다.

## Etc

### [\[번역\] 웹 스토리지 : 무엇을 써야할까요?](https://han41858.tistory.com/54)

브라우저에서 스토리지는 무엇을 쓰는 게 좋을까? 라는 주제의 글인데, 서문에서부터 cache storage 와 indexedDB 를 쓰라고 운을 띄우면서 시작한다.

&gt; 최근 브라우저들은 IndexedDB와 캐시 스토리지 API를 모두 지원합니다. 이 스토리지들은 모두 비동기(asynchronous)로 동작하기 때문에 메인 스레드 연산에 영향을 주지 않습니다.

local storage, session storage 가 동기적이어서 메인 스레드를 붙잡는데 반해 indexedDB 는 비동기적으로 동작한다고 한다. 이것 하나만으로도 쓸만한 가치가 있는 것 같다.

이외에도 저장 용량 확인, 에러 핸들링, 디버깅 등 유용한 정보가 많으니 읽어보기를 권한다.

### [Securely embed content on your site](https://developer.chrome.com/blog/embed-content/)

보안상 안전하게 컨텐츠를 embedding 하는 방법에 대해 소개한다. `&lt;iframe /&gt;` 의 `sandbox`, `allow` 속성, `&lt;fencedframe /&gt;`, `&lt;portal /&gt;` 엘리먼트에 대해 나와있다.

임베드 컨텐츠를 많이 써보지 않아서 그다지 와닿는 글은 아니지만, 관련 키워드를 알아둬서 나쁠 것은 없다. 나중에 사용하게 될 때 되새김질하면 될 듯 하다.

### [Explain the First 10 Lines of Twitter’s Source Code to Me](https://css-tricks.com/explain-the-first-10-lines-of-twitter-source-code/)

Twitter 소스 코드의 첫 열 라인에 대한 설명이 담긴 글.

본문도 재미있지만 댓글도 재미있다. 글의 서두에서 글쓴이가 &quot;이 열 줄을 얼마나 알고 있는가&quot;로 기술 면접을 한다고 말했는데, 몇몇 사람들이 대부분 이 내용이 기술면접에 쓰이기에는 적절하지 않다고 말하고 있다. 누구의 의견이 옳던 간에 (공격적인 내용은 적당히 흘리고) 다른 사람들의 의견들을 같이 읽어보는 것도 좋을 것 같다.

한 번 읽어보기에는 나쁘지 않은 글이다.
</content:encoded></item><item><title><![CDATA[nvm 으로 프로젝트별 Node.js 버전 설정하기]]></title><description><![CDATA[nvm 은 하나의 컴퓨터에 여러 버전의 Node.js 를 설치하고 관리할 수 있게 해주는 툴이다. 한 컴퓨터에 하나 이상의 프로젝트를 진행하고 있을 때, 각각의 프로젝트의 기반 nodejs 버전이 다를 경우 필수적으로 사용해야 한다. nvm 이…]]></description><link>https://ricale.kr/blogposts/220502-node-version-by-project</link><guid isPermaLink="false">https://ricale.kr/blogposts/220502-node-version-by-project</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Sun, 01 May 2022 15:00:00 GMT</pubDate><content:encoded>
[nvm](https://github.com/nvm-sh/nvm) 은 하나의 컴퓨터에 여러 버전의 [Node.js](https://nodejs.org/en/) 를 설치하고 관리할 수 있게 해주는 툴이다. 한 컴퓨터에 하나 이상의 프로젝트를 진행하고 있을 때, 각각의 프로젝트의 기반 nodejs 버전이 다를 경우 필수적으로 사용해야 한다.

nvm 이 설치되어 있을 때, 프로젝트 별로 어떻게 nodejs 버전을 지정하고 자동으로 버전을 변경할 수 있는지 알아보자.

## 0. `nvm` 설치 및 기본적인 사용 방법

[공식 문서](https://github.com/nvm-sh/nvm/blob/master/README.md)를 참고하시라.

## 1. `.nvmrc`

프로젝트에 nodejs 버전을 기록하기 위해, 프로젝트 최상단에 `.nvmrc` 파일을 만들자. 내용은 아래처럼 넣어주면 된다.

```
v14.17.6
```

## 2. `nvm use`

nodejs 버전을 변경하기 위해서는 `.nvmrc` 파일이 있는 프로젝트 최상위 디렉토리에서 아래 명령어를 실행하면 된다.

```bash
$ nvm use
Found &apos;/Users/ricale/workspace/somewehre/my-project/.nvmrc&apos; with version &lt;v14.17.6&gt;
Now using node v14.17.6 (npm v6.14.15)
```

이제 해당 셸 인스턴스의 nodejs 버전은 `.nvmrc` 에 기록된 `v14.17.6` 으로 변경되었다.

## 3. 자동화

프로젝트를 사용할 때마다 최상위 디렉토리에서 `nvm use`를 사용하는 것은 생각보다 번거롭고 잊어버리기 쉬운 일이다. 그래서 자동으로 nodejs 버전이 변경되도록 할 것이다.

접근법은 두 가지가 있다.

(a) 하나는 iTerm2 등 터미널 앱에서 특정 프로필을 실행할 시 `nvm use` 를 사용하게 하는 방법이고,
(b) 다른 하나는 `package.json` 에 등록된 특정 `scripts` 명령어에서 `nvm use`를 선행하게 하는 방법이다.

### 3.a. 터미널 앱으로 `nvm use` 를 자동으로 사용하게 하는 방법

iTerm2 이외의 다른 터미널 앱은 사용한 적이 없으므로 해당 앱 기준으로 설명한다.

![](./3-a-01.png)

0. 최상단 메뉴의 [iTerm2] - [Preferences...] 선택 후
1. [Profiles] 탭 선택
2. [+] 버튼을 눌러 프로필을 추가
3. 프로필 이름 입력
4. 해당 프로필로 셸 실행 시 시작지점이 될 디렉토리 입력
5. 해당 프로필로 셸 실행 시 자동으로 입력될 명령어. 별도의 스크립트 실행 없이 nodejs 버전만 맞추고 싶다면 `nvm use` 만 입력해도 된다.

### 3.b. `package.json` 에 `scripts` 수정 혹은 추가하는 방법

CRA 로 앱을 생성했을 경우의 `package.json` 파일을 기준으로 설명한다. 당연히 CRA 를 사용하지 않았더라도 적용 가능하다.

기본적으로 `sciprts` 의 `start` 항목은 아래처럼 설정되어 있을 것이다.

```js
// package.json
{
  // ...
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;node scripts/start.js&quot;,
  }
  // ...
}
```

위 스크립트를 아래처럼 수정하면 된다.

```js
{
  // ...
  &quot;scripts&quot;: {
    // 오답
    &quot;start&quot;: &quot;nvm use &amp;&amp; cross-env PORT=4000 node scripts/start.js&quot;,
    // 정답
    &quot;start&quot;: &quot;source ~/.nvm/nvm.sh &amp;&amp; nvm use &amp;&amp; cross-env PORT=4000 node scripts/start.js&quot;,
  }
  // ...
}
```

오답과 정답의 차이는 `source ~/.nvm/nvm.sh` 로 시작하는지 여부다. 해당 구문이 없으면 정상적으로 동작하지 않는다.

이유는 `start` 명령어 자체가 별개의 셸 인스턴스라서 nvm 사용 전에 nvm 초기화가 필요하기 때문이다. ([출처](https://stackoverflow.com/a/34321623))

## 4. 마무리

nvm 사용자라면 프로젝트 별로 nodejs 버전을 설정해서 불필요한 버그를 줄여보자.

nvm 사용자가 아니라면 nvm 을 사용해보자. 좋다.

## 5. 참고

- [How to Change Node.js Version Between Projects Using NVM](https://betterprogramming.pub/how-to-change-node-js-version-between-projects-using-nvm-3ad2416bda7e)
- [Is there a way to run &quot;nvm use&quot; automatically in a prestart npm script?](https://stackoverflow.com/a/34321623)
</content:encoded></item><item><title><![CDATA[React Native 에 SVG Icon 컴포넌트 작성]]></title><description><![CDATA[아이콘 같은 간단한 이미지를 다룰 때는 PNG 형식보다는 SVG 가 더 좋다. 하지만 React Native 에서는 기본적으로 SVG 파일을 지원하지 않는다. 그럼 React Native 에서 SVG 파일을 아이콘으로 사용할 수 있도록 설정 및…]]></description><link>https://ricale.kr/blogposts/220409-react-native-svg-icon-component</link><guid isPermaLink="false">https://ricale.kr/blogposts/220409-react-native-svg-icon-component</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Fri, 08 Apr 2022 15:00:00 GMT</pubDate><content:encoded>
아이콘 같은 간단한 이미지를 다룰 때는 PNG 형식보다는 SVG 가 더 좋다. 하지만 React Native 에서는 기본적으로 SVG 파일을 지원하지 않는다.

그럼 React Native 에서 SVG 파일을 아이콘으로 사용할 수 있도록 설정 및 구현해보자.

# 1. 환경 구성 및 설정

## 1.1. react-native-svg

[react-native-svg](https://github.com/react-native-svg/react-native-svg) 는 React Native 프로젝트에서 SVG 및 관련 엘리먼트들을 웹과 유사한 형식으로 사용할 수 있게 해주는 라이브러리다. 이 라이브러리를 먼저 설치하자.

```bash
$ yarn add react-native-svg
$ cd ./ios &amp;&amp; pod install
```

설치만 하면 된다. 특별한 설정은 필요 없다.

## 1.2. react-native-svg-transformer

react-native-svg 는 `&lt;Svg /&gt;`, `&lt;G /&gt;`, `&lt;Path /&gt;` 등 거의 모든 SVG 관련 컴포넌트를 제공하지만, SVG 파일 자체를 `import` 할 수 있게 해주지는 않는다. SVG 파일들을 `import` 해서 사용하려면 [react-native-svg-transformer](https://github.com/kristerkari/react-native-svg-transformer) 라이브러리도 필요하다. 이 라이브러리는 react-native-svg 라이브러리를 사용해 SVG 파일을 읽어들여 React 컴포넌트로 사용할 수 있게 해준다.

```bash
$ yarn add --dev react-native-svg-transformer
```

설치 이후 추가적인 설정이 필요하다. (react-native-svg-transformer 의 [README](https://github.com/kristerkari/react-native-svg-transformer/blob/master/README.md)에도 잘 나와있다.)

### 1.2.1. `metro.config.js`

프로젝트의 루트 디렉토리에 `metro.config.js` 파일이 있다. 기본 설정되어있는 내용과 [라이브러리 README.md 의 `metro.config.js`](https://github.com/kristerkari/react-native-svg-transformer#for-react-native-v059-or-newer) 내용을 병합하자. 아래는 병합한 결과물 예시이다.

```js
// metro.config.js

const { getDefaultConfig } = require(&quot;metro-config&quot;);

module.exports = (async () =&gt; {
  const {
    resolver: { sourceExts, assetExts },
  } = await getDefaultConfig();
  return {
    transformer: {
      getTransformOptions: async () =&gt; ({
        transform: {
          experimentalImportSupport: false,
          inlineRequires: true,
        },
      }),
      babelTransformerPath: require.resolve(&quot;react-native-svg-transformer&quot;),
    },
    resolver: {
      assetExts: assetExts.filter((ext) =&gt; ext !== &quot;svg&quot;),
      sourceExts: [...sourceExts, &quot;svg&quot;],
    },
  };
})();
```

### 1.2.2. `declaration.d.ts`

타입스크립트를 사용한다면 프로젝트 루트 디렉토리에 `declaration.d.ts` 파일을 새로 만들어서 아래 내용을 넣어주어야 한다.

```ts
// declaration.d.ts

declare module &quot;*.svg&quot; {
  import React from &quot;react&quot;;
  import { SvgProps } from &quot;react-native-svg&quot;;
  const content: React.FC&lt;SvgProps&gt;;
  export default content;
}
```

### 1.2.3. `.svgrrc`

이 파일은 꼭 작성할 필요는 없다. 하지만 작성하면 읽어들인 SVG 컴포넌트의 어트리뷰트를 동적으로 지정할 수 있게 된다. 프로젝트 루트 디렉토리에 `.svgrrc` 파일을 만들어 아래 내용을 넣자.

```json
// .svgrrc
{
  &quot;replaceAttrValues&quot;: {
    &quot;#000&quot;: &quot;{props.fill}&quot;
  }
}
```

이렇게 설정하면 읽어들인 svg 파일 내에서 `&quot;#000&quot;`로 값이 설정된 어트리뷰트는 `fill` prop 의 값으로 치환된다.

```xml
&lt;!-- Logo.svg --&gt;
&lt;svg width=&quot;14&quot; height=&quot;14&quot; viewBox=&quot;0 0 14 14&quot; fill=&quot;none&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
  &lt;path d=&quot;M2.965 6.0925C4.045 8.215 ...&quot; fill=&quot;#000&quot;/&gt;
&lt;/svg&gt;
```

위처럼 작성된 `Logo.svg` 파일을 `import` 해서 아래처럼 쓸 수 있다.

```tsx
import Logo from &quot;./Logo.svg&quot;;

// ...
const SomeComp = () =&gt; (
  // 이렇게 하면 Logo.svg 파일 내의 &quot;#000&quot; 어트리뷰트를 &quot;#FFF&quot; 로 치환되어 적용된다.
  &lt;Logo width={120} height={40} fill={&quot;#FFF&quot;} /&gt;
);
```

이 기능은 react-native-svg-transformer 가 내부적으로 [SVGR](https://github.com/gregberge/svgr)이라는 라이브러리를 사용해서 구현했다. 따라서 SVGR 에서 지원하는 다른 설정들도 사용할 수 있다. 좀 더 정보를 얻고 싶다면 [해당 라이브러리의 문서](https://react-svgr.com/docs/configuration-files/)를 확인하자.

#### # `.svgrrc` 설정을 수정해도 적용되지 않는다?

`.svgrrc` 설정을 수정하고 다시 빌드해도 수정한 사항이 적용되지 않을 때가 있다. 그럴 때는 metro 를 끄고 `yarn start --reset-cache` 로 다시 실행시켜주자.

# 2. 공통 아이콘 컴포넌트 작성

이제 SVG 파일을 웹에서처럼 읽어들여 사용할 수 있다. 하지만 SVG 파일을 일일이 따로따로 `import` 해줘야 하므로 사용하기 번거롭고, 아이콘들의 공통 props 혹은 속성을 관리하기도 힘들다.

그러한 불편함을 해결하기 위해 별도의 컴포넌트를 하나 구현할 것이다. 해당 컴포넌트는 아이콘 이름만으로 아이콘을 사용할 수 있게 해줄 것이며 공통적으로 쓰일 props 들도 관리할 것이다.

### 2.1. SVG 파일들 re-export

일단 컴포넌트를 작성하기 전에, 모든 SVG 파일은 직접 `import` 해서 쓰는 게 아니라 인덱스 파일을 따로 만들어 한 곳에서 관리하도록 하자.

```ts
// src/res/index.ts
export { default as Calendar } from &quot;./calendar.svg&quot;;
export { default as Clock } from &quot;./clock.svg&quot;;
export { default as Sandwatch } from &quot;./sandwatch.svg&quot;;
export { default as Watch } from &quot;./watch.svg&quot;;
```

이제 다른 파일에서는 아래와 같은 형식으로 import 가 가능하다.

```tsx
import { Calendar } from &quot;../res&quot;;
&lt;Calendar /&gt;;
// 혹은
import * as icons from &quot;../res&quot;;
const Comp = icons[&quot;Calendar&quot;];
&lt;Comp /&gt;;
```

### 2.2. `&lt;SvgIcon /&gt;` 구현

하나의 파일에 묶이게 된 SVG 파일들을 읽어와 사용하는 컴포넌트 `&lt;SvgIcon /&gt;` 은 아래처럼 구현할 수 있다.

```tsx
// src/components/SvgIcon.tsx
import React from &quot;react&quot;;
import { SvgProps } from &quot;react-native-svg&quot;;

import * as Icons from &quot;../res&quot;;

type IconProps = SvgProps &amp; {
  // res 에서 re-export 되는 SVG 파일들의 이름을 name 으로 받을 수 있다.
  name: keyof typeof Icons;
  size?: number;
};
function Icon({
  name,
  fill = &quot;black&quot;,
  width: _width,
  height: _height,
  size,
  ...props
}: IconProps) {
  const Comp = Icons[name];
  // `width`, `height` 를 따로 지정할 수 있지만
  // 아이콘은 보통 가로 세로 값이 같은 정사각형 형식이기 때문에
  // 여기서는 `size` 를 사용해 너비와 높이를 같이 지정할 수 있게 해주었다.
  const width = _width ?? size;
  const height = _height ?? size;
  const sizeProps = {
    ...(width !== undefined ? { width } : {}),
    ...(height !== undefined ? { height } : {}),
  };

  return (
    &lt;Comp
      {...props}
      // 1.2.3. `.svgrrc` 의 설정 덕분에 `fill` prop 을 이렇게 사용할 수 있다.
      fill={fill}
      {...sizeProps}
    /&gt;
  );
}

export default Icon;
```

# 3. 결과

## 3.1. 사용 예

구현한 컴포넌트 `&lt;SvgIcon /&gt;`을 아래처럼 사용할 수 있다.

```tsx
// ...
import SvgIcon from &quot;./components/SvgIcon&quot;;

const App = () =&gt; {
  return (
    &lt;SafeAreaView style={{ flex: 1, padding: 24 }}&gt;
      {/* ... */}
      &lt;SvgIcon name=&quot;Calendar&quot; /&gt;
      &lt;SvgIcon name=&quot;Clock&quot; fill=&quot;orange&quot; /&gt;
      &lt;SvgIcon size={48} name=&quot;Watch&quot; fill=&quot;gold&quot; /&gt;
      {/* ... */}
    &lt;/SafeAreaView&gt;
  );
};
```

## 3.2. 소스코드 전문

설정 및 구현이 적용된 실제 소스코드를 참고하고 싶다면 [RnSvgIconExample](https://github.com/ricale/RnSvgIconExample) 리파지토리를 참고하자. 이 문서를 작성하면서 다시 한 번 적용 및 구현해본 리파지토리이며, 실행 또한 잘 된다.
</content:encoded></item><item><title><![CDATA[읽은 좋은 글들 (~22.3.12)]]></title><description><![CDATA[메일링, 블로그, 구글링 등을 통해 읽은 좋은 글들을 모아놓은 글이다.]]></description><link>https://ricale.kr/blogposts/220313-read-writings</link><guid isPermaLink="false">https://ricale.kr/blogposts/220313-read-writings</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Sat, 12 Mar 2022 15:00:00 GMT</pubDate><content:encoded>
### [[번역] Proxy와 Reflect](https://ko.javascript.info/proxy)

Proxy 와 Reflect 에 대한 강의? 글. 맨날 몰라서 찾아보고 까먹고 몰라서 찾아보고 까먹고를 반복하는 녀석인데, 이번에는 쓸만한 구석이 있을 수도 있어서 좀 더 정독했다. 한 번 써보면 확실히 안 까먹을텐데. (참고로 번역이 반 정도만 되어있다. 나머지는 영문)

### [Debounce vs throttle](https://www.kaidohussar.dev/posts/debounce-vs-throttle)

debounce 와 throttle 둘을 비교하며 설명한다. 난 또 JavaScript 에 포함되어있는 (내가 알지 못하던) 함수인 줄 알았더니, 그냥 개념 및 구현에 대한 설명이었다. 간단히 요약하면 아래와 같다.

- debounce 는 특정 시간마다 반복되면서 실행
- throttle 은 마지막 실행으로부터 특정 시간동안 실행이 안 됨

간단한 UI 구현 예제도 있으니 읽어보는 것도 좋겠다.

### [LocalStorage vs Cookies: All You Need To Know About Storing JWT Tokens Securely in The Front-End ](https://dev.to/cotter/localstorage-vs-cookies-all-you-need-to-know-about-storing-jwt-tokens-securely-in-the-front-end-15id)

JWT Token 을 관리하기에는 어디가 더 적절한가? Local Storage? Cookie?

글에서는 XSS 와 CSRF 를 피하기 위해

- Refresh token 은 (각종 옵션을 적용해서) 쿠키에 관리
- Access token 은 인메모리에 관리

하라고 권한다.

가장 추천을 많이 받은 댓글에서는 (글의 내용이 좋긴 하지만) 모던 자바스크립트 프레임워크와 NPM 에서 이미 강력한 XSS 방어를 해주고 있으므로 Local Storage 도 나쁘지 않다고 말한다.

이 주제의 글을 볼 때마다 결국 내리는 결론은, 요구사항과 기타 조건에 따라 선택하는 것이지 Local Storage 와 Cookie 중 어느 한 쪽이 (보안 측면에서) 압도적으로 좋지는 않다는 것이다.

### [JWT는 어디에 저장해야할까? - localStorage vs cookie](https://velog.io/@0307kwon/JWT%EB%8A%94-%EC%96%B4%EB%94%94%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%B4%EC%95%BC%ED%95%A0%EA%B9%8C-localStorage-vs-cookie)

바로 위의 글과 같은 주제에 윗글을 많이 참고한 듯한 글. 이 글에서는 어느 쪽이 더 우월하지는 않지만 글쓴이 본인은 Local Storage 를 더 선호한다는 결론을 내렸다.

### [\[번역\] 스벨트 vs 리액트, 누가 더 뛰어날까?](https://yozm.wishket.com/magazine/detail/1176/)

여기저기서 Svelte 에 대해 몇 번 주워 들은 적이 있는데, 이렇게 (비교글일지언정) 정리된 글을 읽는 것은 처음이다.

요약하자면 성능, 사용성 등 거의 모든 부분에서 Svelte 가 React 보다 뛰어나지만, 지원하거나 관리하는 기업이 없는 오픈소스 프로젝트이면서 아직 사용자가 (React 에 비해) 많지 않다보니 문서와 커뮤니티 형성에 있어서는 크게 밀린다는 점이었다. (추가로 대규모 프로젝트에는 아직 적합하지 않다는 것도 있다)

관심이 가긴 하지만, 사람이 좀 많아지면 써봐야겠다.

### [A closer look at the security of React Native biometric libraries](https://blog.nviso.eu/2021/04/06/a-closer-look-at-the-security-of-react-native-biometric-libraries/)

React Native 의 생체인증 관련 라이브러리들이 보안적으로 안전한지 살펴보는 글이다. Event-based 방식 말고 Result-based 방식이 안전하다고 이야기하며 총 다섯 개의 React Native 생체인증 라이브러리를 리뷰한다.

생체인증 구현을 적용해보기 전에 읽어보기 좋은 글이다.
</content:encoded></item><item><title><![CDATA[React Native WebView 에서 쿠키가 유지되지 않는 문제]]></title><description><![CDATA[우리 회사의 앱은 React Native WebView 를 사용해 하이브리드 앱으로 구현되어 있다. 최근 웹앱 쪽에서 로그인 인증 토큰을 쿠키로 유지하는 업데이트를 적용했는데, RN 쪽에서 별안간 쿠키가 유지되지 않는 버그가 발견되었다. 1. 버그…]]></description><link>https://ricale.kr/blogposts/220227-react-native-webview-cookie</link><guid isPermaLink="false">https://ricale.kr/blogposts/220227-react-native-webview-cookie</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Sat, 26 Feb 2022 15:00:00 GMT</pubDate><content:encoded>
우리 회사의 앱은 [React Native WebView](https://github.com/react-native-webview/react-native-webview) 를 사용해 하이브리드 앱으로 구현되어 있다. 최근 웹앱 쪽에서 로그인 인증 토큰을 쿠키로 유지하는 업데이트를 적용했는데, RN 쪽에서 별안간 쿠키가 유지되지 않는 버그가 발견되었다.

## 1. 버그 개요

일단 브라우저 상에서 웹앱을 사용할 때는 쿠키에 관한 이슈가 전혀 없다.

앱에서도 사용하는 동안에는 문제가 없다. 문제는 앱 프로세스를 완전히 종료한 뒤 다시 실행했을 때다. 이 때 쿠키에 저장되어 있던 값들이 롤백된다. 누군가는 로그인이 유지된다는 걸로 봐서는 항상 롤백되는 건 아닌 것 같은데, 규칙성을 찾기가 어려웠다.

이 버그 때문에 쿠키 값이 유지되지 않으면서 로그인이 풀린다는 제보가 잇따르기 시작했다.

React Native WebView 리파지토리의 [이슈들](https://github.com/react-native-webview/react-native-webview/issues?q=is%3Aissue+cookie)을 살펴봐도, 우리처럼 쿠키 때문에 고생하고 있는 사람들은 제법 있었지만 해결책은 보이지 않았다.

## 2. 해결 과정

### 2.1. React Native WebView prop 확인

일단 혹시나 [React Native WebView 에서 제공하는 prop](https://github.com/react-native-webview/react-native-webview/blob/master/docs/Reference.md) 으로 해결할 수 있을까 싶어 쿠키와 관련된 prop 들 (`incognite`, `sharedCookiesEnabled`, `thirdPartyCookiesEnabled`) 을 적용해보았지만 해결되지 않았다.

고민 끝에 우리는 React Native WebView 의 버그라고 판단하고 우회책을 찾기로 했다.

### 2.2. 쿠키를 RN 에 별도로 저장해두자.

우회방법으로 웹앱 쪽에서 쿠키 값이 변경될 때마다 [`postMessage()`](https://github.com/react-native-webview/react-native-webview/blob/master/docs/Reference.md#postmessagestr) 로 쿠키 전문을 보내주는 방법을 선택했다.

```js
postMessage(JSON.stringify({ type: &quot;cookie&quot;, content: document.cookie }));
```

쿠키를 받으면 RN 쪽에서는 AsyncStorage 등에 저장해두었다가 앱의 프로세스가 재실행될 때 웹뷰의 헤더에 쿠키를 넣어주었다.

```jsx
const [source, setSource] = useState({ uri: SOME_URI });
// 저장해놓은 쿠키가 있으면 source 에 저장한다.
useEffect(() =&gt; {
  AsyncStorage.getItem(&apos;cookie&apos;).then((content) =&gt; {
    setSource(st =&gt; ({
      ...st,
      headers: res ? { Cookie: JSON.parse(content) } : null
    }));
  });
}, []);
// ...
return (
  &lt;WebView
    // ...
    incognite // &lt;- incognite 가 없으면 source.headers.Cookie 값이 적용되지 않는다. 이유는 아직 불명
    source={source}
    onMessage={(evt) =&gt; {
      const { type, content } = evt.nativeEvent.data;
      // 웹앱으로부터 postMessage 로 쿠키가 오면 저장해둔다.
      if(type === &apos;cookie&apos;) {
        AsyncStorage.setItem(&apos;cookie&apos;, content);
        return;
      }
      // ...
    }}
    /&gt;
```

### 2.3. 그럼에도 이슈가 남아있다.

신기하게도 이렇게 해도 때때로 웹앱의 `postMessage()` 를 통해 넘어온 쿠키 값에서 인증 리프레시 토큰 값만 누락되어 넘어오는 현상이 있었다 (하필이면 제일 중요한 녀석이..). 이것 또한 원인을 찾지 못하고 결국 임시 방편으로 &quot;액세스 토큰과 리프레시 토큰 중 하나라도 값이 있으면 이전 쿠키로부터 다른 하나의 값을 복구하도록&quot; 로직을 넣었다.

## 3. 근본적인 해결책

회사에 iOS/안드로이드 네이티브 개발자가 없어서 라이브러리를 뜯어가며 근본적인 해결책을 찾는 것은 어려울 것 같다. 일단 임시 방편으로 대응하면서 React Native WebView 가 업데이트 되기를 기다리는 수밖에 없는 것 같다.
</content:encoded></item><item><title><![CDATA[React Native 빌드 에러 (2)]]></title><description><![CDATA[Mac OS 를 쓰면서 마주한 React Native 빌드 에러에 대해 정리한다. M1 프로세서를 사용 중인데 이것이 원인 중 하나인지는 명확하지 않다.

iOS
1. (빌드 에러) node: No such file or directory

nvm 을…]]></description><link>https://ricale.kr/blogposts/220227-react-native-build-error-2</link><guid isPermaLink="false">https://ricale.kr/blogposts/220227-react-native-build-error-2</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Sat, 26 Feb 2022 15:00:00 GMT</pubDate><content:encoded>
Mac OS 를 쓰면서 마주한 React Native 빌드 에러에 대해 정리한다.

M1 프로세서를 사용 중인데 이것이 원인 중 하나인지는 명확하지 않다.

## iOS

### 1. (빌드 에러) node: No such file or directory

nvm 을 사용하고 있는 사람이라면, 아래 명령어 실행으로 해결할 수 있다.

```bash
sudo ln -s &quot;$(which node)&quot; /usr/local/bin/node
```

([출처](https://stackoverflow.com/a/66874780))

### 2. (빌드 에러) Something went wrong. Please verify if generated JS bundle is correct.

번들 명령어를 통해 `main.jsbundle` 파일을 직접 만들고, Xcode 에서 프로젝트를 연 뒤 해당 파일을 드래그앤드랍으로 넣어주면 된다.

```bash
yarn react-native bundle --platform ios --dev false --entry-file index.js --bundle-output ios/main.jsbundle
```

만약 이미 main.jsbundle 파일이 Xcode 상에 추가되어 있다면 기존 파일(레퍼런스)은 삭제 하고 새로 생성한 파일을 추가해보자.

([출처](https://github.com/Microsoft/react-native-code-push/issues/1066#issuecomment-340233140))

### 3. (`pod install` 에러) CocoaPods could not find compatible versions for pod &quot;Firebase/Analytics&quot;

비단 Firebase/Analytics 만의 문제가 아니라, 라이브러리를 추가/버전업 할 때 마주할 수 있는 에러로 보인다.

일단은 `ios/Podfile.lock` 파일을 삭제한 뒤 아래 명령어로 해결했다.

```sh
pod install --repo-update
```

## 안드로이드

### 1. (빌드 에러) An exception has occurred in the compiler (1.8.0_292)

에러 전문은 아래와 같다.

&gt; An exception has occurred in the compiler (1.8.0_292). Please file a bug against the Java compiler via the Java bug reporting page (http://bugreport.java.com) after checking the Bug Database (http://bugs.java.com) for duplicates. Include your program and the following diagnostic in your report. Thank you.
&gt; java.lang.AssertionError: annotationType(): unrecognized Attribute name MODULE (class com.sun.tools.javac.util.UnsharedNameTable$NameImpl)

react-native-fierbase/messaging 을 설치한 뒤 발생했다. 해당 라이브러리에 직접적인 문제가 있다기보다는, 안드로이드 SDK 버전이 올라가면서 필요한 openjdk 버전도 올라간 것 같다.

openjdk 버전을 11로 올려주면 해결된다. 아래는 MacOS 에서 openjdk11 을 설치하는 명령어다.

```bash
$ brew tap adoptopenjdk/openjdk
$ brew install --cask adoptopenjdk11
```

([출처1](https://github.com/invertase/react-native-firebase/issues/5909), [출처2](https://apple.stackexchange.com/questions/349454/how-can-i-upgrade-my-mac-to-openjdk-11-using-homebrew))

### 2. (Metro 에러) jest-haste-map: Watchman crawl failed. Retrying once with node crawler.

안드로이드 개발 빌드에서 느닷없이 hot reloading 이 동작하지 않는 현상이 발생했다. Metro 쪽을 보니 아래와 같은 에러 메시지가 찍혀 있었다.

&gt; jest-haste-map: Watchman crawl failed. Retrying once with node crawler.
&gt; Usually this happens when watchman isn&apos;t running. Create an empty `.watchmanconfig` file in your project&apos;s root folder or initialize a git or hg repository in your project.
&gt; Error: Watchman error: watchman::QueryExecError: query failed: synchronization failed: syncToNow: timed out waiting for cookie file to be observed by watcher within 60000 milliseconds: Operation timed out. Make sure watchman is running for this project. See https://facebook.github.io/watchman/docs/troubleshooting.

구글링을 하다가 [나와 같은 증상의 이슈](https://github.com/facebook/draft-js/issues/2183)를 찾았다. 그래서 코멘트에 있는 답변들을 시도해봤는데, 안 되고 안 되고 안 되다가 결국에는 해결되었다. 내가 진행한 과정은 아래와 같다.

1. `brew reinstall watchman`
2. `watch-del-all &amp;&amp; yarn cache clean &amp;&amp; react-native start --reset-cache`
3. `.watchmanconfig` 삭제 후 새로 파일을 만든 뒤 기존과 동일한 내용을 넣음
4. 재부팅

마지막에 재부팅을 하고 나서야 해결되었다. 이게 저 위의 네 과정을 다 거쳐야 하는 것인지, 저 중 하나만 하면 되는 건지, 몇 개만 조합하면 되는 건지, 그건 불명이다.
</content:encoded></item><item><title><![CDATA[MUI 커스텀 테마에 타입스크립트 적용]]></title><description><![CDATA[타입스크립트 환경에서 MUI 의 테마에 필드를 추가하려면 타입스크립트 또한 추가적인 타입 선언이 필요하다. 어떻게 하면 되는지 유형별로 간단히 살펴보자. References
MUI Docs
Theming - Custom variablesPalet…]]></description><link>https://ricale.kr/blogposts/220226-mui-custom-theme-typescript</link><guid isPermaLink="false">https://ricale.kr/blogposts/220226-mui-custom-theme-typescript</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Fri, 25 Feb 2022 15:00:00 GMT</pubDate><content:encoded>
타입스크립트 환경에서 [MUI](https://mui.com/) 의 테마에 필드를 추가하려면 타입스크립트 또한 추가적인 타입 선언이 필요하다. 어떻게 하면 되는지 유형별로 간단히 살펴보자.

### References

- [MUI Docs](https://mui.com/getting-started/installation/)
  - [Theming - Custom variables](https://mui.com/customization/theming/#custom-variables)
  - [Palette - Adding new colors](https://mui.com/customization/palette/#adding-new-colors)
- StackOverflow [Add property to background prop in createMuiTheme in Material-UI using Typescript](https://stackoverflow.com/questions/66080451/add-property-to-background-prop-in-createmuitheme-in-material-ui-using-typescrip)
- GitHub [mui/material-ui](https://github.com/mui/material-ui) - [createPalette.d.ts](https://github.com/mui/material-ui/blob/master/packages/mui-material/src/styles/createPalette.d.ts)

## 1. 테마에 커스텀 필드 추가

테마에 기존에 존재하지 않는 새로운 필드를 추가할 수 있다.

```ts
const theme = createTheme({
  status: {
    danger: orange[500],
  },
});
```

이것을 위한 타입스크립트 타입 선언은 경우에는 아래처럼 해주면 된다.

```ts
declare module &quot;@mui/material/styles&quot; {
  interface Theme {
    status: {
      danger: string;
    };
  }
  interface ThemeOptions {
    status?: {
      danger?: string;
    };
  }
}
```

## 2. 테마 Palette 에 커스텀 필드 추가

테마의 palatte 에 색상을 추가하면 `color`, `sx` prop 등에서 이름만으로 색상을 지정할 수 있게 된다. 아래 코드처럼 `palette.neutral`을 추가한다면,

```ts
const theme = createTheme({
  palette: {
    neutral: {
      main: &quot;#64748B&quot;,
      contrastText: &quot;#fff&quot;,
    },
  },
});
```

타입스크립트는 아래처럼 해주면 된다.

```ts
declare module &quot;@mui/material/styles&quot; {
  interface Palette {
    neutral: Palette[&quot;primary&quot;];
  }
  interface PaletteOptions {
    neutral: PaletteOptions[&quot;primary&quot;];
  }
}
```

이걸로 끝이면 좋겠지만, 특정 컴포넌트의 `color` 속성에서도 위에서 추가한 색상을 쓰고 싶다면, 해당 컴포넌트에 관한 타입 추가 선언을 해주어야 한다.

```ts
// Button 의 color prop 에서 neutral 을 쓰고 싶을 경우
declare module &quot;@mui/material/Button&quot; {
  interface ButtonPropsColorOverrides {
    neutral: true;
  }
}
```

## 3. 테마 Palette 의 특정 색상에 필드 추가

Palette 의 특정 색상에 필드를 추가하고 싶을 수 있다. 아래는 `palette.primary.darker`, `palette.background.contrastText` 를 추가했다.

```ts
const normalTheme = createTheme({
  palette: {
    primary: {
      main: &quot;#0971f1&quot;,
      darker: &quot;#053e85&quot;,
    },
    background: {
      default: &quot;#E4E7EB&quot;,
      contrastText: &quot;#000000&quot;,
    },
  },
});
```

속성을 추가하려는 색상이 `primary`, `secondary`, `error`, `warning`, `info`, `success` 중 하나라면, 이 색상들은 타입을 공유하기 때문에 아래처럼 타입을 지정하면 된다.

```ts
declare module &quot;@mui/material/styles&quot; {
  interface PaletteColor {
    darker?: string;
  }
  interface SimplePaletteColorOptions {
    darker?: string;
  }
}
```

하지만 `background` 의 경우 다른 타입을 사용하므로 아래처럼 해주어야 한다.

```ts
declare module &quot;@mui/material/styles/createPalette&quot; {
  interface TypeBackground {
    default: string;
    paper: string;
    contrastText: string;
  }
}
```

어떤 색상이 어떤 타입을 사용하는지 알고 싶다면 [createPalette.d.ts](https://github.com/mui/material-ui/blob/master/packages/mui-material/src/styles/createPalette.d.ts) 코드를 보면 된다. 아래처럼 나와있으니 참고해서 타입 지정을 해주면 된다.

```ts
export interface PaletteOptions {
  primary?: PaletteColorOptions;
  secondary?: PaletteColorOptions;
  error?: PaletteColorOptions;
  warning?: PaletteColorOptions;
  info?: PaletteColorOptions;
  success?: PaletteColorOptions;
  mode?: PaletteMode;
  tonalOffset?: PaletteTonalOffset;
  contrastThreshold?: number;
  common?: Partial&lt;CommonColors&gt;;
  grey?: ColorPartial;
  text?: Partial&lt;TypeText&gt;;
  divider?: string;
  action?: Partial&lt;TypeAction&gt;;
  background?: Partial&lt;TypeBackground&gt;;
  getContrastText?: (background: string) =&gt; string;
}
```
</content:encoded></item><item><title><![CDATA[React Native 애플 로그인에서 탈퇴 기능 구현]]></title><description><![CDATA[1. 서두 토이 프로젝트에서 아래 라이브러리를 사용해 소셜 로그인을 구현하고 있다.

@react-native-firebase/app: React Native Firebase 코어 모듈@react-native-firebase/auth: React…]]></description><link>https://ricale.kr/blogposts/220102-react-native-apple-login-revoke</link><guid isPermaLink="false">https://ricale.kr/blogposts/220102-react-native-apple-login-revoke</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Sat, 01 Jan 2022 15:00:00 GMT</pubDate><content:encoded>
## 1. 서두

토이 프로젝트에서 아래 라이브러리를 사용해 소셜 로그인을 구현하고 있다.

- [@react-native-firebase/app](https://www.npmjs.com/package/@react-native-firebase/app): React Native Firebase 코어 모듈
- [@react-native-firebase/auth](https://www.npmjs.com/package/@react-native-firebase/auth): React Native Firebase Authentication 모듈
- [@react-native-google-signin/google-signin](https://github.com/react-native-google-signin/google-signin): React Native 구글 소셜 로그인 라이브러리
- [@invertase/react-native-apple-authentication](https://github.com/invertase/react-native-apple-authentication): React Native 애플 소셜 로그인 라이브러리

이 글에서는 애플 소셜 로그인에서도 탈퇴(앱과 연결 끊기) 기능 구현을 정리한다. 탈퇴는 사용자에게 당연히 제공되어야 하는 사용자의 권리다. 뭐 필수 기능이니 구현하는 데 어려울 건 없을 것이다. 아마 라이브러리에 `탈퇴하기()` 같은 메서드가 있을 것이고 우리는 그걸 호출하기만 하면 될 것이다. 아주 쉽다. 자 시작해보자. ...어? 아니네?

### 1.1. 엥? 로그인은? 로그아웃은? 구글은?

애플 소셜 로그인/로그아웃, 구글 소셜 로그인/로그아웃/탈퇴 기능 구현에는 특별한 이슈가 없다. 개발자가 상상하고 있는 거의 그대로 메서드가 나와있고 우리는 호출하기만 되는 형태다. 일부 콜백을 사용해야 하긴 하지만 큰 문제는 아니다. 따라서 일단은 이슈가 있다고 생각되는 애플 쪽의 탈퇴 기능을 먼저 정리한다. (나머지 기능들은 나중에 정리할 수도 있다.) 일단은 공식문서들을 참고하시라.

- [React Native Firebase - Authentication](https://rnfirebase.io/auth/usage)
- [Github - react-native-google-signin/google-signin](https://github.com/react-native-google-signin/google-signin)
- [GitHub - invertase/react-native-apple-authentication](https://github.com/invertase/react-native-apple-authentication)

## 2. 구현

### 2.1. `onCredentialRevoked()`

일단 [@invertase/react-native-apple-authentication](https://github.com/invertase/react-native-apple-authentication) 라이브러리의 README 를 찬찬히 살펴봐도 탈퇴를 위한 메서드는 존재하지 않는다. (구글 쪽 라이브러리에서는 `revokeAccess()`라는 메서드를 제공하는 것과 대조적이다.) 그나마 탈퇴 쪽과 관련된 메서드라면 `onCredentialRevoked(listener)` 가 있다. 이 메서드는 사용자가 탈퇴되었을 때 실행되는 콜백을 등록하게 해준다.

여기서 평소 iOS 를 사용하지 않는 사람들은 당황할 수 있다 (내가 그랬다). 탈퇴 기능은 제공하지 않지만 탈퇴 상태를 들을 수 있는 이벤트 리스너만 제공하고 있는 것이다. 그럼 대체 탈퇴는 어떻게 하는 거야?

다행히 답은 멀리 있지 않다. 애플은 iOS 기기 내에서 특정 앱과의 연결을 끊을 수 있는 (탈퇴할 수 있는) 기능을 제공한다. (apple.com 에서도 제공하는 것으로 알고 있다. 확인해보지는 않았다.)

&gt; iOS 기기의 [설정] 앱 - 최상단의 자신의 이름 영역 선택 - [암호 및 보안] - [Apple ID를 사용하는 앱] - 탈퇴할 앱 선택 - [Apple ID 사용 중단]

이 말은 즉슨, 탈퇴 기능을 직접 구현할 필요는 없다는 것이다. 우리는 사용자가 애플을 통해 탈퇴를 했을 때 그에 대응하는 처리만 해주면 된다.

#### 구현 예

그럼 문서에 나와있는대로 탈퇴 기능을 구현해보자.

```js
function App() {
  // ...

  useEffect(() =&gt; {
    // 현재 기기가 애플 로그인을 지원하는 기기인지 확인
    if(!appleAuth.isSupported) {
      return;
    }

    const unsubscriber = appleAuth.onCredentialRevoked(() =&gt; {
      // 사용자의 정보를 가지고 탈퇴 기능을 수행하자.
      doSomethingForRevoke();
      // firebase 에서도 로그아웃
      auth().signOut();
    });
    return unsubscriber;
  }, []);

  // ...

  return (
    &lt;View&gt;
    &lt;/View&gt;
  )
}

});
```

### 2.2. `getCredentialStateForUser()`

좋다. 구현이 완료되었다. 라이브러리의 README 에는 예외 처리에 대한 안내가 없는 걸로 봐서 이 콜백은 사용자의 탈퇴 시 무조건 실행을 보장하는 것 같다 (API 문서를 보고 싶지만 링크가 깨져있다).

그렇게 믿고 싶다. 하지만 세상에 백퍼센트는 없다. 특히 앱 프로세스가 완전히 죽은 상태에서 탈퇴를 하고 앱을 실행했을 때 `onCredentialRevoked()` 가 실행되지 않는 것을 여러차례 직접 목격한 나로서는, 더더욱 무시할 수 없었다. 이 콜백이 실행되지 않을 때를 대비해야 한다.

이럴 때 쓸 수 있는 메서드가 `getCredentialStateForUser(user)`다. 이 메서드는 현재 사용자의 상태를 반환한다.

```typescript
enum AppleCredentialState {
  REVOKED = 0, // The Opaque user ID was revoked by the user.
  AUTHORIZED = 1, // The Opaque user ID is in good state.
  NOT_FOUND = 2, // The Opaque user ID was not found.
  TRANSFERRED = 3, // N/A
}
```

즉 사용자가 앱에 진앱했을 때, 혹은 사용자 정보가 업데이트되었다고 추정될 때, 이 메서드로 사용자의 상태를 확인하면 탈퇴 여부를 확인할 수 있다는 말이다.

#### 구현 예

여기서는 &quot;사용자의 인증 정보가 바뀐 시점&quot;을 React Native Firebase 의 `auth().onAuthStateChanged()` 콜백으로 확인한다. 만약 React Native Firebase 를 사용하지 않는다면 다른 방법으로 해당 시점을 찾아야 할 것이다.

```js
function App() {
  // ...

  useEffect(() =&gt; {
    const subscribe = auth().onAuthStateChanged(async user =&gt; {
      if(!user) {
        // 로그아웃된 상태 처리
        loggedOut();
        return;
      }

      const isApple = (
        appleAuth.isSupported
        &amp;&amp; user.providerData[0].providerId === &apos;apple.com&apos;
      );
      const uidInProvider = user.providerData[0].uid;
      const appleState = await appleAuth.getCredentialStateForUser(uidInProvider);

      if(isApple &amp;&amp; appleState === appleAuth.State.REVOKED) {
        // 사용자의 정보를 가지고 탈퇴 기능을 수행하자.
        revokeThisService();
        // firebase 에서도 로그아웃
        auth().signOut();
      }
    })
  }, []);

  // ...

  return (
    &lt;View&gt;
    &lt;/View&gt;
  )
}

});
```

## 3. 결론

마지막으로 요약하자. React Native 에서 [@invertase/react-native-apple-authentication](https://github.com/invertase/react-native-apple-authentication) 라이브러리를 사용해 탈퇴 기능을 구현할 때는 아래 두 개의 메서드를 적절히 잘 조합하면 되겠다.

- `onCredentialRevoked()`
- `getCredentialStateForUser()`
</content:encoded></item><item><title><![CDATA[읽은 좋은 글들 (~21.12.2)]]></title><description><![CDATA[메일링, 블로그, 구글링 등을 통해 읽은 좋은 글들을 모아놓은 글이다.]]></description><link>https://ricale.kr/blogposts/211202-read-writings</link><guid isPermaLink="false">https://ricale.kr/blogposts/211202-read-writings</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Wed, 01 Dec 2021 15:00:00 GMT</pubDate><content:encoded>
### [브라우저의 사용자 에이전트는 왜 이렇게 복잡하게 생겼을까?](https://wormwlrm.github.io/2021/10/11/Why-User-Agent-string-is-so-complex.html)

브라우저 사용자 에이전트의 역사에 대한 간략한 소개. 간추리자면 &quot;사용자 에이전트 정보가 이렇게 엉망이 된 이유는 브라우저 개발사들이 경쟁에서 뒤쳐지지 않기 위해 다른 회사 브라우저의 사용자 에이전트 정보까지 자신들의 브라우저에 포함시켰기 때문이다.&quot; 라는 이야기다.

### [React Derived State 다시 보기](https://reactiver.dev/review-react-derived-state/)

Derived State 가 뭔지, 문제가 뭔지, 개선책이 뭔지를 설명한다. Derived State 는 props 에 의해 초기화되는 상태값으로, `initial` 을 말머리로 갖는 props 를 작성한 적이 있거나 본 적이 있다면 이미 잘 알고 있을 것이다.

### [Before You memo()](https://overreacted.io/before-you-memo/)

`memo()` 를 사용하기 전에 적용해볼 수 있는, React 앱의 성능을 개선하는 기초적이면서도 놓치기 쉬운 방법을 소개한다. 투박하게 축약하자면, &quot;자주 변경되는 상태값을 너무 상위 컴포넌트에 두지 말자&quot;가 되겠다.

### [Writing Resilient Components](https://overreacted.io/writing-resilient-components/)

탄력적인 컴포넌트를 작성하는 원칙에 관한 글. 여기서 말하는 &quot;탄력적인 컴포넌트&quot;는 유연하고 독립적인 컴포넌트를 말하는 듯 하다. 말하는 원칙은 아래 네 개인데

1. 데이터 흐름을 막지 마라: props, state 의 변경에 따라 동작하는 React 컴포넌트의 기본 라이프사이클을 흐리지 말라는 말이다. 불필요한 Derived State 사용을 줄이는 것도 여기에 포함된다.
2. 언제나 렌더링 되게 하라: 굳이 렌더링 타이밍을 조정하려 하지 말라는 말. 자연스럽게 현재 상태에 따라 동작하게 하라는 의미다.
3. 컴포넌트는 싱글톤이 아니다: 자신도 모르게 싱글톤으로 작성하고 있을 수도 있다고? 그럼 같은 한 화면에서 컴포넌트를 두 번 렌더링해보자.
4. 컴포넌트의 로컬 상태는 독립적으로: 이건 뭐 부언할 말도 없다.

공감이 되기도 하고 새삼 되새기게 되기도 하는 좋은 글이다. 한글 번역본도 글 말머리에 링크가 있어 영어가 약해도 읽을 수 있다.

---

앞으로는 글을 많이 읽고 링크만 공유하는 것에 초점을 두지 않고 (어차피 제대로 지켜진 적도 없다), 글을 적게 읽더라도 어느정도 요약을 작성하면서 자주자주 적는 걸 목표로 하려고 한다.
</content:encoded></item><item><title><![CDATA[프로덕션 빌드에서만 Firebase Authentication (구글 로그인) 이 되지 않는 문제]]></title><description><![CDATA[발단 및 전개 React Native 를 활용해 토이 프로젝트를 진행하고 있다. Firebase 의 Authentication 기능을 활용해 구글 로그인을 붙였다. 이전에도 써 본 기능이었기 때문에 별다른 어려움은 없었다. 로컬의 개발 환경에서 잘…]]></description><link>https://ricale.kr/blogposts/211118-firbase-authentication-issue-in-production</link><guid isPermaLink="false">https://ricale.kr/blogposts/211118-firbase-authentication-issue-in-production</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Wed, 17 Nov 2021 15:00:00 GMT</pubDate><content:encoded>
### 발단 및 전개

React Native 를 활용해 토이 프로젝트를 진행하고 있다. Firebase 의 Authentication 기능을 활용해 구글 로그인을 붙였다. 이전에도 써 본 기능이었기 때문에 별다른 어려움은 없었다. 로컬의 개발 환경에서 잘 동작하는 것을 확인하고, 프로덕션 환경으로도 테스트해보았다.

```bash
$ ENVFILE=.env.production react-native run-android --variant=release
```

아무런 문제가 없었다. 그래서 프로덕션 환경으로 빌드를 해서 aab 파일을 구글 플레이 콘솔에 올렸다. 그런데, 로그인이 되지 않는다면서 심사가 반려되었다.

다시 로컬에서 프로덕션 환경으로 실행해봤다. 여전히 잘 되었다. 뭐지? 이번에는 구글 플레이 콘솔에 들어가 내가 올린 파일을 다운로드했다. 어라? 로그인이 되지 않았다.

&gt; Error: DEVELOPER_ERROR

이 에러는 익히 잘 알고 있다. Firebase 콘솔에 내 안드로이드 앱의 SHA-1 키를 등록하지 않았을 때 발생하는 인증 에러다. 하지만 이상하다. 나는 분명히 키를 등록했다.

![](./001.png)

(분명 키는 등록되어있다.)

뭘 잘못한 것일까? 잘못된 키를 등록한 것일까? Gradle 의 기능을 활용해 다시 키값을 확인해봤다.

```
$ ./gradlew signReport
```

동일한 키값이 나온다. 이번엔 keytool 로 확인해보자.

```
$ keytool -list -v -keystore {keystore_name} -alias {alias_name}
```

마찬가지의 키 값이 나온다.

어떻게 된 거지? 구글링을 해봐도 거의 대부분 키를 등록하지 않았던 사람들의 이야기 뿐이었다.

### 해결

그렇게 몇 시간을 헤메다가 결국 [나와 동일한 현상의 글](https://github.com/react-native-google-signin/google-signin/issues/823#issuecomment-606271524)을 찾을 수 있었다.

&gt; Everything worked swimmingly with debug builds (we generated SHA1 hashes of our local dev keystore) and everything worked great with release APKs that we were installing directly to device (we generated a SHA1 hash of our production key to get this to work). However, when generating an AAB and uploading to the Beta channel and trying this version, we would get the nefarious DEVELOPER_ERROR.
&gt;
&gt; The fix? I went into the PlayStore console and found a tab named &quot;App Signing&quot; under &quot;Release management&quot; There, I found yet another SHA1 which I then put into our Google Console account. After that, everything worked.

간단히 말하자면, .aab 파일로 빌드해서 구글 플레이 콘솔에 올리면 구글 측에서 앱을 한 번더 서명하기 때문에, 플레이 콘솔에서 서명 키 값을 가져와야 한다는 것이었다.

이제야 비밀이 풀렸다. 그래서 로컬에서 프로덕션 환경으로 실행해봤을 때는 잘 되었던 것이다. 구글이 서명을 한 번 더 하기 전이니까.

좋다. 이제 구글 플레이 콘솔에서 키값을 가져오자.

![](./002.png)

Firebase 콘솔로 돌아가 키값을 입력해보자. 좋다. 이제 에러가 없어졌다.

### 결론

.aab 파일로 빌드한다면, 구글 플레이 콘솔에서 SHA-1 키값을 찾아내서 Firebase 콘솔에 입력해주자.
</content:encoded></item><item><title><![CDATA[읽은 좋은 글들 (~21.11.16)]]></title><description><![CDATA[메일링, 블로그, 구글링 등을 통해 읽은 좋은 글들을 모아놓은 글이다.]]></description><link>https://ricale.kr/blogposts/211116-read-writings</link><guid isPermaLink="false">https://ricale.kr/blogposts/211116-read-writings</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Mon, 15 Nov 2021 15:00:00 GMT</pubDate><content:encoded>
### [React useRef Hook for Dummies: How to Use useRef Correctly with Examples](https://blog.notesnook.com/react-useref-hook-with-examples/)

React 컴포넌트에서 어떤 값을 관리함에 있어 `useState` 보다는 `useRef` 가 효율적일 때가 있다. 그것을 설명하는 글이다.

### [[번역] 심층 분석: React Hook은 실제로 어떻게 동작할까?](https://hewonjeong.github.io/deep-dive-how-do-react-hooks-really-work-ko/)

React Hook 의 구현 및 작동 원리를 설명한 글을 번역한 글. 번역이 훌륭하지만, 영어를 읽는데 문제가 없다면 [원문](&lt;(https://www.netlify.com/blog/2019/03/11/deep-dive-how-do-react-hooks-really-work/)&gt;)을 읽는 것도 나쁘지 않다.

### [A Visual Guide to React Rendering - Cheat Sheet](https://alexsidorenko.com/blog/react-render-cheat-sheet/)

React 의 컴포넌트가 리렌더링되는 이유, 그것을 막을 수 있는 방법을 단계적으로 설명한 글이다. 실제로는 이 글에 그 내용이 다 있는 것이 아니고 작성자가 작성해두었던 여러 글들을 엮은 글이다.

작성자가 쓴 글 이외에도 좋은 몇몇 글들이 추가로 링크되어있다. 제목에 나온 그대로, 훌륭한 &quot;Cheat Sheet&quot; 이라고 할 수 있다.

### [Rust Is The Future of JavaScript Infrastructure](https://leerob.io/blog/rust)

Rust 라는 언어가 가까운 미래에 자바스크립트의 각종 툴링(번들링,압축,포멧팅 등)을 대체할 것이라는 내용의 글. Rust 의 장점과 현황, 미래에 대한 글쓴이의 생각이 잘 정리되어 있다.

### [The Invisible JavaScript Backdoor](https://certitude.consulting/blog/en/invisible-backdoor/)

너비가 0인 공백 특수문자, 생긴 건 느낌표와 동일하지만 다른의미의 특수문자 등을 활용해 백도어를 구현하는 재밌는 글.
</content:encoded></item><item><title><![CDATA[읽은 좋은 글들 (~21.10.13)]]></title><description><![CDATA[메일링, 블로그, 구글링 등을 통해 읽은 좋은 글들을 모아놓은 글이다.]]></description><link>https://ricale.kr/blogposts/211013-read-writings</link><guid isPermaLink="false">https://ricale.kr/blogposts/211013-read-writings</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Tue, 12 Oct 2021 15:00:00 GMT</pubDate><content:encoded>
### [React is Declarative - What Does it Mean?](https://alexsidorenko.com/blog/react-is-declarative-what-does-it-mean/)

React 가 Declarative(선언형)이라는 게 어떤 의미인지 Imperative(명령형)과 비교해서 설명해준다. 선언형을 경험해보지 못한 사람에게 개념을 설명해주기 좋은 글.

### [How to use React useReducer hook like a pro](https://devtrium.com/posts/how-to-use-react-usereducer-hook)

`useReducer` 메서드에 대한 사용 팁을 다룬 글인데.. &apos;like a pro&apos;까진 아닌 것 같은데..

### [Using Recoil instead of Redux For State Management In React Applications.](https://blog.openreplay.com/using-recoil-instead-of-redux-for-state-management-in-react-applications)

Recoil 에 대한 설명글. Redux 에 빗댄 개념 설명과 예제 코드를 함께 볼 수 있다.

### [Stop trying to be so DRY, instead Write Everything Twice (WET)](https://dev.to/wuz/stop-trying-to-be-so-dry-instead-write-everything-twice-wet-5g33)

&gt; You can ask yourself &quot;Haven&apos;t I written this before?&quot; two times, but never three.

같은 코드를 세 번 중복 작성하게 되면 그 때 일반화를 고민하라는 글이다. 성급하게 일반화하지 말라는 글이다.

### [AHA Programming](https://kentcdodds.com/blog/aha-programming)

&gt; prefer duplication over the wrong abstraction

DRY와 WET 을 넘어, 확신이 들기 전에는 추상화(일반화)하지 말라는 글이다.

### [변경에 유연한 컴포넌트](https://jbee.io/web/components-should-be-flexible/)

컴포넌트의 일반화, 추상화에 대해 다룬다. 데이터와 분리된 독립적인 컴포넌트 설계에 대해 잘 설명되어있다.
</content:encoded></item><item><title><![CDATA[한 기기에서 여러 GitHub 계정 SSH 인증 설정]]></title><description><![CDATA[얼마 전 GitHub 의 비밀번호 인증 방식이 중지되었다. 이제는 pull, push 등 GitHub 에 인증이 필요한 액션을 할 때 비밀번호가 아닌 다른 인증 방식을 설정해야 한다. Instead, token-based authentication…]]></description><link>https://ricale.kr/blogposts/210901-github-ssh-multi-account</link><guid isPermaLink="false">https://ricale.kr/blogposts/210901-github-ssh-multi-account</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Tue, 31 Aug 2021 15:00:00 GMT</pubDate><content:encoded>
얼마 전 [GitHub 의 비밀번호 인증 방식이 중지](https://github.blog/changelog/2021-08-12-git-password-authentication-is-shutting-down/)되었다. 이제는 pull, push 등 GitHub 에 인증이 필요한 액션을 할 때 비밀번호가 아닌 다른 인증 방식을 설정해야 한다.

&gt; Instead, token-based authentication (for example, personal access, OAuth, SSH Key, or GitHub App installation token) will be required for all authenticated Git operations.

그나마 익숙한 것이 무엇인가 살펴보았더니 SSH인 것 같았다. 그래서 SSH로 인증을 설정하기로 했다.

(이 글은 Mac 기준으로 작성되었다.)

## 1. 하나의 계정에 대한 SSH 인증 설정

한 계정에 대한 설정 방법은 [GitHub 공식 문서](https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent)에 매우 잘 설명되어 있다. 영어가 불편하지 않다면 공식 문서를 보자.

일단 `ssh-keygen`을 사용해 인증서를 생성하자.

```bash
$ ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;
Generating public/private ed25519 key pair.
Enter file in which to save the key (/Users/default/.ssh/id_ed25519):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
```

경로를 지정하고 싶다면 `-f` 옵션을 주자

```bash
$ ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot; -f ~/.ssh/myCompany/ed25519
```

생성된 인증서를 key agent 에 등록시켜야 한다. ssh-agent 를 백그라운드에서 실행하자.

```bash
$ eval &quot;$(ssh-agent -s)&quot;
```

설정에는 `~/.ssh/config` 파일이 필요한데, 맥의 경우 자동 생성되지 않았을 수 있다. 그 경우 파일을 직접 생성해서 아래와 같은 내용을 넣어야 한다.

```
Host *
  AddKeysToAgent yes
  UseKeychain yes
  IdentityFile ~/.ssh/id_ed25519
```

`~/.ssh/config` 파일도 확인했으면 이제 아래 명령어를 통해 인증서를 ssh-agent 에 추가하자.

```bash
$ ssh-add -K ~/.ssh/id_ed25519
```

GitHub에 인증서를 등록하려면 아래 명령어를 통해 공개키를 클립보드로 복사해서 사용하면 된다.

```bash
$ pbcopy &lt; ~/.ssh/id_ed25519.pub
```

복사한 공개키는 GitHub [Settings] - [SSH and GPG keys] - [New SSH key] 를 통해 등록하자.

여기까지 하면 이제 리파지토리의 SSH 주소를 remote 로 사용해 코드를 push/pull 할 수 있다.

```bash
$ git remote set-url origin git@github.com:ME/MY_REPOSITORY.git
```

## 2. 여러 계정의 SSH 설정을 한 기기에서 같이 하기

한 사람이 GitHub 계정을 여러 개 가지고 있을 수도 있다. 예를 들면 개인 계정과 회사 계정을 분리한 경우가 있을 수 있다. 그리고 사람 일이 늘 그렇듯, 한 기기에서 개인 일과 회사 일을 다 해야 하는 경우가 생길 수도 있다. 그럴 경우에는 어떻게 설정해주면 될까?

거의 모든 과정이 1번과 동일하다. 다른 것은 키가 저장될 위치, `~/.ssh/config`, 그리고 로컬 리파지토리의 remote 주소이다.

### 2.1. 키가 저장될 위치

키가 저장될 위치가 다른 것은 당연하다. 다른 두 파일을 하나의 위치에 같이 저장할 수는 없으니까. 일단 처음에 저장된 것은 기본 위치에 두고, 추후 추가되는 것을 다른 위치에 저장해보자.

```bash
# 처음에 저장된 SSH 키의 위치. (기본값)
~/.ssh/id_ed25519
~/.ssh/id_ed25519.pub
# 이후 추가한 SSH 키의 위치.
# 당연하지만 다른 디렉토리의 다른 파일명으로 저장해도 무방하다.
~/.ssh/myCompany/id_ed25519
~/.ssh/myCompany/id_ed25519.pub
```

자신이 원하는 아무 곳에나 저장하면 된다.

### 2.2. `~/.ssh/config`

저장된 위치를 설정 파일에 반영하자.

```
Host github-private
  hostName github.com
  IdentityFile ~/.ssh/id_ed25519
  User git
  IdentitiesOnly yes

Host github-my-company
  hostName github.com
  IdentityFile ~/.ssh/myCompany/id_ed25519
  User git
  IdentitiesOnly yes
```

- `Host`: 본래 호스트명 대신 사용할 호스트명. alias 라고 이해하면 쉽다. 원하는 이름으로 하면 된다. (사용 예는 2.3. 에서 확인할 수 있다.)
  - `hostName`: git 서비스의 호스트명
  - `IdentityFile`: 인증 파일 경로
  - `IdentitiesOnly`: 인증 파일 경로를 확인함에 있어 내가 지정한 값(`IdentityFile`)만을 사용할 건지 여부. 만약 값을 `no`로 하면, 키 파일을 가져오기 위해 `IdentityFile`의 위치를 확인하기에 **앞서** 시스템의 기본값(이 경우 `~/.ssh/id_ed25519`일 것이다.)을 먼저 확인한다고 한다.

### 2.3. 로컬 리파지토리의 remote 주소 변경

자 이제 2.2. 항목에서 설정한 값을 가지고 리파지토리의 주소를 변경해주어야 한다.

변경하는 방법은 간단하다. 기존 호스트명(`github.com`) 대신 우리가 위 설정파일에서 지정한 호스트명(`Host github-my-company`)를 적용해주면 된다.

```bash
## 원래 주소
# git@github.com:ME/MY-REPOSITORY.git
## 변경할 주소
# git@github-private:ME/MY-REPOSITORY.git
$ git remote set-url origin git@github-private:ME/MY-REPOSITORY.git
```

다른 쪽 리파지토리도 마찬가지다.

```bash
## 원래 주소
# git@github.com:COMPANY/COMPANY-REPOSITORY.git
## 변경할 주소
# git@github-my-company:COMPANY/COMPANY-REPOSITORY.git
$ git remote set-url origin git@github-my-company:COMPANY/COMPANY-REPOSITORY.git
```

이제 양쪽 다 SSH 인증을 사용할 수 있다.

## References

- The GitHub Blog - [Git password authentication is shutting down](https://github.blog/changelog/2021-08-12-git-password-authentication-is-shutting-down/)
- GitHub Docs - [Generating a new SSH key and adding it to the ssh-agent](https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent)
- GitHub Docs - [Adding a new SSH key to your GitHub account](https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account)
- Stack Overflow - [Specify an SSH key for git push for a given domain](https://stackoverflow.com/questions/7927750/specify-an-ssh-key-for-git-push-for-a-given-domain)
</content:encoded></item><item><title><![CDATA[React Native 환경별 빌드 설정]]></title><description><![CDATA[한 프로젝트는 여러 환경에서 빌드 혹은 실행될 수 있다. 가장 단순하게는 개발 환경과 운영(production) 환경 두 환경으로 분리할 수 있고, local, dev, stage, test 등을 보다 세분화해서 분리할 수도 있다. 이 글에서는 여러…]]></description><link>https://ricale.kr/blogposts/210831-react-native-build-setting-for-envs</link><guid isPermaLink="false">https://ricale.kr/blogposts/210831-react-native-build-setting-for-envs</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Mon, 30 Aug 2021 15:00:00 GMT</pubDate><content:encoded>
한 프로젝트는 여러 환경에서 빌드 혹은 실행될 수 있다. 가장 단순하게는 개발 환경과 운영(production) 환경 두 환경으로 분리할 수 있고, local, dev, stage, test 등을 보다 세분화해서 분리할 수도 있다.

이 글에서는 여러 환경에 따라 React Native 프로젝트를 빌드 및 실행해야 할 때, 어떻게 설정을 나누어 관리할 수 있는지 설명한다.

## 1. react-native-config 설치

일단 [react-native-config](https://github.com/luggit/react-native-config)를 설치한다. 이 라이브러리는 `.env.ENV_NAME`파일들을 이용해 각 환경별로 필요한 값을 관리할 수 있다.

### 1.1. react-native-dotenv vs react-native-config

react-native-config 라이브러리와 비슷한 라이브러리로는 [react-native-dotenv](https://github.com/goatandsheep/react-native-dotenv)가 있다. 두 라이브러리는 단일 환경 사용자 측면에서는 거의 동일하지만, 현재 react-native-dotenv 가 다중 환경 지원이 제대로 되지 않는 이슈가 있어서 여기서 사용하기에는 적합하지 않다. (GitHub issue - [APP_ENV doesn&apos;t work as expected](https://github.com/goatandsheep/react-native-dotenv/issues/131) 참고)

따라서 이 글에서는 react-native-config 를 사용한다.

### 1.2. `.env` 파일 작성

프로젝트 root 디렉토리에, 만들려는 환경만큼 파일을 생성한다. (이 파일들은 `.gitignore` 에 추가되는 게 좋다. [참고](https://github.com/luggit/react-native-config/issues/422))

```json
.env             // 기본, local 환경을 위한 env 파일로 사용
.env.dev         // dev 환경을 위한 env 파일
.env.stage       // stage 환경을 위한 env 파일
.env.production  // production 환경을 위한 env 파일
```

각 파일에서 원하는 값은 `key=value` 형식으로 작성하면 된다.

```json
BUILD_ENV=LOCAL
BASE_URL=http://localhost:3000
```

## 2. 안드로이드 설정

### 2.1. `android/app/build.gradle`

안드로이드 설정에서 가장 중요한 것은 이 `android/app/build.gradle` 파일이다. 하나씩 설정을 추가해보자.

#### 2.1.1. react-native-config 를 위한 설정

react-native-config 는 [단일 환경이 아닌 여러 빌드 환경을 설정할 때는, autolinking 말고도 추가로 해줘야 할 설정이 있다.](https://github.com/luggit/react-native-config#extra-step-for-android) 문서를 자세히 읽지 않으면 놓치기 쉬우므로 정리하고 넘어간다.

파일 최상단에 (`apply plugin: &quot;com.android.application&quot;` 바로 아랫줄에) 아래 코드를 추가한다.

```js
apply from: project(&apos;:react-native-config&apos;).projectDir.getPath() + &quot;/dotenv.gradle&quot;
```

`android.defaultConfig` 항목에는 아래 코드를 추가한다.

```js
android {
    // ...
    defaultConfig {
        // ...
        // APP_PACKAGE_NAME 대신 자신의 앱 패키지명을 넣으면 된다
        resValue &quot;string&quot;, &quot;build_config_package&quot;, &quot;APP_PACKAGE_NAME&quot;
    }
    // ...
}
```

#### 2.1.2. 환경 분리를 위한 설정

`android.buildTypes` 항목에 환경별 설정을 추가한다.

```js
android {
    // ...
    buildTypes {
        debug {
            signingConfig signingConfigs.debug
            applicationIdSuffix &quot;.dev&quot;
        }
        release {
            // Caution! In production, you need to generate your own keystore file.
            // see https://facebook.github.io/react-native/docs/signed-apk-android.
            signingConfig signingConfigs.debug
            minifyEnabled enableProguardInReleaseBuilds
            proguardFiles getDefaultProguardFile(&quot;proguard-android.txt&quot;), &quot;proguard-rules.pro&quot;
        }
        //
        // 아래부터가 추가되는 코드
        //
        devDebug {
            initWith debug
            applicationIdSuffix &quot;.dev&quot;
            matchingFallbacks = [&apos;debug&apos;]
        }
        devRelease {
            initWith release
            applicationIdSuffix &quot;.dev&quot;
            matchingFallbacks = [&apos;release&apos;]
        }
        stageDebug {
            initWith debug
            applicationIdSuffix &quot;.test&quot;
            matchingFallbacks = [&apos;debug&apos;]
        }
        stageRelease {
            initWith release
            applicationIdSuffix &quot;.test&quot;
            matchingFallbacks = [&apos;release&apos;]
        }
    }
}
```

`devDebug`, `devRelease` 등이 추가된 환경들이다. 앞에 붙은 `dev`, `stage` 가 빌드 환경 이름이고 뒤에 붙은 `Debug`, `Release` 가 빌드 유형 정보다. (네이밍 방식이 정해진 것은 아니다. 꼭 이 형식을 따를 필요는 없다.)

- `initWith`: 해당 타입을 기반으로 새 타입을 생성하겠다는 의미다.
- `applicationIdSuffix`: 앱이 빌드되면 패키지명 뒤에 이 값을 붙여준다. 즉 같은 앱을 환경별로 나눠서 설치할 수 있게 해준다.
- `matchingFallbacks`: 앱 빌드 시 환경이름을 buildTypes 이름이 아니라 이 값으로 대체한다. (`devDebug`로 빌드해도 React Native 코드 상에서 환경 이름에 접근할 때는 `debug`가 된다.) 기본 node 환경에도 대응되게 하려면 이 값을 설정해주는 게 좋다.

#### 2.1.3. 스토어키 등록

안드로이드 스튜디오에서는 실행 및 빌드 시 원하는 `.env.ENVNAME` 파일 적용을 할 수 없다. (사실 가능할 수도 있다. 찾아보진 않았다.) 커맨드라인에서는 가능한데, 실행은 아무 추가적 설정 없이 가능한 반면 (릴리즈)빌드는 스토어 키 설정을 해주어야 한다.

`android.signingConfigs` 에 릴리즈용 키 정보를 등록하면 된다.

```js
signingConfigs {
    debug {
        storeFile file(&apos;debug.keystore&apos;)
        storePassword &apos;android&apos;
        keyAlias &apos;androiddebugkey&apos;
        keyPassword &apos;android&apos;
    }
    // 이름을 release 로 하긴 했지만 다른 이름도 가능하다.
    // 단, 그 경우 `android.buildTypes.release`의 `signingConfig` 값도 같이 바꿔주어야 한다.
    release {
        if(project.hasProperty(&apos;MYAPP_UPLOAD_STORE_FILE&apos;)) {
            storeFile file(MYAPP_UPLOAD_STORE_FILE)
            storePassword MYAPP_UPLOAD_STORE_PASSWORD
            keyAlias MYAPP_UPLOAD_KEY_ALIAS
            keyPassword MYAPP_UPLOAD_KEY_PASSWORD
        }
    }
}
```

보다 자세한 내용은 React Native 공식 문서 ([Publishing to Google Play Store](https://reactnative.dev/docs/signed-apk-android)) 를 참고.

### 2.2. 환경별 파일 분리

`./android/app/src/main` 디렉토리에 아래와 같은 파일들이 존재할 것이다.

- `AndroidManifest.xml`
- `MainActivity.java`
- `MainApplication.java`
- 각종 리소스(이미지, `res/values/*.xml` 등)

해당 파일들을 환경별로 따로 관리하고 싶다면, 환경별로 디렉토리를 별도로 만들어 관리하면 된다.

예를 들어 devDebug 환경의 `AndroidManifest.xml` 파일을 따로 관리하고 싶다면 `android/app/src/devDebug` 디렉토리를 만든 뒤, 해당 디렉토리에 `AndroidManifest.xml` 파일을 새로 작성하면 된다. (일반적으로는 기존의 파일을 복사해와서 수정하고 싶은 부분만 수정하게 될 것이다)

### 2.3. Firebase 설정 파일 분리

일반적으로 Firebase 설정 파일인 `google-services.json`은 `android/app` 디렉토리에 위치하게 된다. 하지만 환경별로 분리해주고 싶을 경우, 2.2. 와 동일한 방법으로 환경별로 각각 파일을 만들어주어야 한다.

- `android/app/google-services.json`: 환경별 Firebase 설정 파일이 없을 경우 일괄적으로 적용되는 설정 파일
- `android/app/src/ENV_NAME/google-services.json`: ENV_NAME 환경에만 적용되는 Firebase 설정 파일

### 2.4. 실행/빌드 명령어 작성

환경별 실행/빌드 명령어를 `package.json` 파일에 작성해두자.

```javascript
{
  // ...
  &quot;scripts&quot;: {
    // ...
    &quot;android&quot;: &quot;ENVFILE=.env react-native run-android --appIdSuffix=dev&quot;,
    // 아래 주석 처리된 내용은 2.4.1. 항목 참고.
    // &quot;android-dev&quot;: &quot;ENVFILE=.env.dev react-native run-android --variant=devDebug --appIdSuffix=dev&quot;,
    // &quot;android-stage&quot;: &quot;ENVFILE=.env.stage react-native run-android --variant=stageDebug --appIdSuffix=test&quot;,
    &quot;android-dev&quot;: &quot;ENVFILE=.env.dev react-native run-android&quot;,
    &quot;android-stage&quot;: &quot;ENVFILE=.env.stage react-native run-android&quot;,
    &quot;build-android-dev&quot;: &quot;cd ./android &amp;&amp; ENVFILE=.env.dev ./gradlew assembleDevRelease &amp;&amp; cd ../&quot;,
    &quot;build-android-stage&quot;: &quot;cd ./android &amp;&amp; ENVFILE=.env.stage ./gradlew assembleStageRelease &amp;&amp; cd ../&quot;,
    &quot;build-android-production&quot;: &quot;cd ./android &amp;&amp; ENVFILE=.env.production ./gradlew assembleRelease &amp;&amp; cd ../&quot;,
  }
}
```

이렇게 하면 커맨드라인에서 아래 같은 명령어들로 안드로이드앱을 실행 및 빌드하는 것이 가능해진다.

```bash
yarn android                  # 로컬/개발 환경 실행
yarn android-dev              # dev/개발 환경 실행
yarn android-stage            # stage/개발 환경 실행
yarn build-android-dev        # dev 빌드
yarn build-android-stage      # stage 빌드
yarn build-android-production # production 빌드
```

#### 2.4.1. `react-native run-android --variant=VAR_NAME` 이슈

현재 `react-native run-android --variant=VAR_NAME` 명령어를 사용하면 metro 번들러가 정상적으로 동작하지 않아 에러가 발생한다. 의도적인 것인지 버그인지는 불명, 해결 방법도 불명이다.

`react-native bundle` 명령어를 선행하면 에러는 제거할 수 있지만 hot-reload 가 동작하지 않는다. (이 말은 js/ts 파일이 수정될 때마다 다시 빌드해줘야 함을 의미한다.)

따라서 `react-native run-android` 명령어 사용 시에는 `variant` 옵션을 사용하지 않기를 권한다. `ENVFILE` 옵션만 써줘도 테스트는 충분히 할 수 있다.

## 3. iOS 설정

### 3.1. Configuration 추가

PROJECT - [Info] - [Configuration] 에서 [+] 버튼 클릭한다.

![](./3-1-01.png)

[Duplicate &quot;Debug&quot; Configuration] (&quot;Release&quot; 도 크게 상관 없음) 눌러서 필요한 만큼 설정을 추가하자.

![](./3-1-02.png)

### 3.2. Scheme 추가

최상단 메뉴에서 [Product] - [Scheme] - [Edit Scheme] 을 선택한다. 이후 [Duplicate Scheme] 버튼으로 Scheme 추가한다.

![](./3-2-01.png)

환경 이름 설정 후 [Run], [Test], [Profile], [Analyze], [Archive] 탭의 Build Configuration 항목을 모두 변경하자.

![](./3-2-02.png)

여기서 Build Configuration 은 _&quot;3.1. Configuration 추가&quot;_ 에서 추가했던 항목들을 선택할 수 있다. 되도록 Scheme과 Build Configuration은 1:1로 매칭해주는 것이 좋다. (반드시 그래야 하는 것은 아니고, 편의성을 위해서다)

##### &gt; Scheme - Build Configuration 설정 예

| Scheme                | Build Configuration |
| --------------------- | ------------------- |
| my-project            | (기본값 유지)       |
| my-project-dev        | Dev                 |
| my-project-stage      | Stage               |
| my-project-production | Production          |

#### 3.2.1. Scheme 의 Pre-actions, Post-actions 적용

iOS 는 환경별 `.env` 파일 적용이 자동으로 이루어지지 않기 때문에, 별도의 선행 스크립트를 삽입해주어야 한다.

[Edit Scheme] 의 [Build] 탭에서 [Pre-actions] 선택해 스크립트를 작성하자.

![](./3-2-03.png)

```bash
echo &quot;.env.ENVNAME&quot; &gt; /tmp/envfile
```

[Post-actions] 에는 아래 스크립트를 삽입하자.

```bash
rm /tmp/envfile
```

### 3.3. Firebase 설정 파일 관련 설정 추가

빌드될 때마다 각 환경에 맞는 firebase 설정 파일을 사용하게 하는 설정도 추가할 것이다.

일단 `./ios/firebaseInfo` 디렉토리 생성(디렉토리 이름은 이후 설정에서 일관되게 유지하기만 하면 바꿔도 상관 없다)해 환경별로 `GoogleService-Info.plist`를 작성하자. 아래처럼 파일이 추가될 것이다.

- `./ios/firebaseInfo/GoogleService-Info-dev.plist`
- `./ios/firebaseInfo/GoogleService-Info-stage.plist`
- `./ios/firebaseInfo/GoogleService-Info.plist`

TARGET - [Build Phases] 에서 [+] 버튼을 눌러서 스크립트 추가하자.

![](./3-3-01.png)

스크린샷에서는 스크립트 이름을 &quot;Firebase GoogleService-Info.plist&quot; 라고 작성했으나, 다른 이름을 써도 무방하다.

순서는 대략 &quot;Link Binary With Libraries&quot; 와 &quot;Copy Bundle Resources&quot; 사이로 했는데, 다른 위치에 있어도 정상 동작할 수도 있다.

스크립트는 아래 형식으로 작성한다.

```bash
PATH_TO_GOOGLE_PLISTS=&quot;${PROJECT_DIR}/firebaseInfo&quot;
PATH_TO_PROJECT=&quot;${PROJECT_DIR}&quot;

echo &quot;CONFIGURATION: $CONFIGURATION&quot;

case &quot;${CONFIGURATION}&quot; in

&quot;Debug&quot; )
                cp -r &quot;$PATH_TO_GOOGLE_PLISTS/GoogleService-Info-dev.plist&quot; &quot;${PATH_TO_PROJECT}/GoogleService-Info.plist&quot; ;;

           &quot;Stage&quot; )
                cp -r &quot;$PATH_TO_GOOGLE_PLISTS/GoogleService-Info-stage.plist&quot; &quot;${PATH_TO_PROJECT}/GoogleService-Info.plist&quot; ;;

           &quot;Dev&quot; )
                cp -r &quot;$PATH_TO_GOOGLE_PLISTS/GoogleService-Info-dev.plist&quot; &quot;${PATH_TO_PROJECT}/GoogleService-Info.plist&quot; ;;

           &quot;Release&quot; )
                cp -r &quot;$PATH_TO_GOOGLE_PLISTS/GoogleService-Info.plist&quot; &quot;${PATH_TO_PROJECT}/GoogleService-Info.plist&quot; ;;

            *)
                ;;
        esac
```

### 3.4. Package 이름 분리

TARGET - [Build Settings] - [Packaging] - [Product Bundle Identifier] 항목을 수정하자.

![](./3-4-01.png)

### 3.5. 앱 이름 분리

먼저 TARGET - [Build Settings] 에서 앱 이름으로 사용될 User-defined 값을 추가하자.

![](./3-5-01.png)

그 추가한 값을 Info.plist - [Bundle display name] 에 적용하면 된다.

![](./3-5-02.png)

### 3.6. 실행 및 빌드

이제 Xcode 에서 알맞는 Scheme 을 고른 뒤 [Run] 혹은 [Archive]를 하면 앱을 실행 혹은 빌드할 수 있다.

(커맨드라인에서 하는 방법은 찾고 있다.)

## 4. 이슈

- 현재 iOS 빌드 시 `GoogleService-Info.plist`가 제대로 생성되지 않아 에러가 발생하는 현상이 있다. 이 경우 다시 빌드를 하면 문제 없이 된다. 원인 및 해결 방법은 찾는 중이다.
- `.env`파일들을 어떻게 공유하는 게 좋을지 방법을 고민 중이다. 수정할 때마다 팀원들에게 넘겨주기에는 번거롭고 실수를 유발하기도 쉽다.
</content:encoded></item><item><title><![CDATA[React Native iOS 빌드 에러]]></title><description><![CDATA[최근 React Native 의 빌드 환경을 옮기면서 마주한 에러들을 간단히 정리한다. Intel 프로세서에서 Apple M1 프로세서로 옮기면서 생긴 에러들이 아닌가 하고 추정하고 있지만, 정확하지는 않다. 1. pod install이 되지 않는다…]]></description><link>https://ricale.kr/blogposts/210823-react-native-ios-build-error</link><guid isPermaLink="false">https://ricale.kr/blogposts/210823-react-native-ios-build-error</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Sun, 22 Aug 2021 15:00:00 GMT</pubDate><content:encoded>
최근 React Native 의 빌드 환경을 옮기면서 마주한 에러들을 간단히 정리한다. Intel 프로세서에서 Apple M1 프로세서로 옮기면서 생긴 에러들이 아닌가 하고 추정하고 있지만, 정확하지는 않다.

### 1. `pod install`이 되지 않는다

아래와 같은 에러가 발생하며 `pod install`이 진행되지 않았다.

&gt; LoadError - dlopen(/Library/Ruby/Gems/2.6.0/gems/ffi-1.15.1/lib/ffi_c.bundle, 0x0009): missing compatible arch in /Library/Ruby/Gems/2.6.0/gems/ffi-1.15.1/lib/ffi_c.bundle - /Library/Ruby/Gems/2.6.0/gems/ffi-1.15.1/lib/ffi_c.bundle

아래의 명령어를 실행하면 해결할 수 있다.

    $ sudo arch -x86_64 gem install ffi
    $ arch -x86_64 pod install

이후부터는 그냥 `pod install`을 써도 문제 없다.

([출처](https://github.com/CocoaPods/CocoaPods/issues/10220#issuecomment-730963835))

### 2. Xcode 빌드 에러: Library not found for -lBase64

이 문제는 Xcode에서 프로젝트를 열 때 `*.xcodeproj` 파일 대신 `*.xcworkspace` 파일을 여니 해결되었다. 이것은 M1과는 무관한 이슈 같다.

### 3. Xcode 빌드 에러: ios/main.jsbundle: No such file or directory

본래라면 자동 생성/갱신되는 것으로 알고 있는 `ios/main.jsbundle` 파일이 생성/갱신되지 않으면서 생긴 에러이다.

아래 명령어를 실행해서 `ios/main.jsbundle` 파일을 직접 생성하면 문제가 해결된다.

```
yarn react-native bundle --entry-file=&apos;index.js&apos; --bundle-output=&apos;./ios/main.jsbundle&apos; --dev=false --platform=&apos;ios&apos; --assets-dest=&apos;./ios&apos;
```

라이브러리를 추가/삭제할 때마다 항상 실행해주어야 한다는 것이다. 나중에 언젠가 React Native 에서 (자동으로 되도록) 패치를 내주지 않을까 싶다.

([출처](https://github.com/facebook/react-native/issues/18472#issuecomment-407759054))

### 4. Xcode 빌드 에러: PhaseSriptExecution failed with a nonzero exit code

빌드 target의 [Build Phases] 탭의 [Bundle React Native code and images] 항목에서 &quot;For install builds only&quot; 선택 항목을 체크하면 해결된다.

만약 Sentry 를 연동하고 있다면, [Upload Debug Symbols to Sentry] 항목에 대해서도 &quot;For install builds only&quot; 선택 항목을 체크하자.
</content:encoded></item><item><title><![CDATA[React Native WebView 안드로이드 백버튼 처리]]></title><description><![CDATA[React Native 를 웹뷰 컨테이너로 사용해 웹앱을 구현하고 있다. 웹뷰를 사용한 하이브리드앱 구현 시 주의해야 할 점 중 하나는 안드로이드 기기의 백버튼(뒤로가기 버튼)에 대한 처리다. 사람들은 이전 웹페이지로 돌아가길 기대하며 백버튼을…]]></description><link>https://ricale.kr/blogposts/210821-react-native-webview-android-back-button</link><guid isPermaLink="false">https://ricale.kr/blogposts/210821-react-native-webview-android-back-button</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Fri, 20 Aug 2021 15:00:00 GMT</pubDate><content:encoded>
React Native 를 웹뷰 컨테이너로 사용해 웹앱을 구현하고 있다.

웹뷰를 사용한 하이브리드앱 구현 시 주의해야 할 점 중 하나는 안드로이드 기기의 백버튼(뒤로가기 버튼)에 대한 처리다. 사람들은 이전 웹페이지로 돌아가길 기대하며 백버튼을 누르지만, React Native 는 웹뷰 내에서의 이전 페이지로 이동하는 것이 아니라 React Native 상의 이전 화면으로 돌아가기 때문이다.

만약 웹뷰 화면이 해당 앱의 첫 화면이라면, 백버튼을 눌렀을 때 이전 웹페이지로 가는 것이 아니라 앱이 종료되는 것을 경험할 수 있다. 당연하게도 그것은 개발자가 의도한 사항도, 사용자가 의도한 사항도 아니다.

그러면 웹뷰가 있는 화면에서 백버튼을 눌렀을 때 React Native 의 이전 화면이 아닌 웹뷰의 이전 웹페이지가로 가도록 코드를 수정해보자.

## 1. `onNavigationStateChange`

React Native WebView 를 사용하고 있다면 [`onNavigationStateChange` 콜백](https://github.com/react-native-webview/react-native-webview/blob/master/docs/Reference.md#onnavigationstatechange)과 [`BackHandler` API](https://reactnative.dev/docs/backhandler)를 사용해 이전 웹페이지로 이동하도록 백버튼의 기능을 조정할 수 있다.

```js
const HomeScreen = (props) =&gt; {
  const ref = useRef();
  const [navState, setNavState] = useState();

  useEffect(() =&gt; {
    const onPress = () =&gt; {
      if (navState.canGoBack) {
        // 뒤로 갈 수 있는 상태라면 이전 웹페이지로 이동한다
        ref.current.goBack();
        // 기본 뒤로가기 동작을 수행하지 않을 거라면 true 를 리턴한다.
        return true;
      } else {
        // 뒤로 갈 수 없는 상태라면
        // 다른 원하는 행동을 하면 된다
        console.log(&quot;do something&quot;);
        // 기본 뒤로가기 동작을 수행하지 않을 거라면 true 가 아닌 값을 리턴한다.
        return false;
      }
    };

    // 안드로이드 백버튼이 눌렸을 때 이벤트 리스너를 등록한다.
    BackHandler.addEventListener(&quot;hardwareBackPress&quot;, onPress);
    return () =&gt; {
      BackHandler.removeEventListener(&quot;hardwareBackPress&quot;, onPress);
    };
  }, [navState.canGoBack]);

  return (
    &lt;WebView
      // ...
      ref={ref}
      // 웹뷰의
      onNavigationStateChange={setNavState}
    /&gt;
  );
};
```

`onNavigationStateChange` 콜백의 첫 번째 인자(`navState`)는 웹뷰의 현재 상태가 담긴 객체인데, 해당 객체의 `canGoBack` 값은 현재 웹뷰에서 뒤로가기가 가능한 상태인지를 알려준다 (예를 들어 첫페이지에서는 뒤로 갈 수 없을 것이다. 그런 경우에는 `false` 값을 가진다).

뒤로 갈 수 있다면 `ref.current.goBack()`메서드를 사용해 이전 페이지로 돌아가고, 그렇지 않다면 필요한 다른 작업을 하면 되겠다.

## 2. HTML5 History API 대응

하지만 `onNavigationStateChange` 콜백에 문제가 있으니, 바로 `pushState()`, `replaceState()` 등 [HTML5 History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API)로 추가된 기능으로 페이지 이동을 하면 동작하지 않는다는 것이다. 이는 `canGoBack` 값이 최신화되지 않는다는 뜻이고, 위에서 작성한 코드가 정상적으로 동작할 수 없다는 뜻이다.

물론 여기서 주저앉을 수는 없다. 이제 우리는 [`onMessage` 콜백](https://github.com/react-native-webview/react-native-webview/blob/master/docs/Reference.md#onmessage)과 [`webview.injectJavaScript()` 메서드](https://github.com/react-native-webview/react-native-webview/blob/master/docs/Reference.md#injectjavascriptstr)를 통해 `pushState()`, `replaceState()` 동작 시 웹뷰의 상태를 받아오도록 할 것이다.

### 2.1. `webview.injectJavaScript()`

`webview.injectJavaScript()` 메서드는 웹뷰에 자바스크립트 코드를 삽입할 수 있도록 해주는 메서드이다. 해당 메서드를 통해 `pushState()`와 `replaceState()` 메서드를 래핑해줄 것이다.

```js
const INJECTED_CODE = `
(function() {
  function wrap(fn) {
    return function wrapper() {
      var res = fn.apply(this, arguments);
      window.ReactNativeWebView.postMessage(&apos;navigationStateChange&apos;);
      return res;
    }
  }

  history.pushState = wrap(history.pushState);
  history.replaceState = wrap(history.replaceState);
  window.addEventListener(&apos;popstate&apos;, function() {
    window.ReactNativeWebView.postMessage(&apos;navigationStateChange&apos;);
  });
})();

true;
`;
const HomeScreen = (props) =&gt; {
  // ...
  return (
    &lt;WebView
      // ...
      ref={ref}
      onLoadStart={() =&gt; ref.current.injectJavaScript(INJECTED_CODE)}
      onNavigationStateChange={setNavState}
    /&gt;
  );
};
```

#### 2.1.1. `injectedJavaScript` props 는 안 되나?

React Native WebView 에는 `webview.injectJavaScript()`메서드와 비슷한 기능을 하는 [`injectedJavaScript` prop](https://github.com/react-native-webview/react-native-webview/blob/master/docs/Reference.md#injectedjavascript)도 존재한다. 하지만 결정적인 차이점이 존재하는데, `webview.injectJavaScript()`는 우리가 원하는 때에만 골라서 코드를 삽입할 수 있지만, `injectedJavaScript`는 `onLoad` 이벤트가 발생할 때마다 코드를 삽입된다는 것이다.

`onLoadStart` 이벤트는 실제 페이지 이동이 일어날 때만 발생하는데 반해 `onLoad` 이벤트는 History API 등으로 로딩이 발생할 때도 발생한다. 때문에 같은 코드가 중복적으로 삽입될 수 있고, 우리는 그러한 현상을 피하기 위해 `onLoadStart`와 `injectJavaScript()` 메서드를 조합해서 코드를 삽입한다.

(단, `injectedJavaScriptBeforeContentLoaded` prop 을 사용하면 위 코드와 거의 동일한 효과를 낼 수 있다.)

#### 2.1.2. 삽입된 코드는 어떤 코드?

위 코드에는 삽입된 코드가 통문자열로 되어있기 때문에 알아보기 힘들다. 하이라이트된 코드로 다시 살펴보자.

```js
(function () {
  function wrap(fn) {
    return function wrapper() {
      var res = fn.apply(this, arguments);
      window.ReactNativeWebView.postMessage(&quot;navigationStateChange&quot;);
      return res;
    };
  }

  history.pushState = wrap(history.pushState);
  history.replaceState = wrap(history.replaceState);
  window.addEventListener(&quot;popstate&quot;, function () {
    window.ReactNativeWebView.postMessage(&quot;navigationStateChange&quot;);
  });
})();

true;
```

`pushState()`와 `replaceState()`를 래핑하고 `popState` 이벤트에 리스너를 붙이는 코드라는 것을 알 수 있다. 모든 코드들은 공통적으로 [`ReactNativeWebView.postMessage()` 메서드](https://github.com/react-native-webview/react-native-webview/blob/master/docs/Reference.md#postmessagestr)를 호출하는 것을 볼 수 있다. 이 메서드가 호출될 때마다 웹뷰는 웹페이지의 상태를 `onMessage` 콜백으로 받아볼 수 있다.

### 2.2. `onMessage`

그럼 `onMessage` 콜백도 넣어보자.

```js
const HomeScreen = (props) =&gt; {
  // ...
  return (
    &lt;WebView
      // ...
      ref={ref}
      onLoadStart={() =&gt; ref.current.injectJavaScript(INJECTED_CODE)}
      onNavigationStateChange={setNavState}
      onMessage={({ nativeEvent }) =&gt; {
        if (nativeEvent.data === &quot;navigationStateChange&quot;) {
          setNavState(nativeEvent);
        }
      }}
    /&gt;
  );
};
```

됐다. 이제 `pushState()`, `replaceState()`도 놓치지 않게 되었다.

## 3. 전체 코드

(아래 코드는 이해를 돕기 위한 의사코드로, 실제로는 동작하지 않을 수도 있다)

```js
const INJECTED_CODE = `
(function() {
  function wrap(fn) {
    return function wrapper() {
      var res = fn.apply(this, arguments);
      window.ReactNativeWebView.postMessage(&apos;navigationStateChange&apos;);
      return res;
    }
  }

  history.pushState = wrap(history.pushState);
  history.replaceState = wrap(history.replaceState);
  window.addEventListener(&apos;popstate&apos;, function() {
    window.ReactNativeWebView.postMessage(&apos;navigationStateChange&apos;);
  });
})();

true;
`;

const HomeScreen = (props) =&gt; {
  const ref = useRef();
  const [navState, setNavState] = useState();

  useEffect(() =&gt; {
    const onPress = () =&gt; {
      if (navState.canGoBack) {
        // 뒤로 갈 수 있는 상태라면 이전 웹페이지로 이동한다
        ref.current.goBack();
      } else {
        // 뒤로 갈 수 없는 상태라면
        // 다른 원하는 행동을 하면 된다
      }
    };

    // 안드로이드 백버튼이 눌렸을 때 이벤트 리스너를 등록한다.
    BackHandler.addEventListener(&quot;hardwareBackPress&quot;, onPress);
    return () =&gt; {
      BackHandler.removeEventListener(&quot;hardwareBackPress&quot;, onPress);
    };
  }, [navState.canGoBack]);

  return (
    &lt;WebView
      // ...
      ref={ref}
      onLoadStart={() =&gt; ref.current.injectJavaScript(INJECTED_CODE)}
      onNavigationStateChange={setNavState}
      onMessage={({ nativeEvent }) =&gt; {
        if (nativeEvent.data === &quot;navigationStateChange&quot;) {
          setNavState(nativeEvent);
        }
      }}
    /&gt;
  );
};
```

## 4. 참고

- [React Native WebView](https://github.com/react-native-webview/react-native-webview)
- [MIGRATED: iOS WebView doesn&apos;t support hash url change. The onNavigationStateChange listener will not be called when url hash changes. (#20447) #24](https://github.com/react-native-webview/react-native-webview/issues/24#issuecomment-483956651)
</content:encoded></item><item><title><![CDATA[읽은 좋은 글들 (~21.7.24)]]></title><description><![CDATA[메일링, 블로그, 구글링 등을 통해 읽은 좋은 글들을 모아놓은 글이다.]]></description><link>https://ricale.kr/blogposts/210724-read-writings</link><guid isPermaLink="false">https://ricale.kr/blogposts/210724-read-writings</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Fri, 23 Jul 2021 15:00:00 GMT</pubDate><content:encoded>
## JavaScript

### [Encoding data for POST requests](https://jakearchibald.com/2021/encoding-data-for-post-requests/)

POST 리퀘스트의 `body`를 어떻게 실어보내는 것이 좋을지에 대한 글. `URLSearchParams`, `FormData`를 포함한 여러 방법을 소개하고 있다.

### [JS Is Weird](https://jsisweird.com/)

자바스크립트가 얼마나 이상한 언어인지 소개하고자 만들어진듯한 페이지. 총 25개의 문제를 주는데, 각각의 자바스크립트 문장을 보고 결과값이 무엇인지 맞추는 페이지이다. 재미도 있고 교훈도 있다. (...25문제 중 15문제를 맞췄다)

## React

### [React Architecture: How to Structure and Organize a React Application](https://www.taniarascia.com/react-architecture-directory-structure/)

React 프로젝트를 구성할 때 디렉토리 구조를 어떻게 할 것인가에 관한 글. React 를 처음 사용할 당시 이런 글이 없어서 참으로 난감했던 기억이 있는데, 그런 의미에서 입문자에게는 영감을 주고 숙련자에게는 본인의 프로젝트를 리뷰하게끔 하게 해주는 글. 물론 맹신할 필요까지는 없다.

### [Past, Present, and Future of React State Management](https://leerob.io/blog/react-state-management#zustand-recoil-jotai-valtio-oh-my)

React 프로젝트에서의 상태 관리에 관한 글. 제목에서도 알 수 있듯이 과거 현재 미래 관점에서 전반적인 상태 관리 생태계를 훑고 있는 글이다. 꼭 상태 관리 라이브러리를 바꿀 목적이 아니라더라도, 재미로 읽기에도 좋은 글.

### [How To useContext With useReducer](https://hswolff.com/blog/how-to-usecontext-with-usereducer/)

상태 관리 라이브러리 없이 `useContext`와 `useReducer`로 상태 관리를 구현하는 방법에 대한 튜토리얼.

### [React useReducer with Middleware](https://www.robinwieruch.de/react-usereducer-middleware)

`useReducer`를 사용하면서, middleware 를 어떻게 적용할지에 대한 글.

### [React Fragments: A Simple Syntax to Improve Performance](https://www.sitepoint.com/react-fragments-introduction/)

React `&lt;Fragment /&gt;`에 관한 글. 서두에서는 `&lt;Fragment /&gt;`의 숨겨진 팁을 알려줄 것처럼 이야기하더니 생각보다 별 내용이 없어서 실망. 원래 `&lt;Fragment /&gt;`를 알고 있는 사람은 굳이 읽을 필요 없지만, 모르던 사람이라면 읽어볼 만 하다.

### [How to debug unnecessary rerenders in React](https://brycedooley.com/debug-react-rerenders/)

React 의 렌더링을 디버깅하기 위한 툴을 소개한다.

### [5 Code Smells React Beginners Should Avoid](https://betterprogramming.pub/5-code-smells-react-beginners-should-avoid-480c97799162)

React 를 사용함에 있어 피해야 할 다섯 가지 패턴에 대해 이야기하는데, 사실 읽어보면 &quot;DOM 을 직접 건드리지 말자&quot;를 제외하면 일반적인 코딩 스타일에도 적용되는 이야기다.

## 기타

### [How to Create a Responsive Square with CSS](https://spin.atomicobject.com/2015/07/14/css-responsive-square/)

CSS 로 반응형 정사각형을 구현하는 방법에 대한 글. 몇 번이나 해봤으면서 다시 할 때가 되면 매번 까먹는다.

### [GitHub 접속 용 SSH 키 만드는 방법](https://www.lainyzine.com/ko/article/creating-ssh-key-for-github/)

GitHub 의 SSH 인증 방식을 사용해보려고 검색하다가 찾은 글. 쉽고 간결하게 설명이 잘 되어있다.
</content:encoded></item><item><title><![CDATA[읽은 좋은 글들 (~21.7.5)]]></title><description><![CDATA[CSS Perfect Tooltips With CSS Clipping and Masking

CSS로 말풍선 모양의 툴팁을 구현하는 내용이다. 단순히 네모와 그 아래 세모를 붙이는 것으로 끝나지 않고, 말풍선 모양으로 사진을 클리핑하는 것까지 구현한다.…]]></description><link>https://ricale.kr/blogposts/210705-read-writings</link><guid isPermaLink="false">https://ricale.kr/blogposts/210705-read-writings</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Sun, 04 Jul 2021 15:00:00 GMT</pubDate><content:encoded>
## CSS

### [Perfect Tooltips With CSS Clipping and Masking](https://css-tricks.com/perfect-tooltips-with-css-clipping-and-masking/)

CSS로 말풍선 모양의 툴팁을 구현하는 내용이다. 단순히 네모와 그 아래 세모를 붙이는 것으로 끝나지 않고, 말풍선 모양으로 사진을 클리핑하는 것까지 구현한다. `svg`(특히 `clip-path`)를 활용한다.

### [Using Performant Next-Gen Images in CSS with image-set](https://css-tricks.com/using-performant-next-gen-images-in-css-with-image-set/)

이제는 거의 모든 모던 브라우저에 탑재된 `image-set` 속성에 대해 설명하는 글이다. 간단히 설명하면 모바일 앱처럼 사용자의 해상도나 네트워크 상태에 따라 적절한 이미지를 보여주는 기능이다. 글에서는 다른 비슷한 기능들과 비교하며 사용 예를 설명해고 있다.

### [Detecting Hover-Capable Devices](https://css-irl.info/detecting-hover-capable-devices/)

`hover`가 가능한 기기와 그렇지 않은 기기를 구분할 수 있는 미디어 쿼리에 대해 설명하는 글이다.

## JavaScript

### [Modern Javascript: Everything you missed over the last 10 years (ECMAScript 2020)](https://turriate.com/articles/modern-javascript-everything-you-missed-over-10-years)

지난 10년간 있었던 자바스크립트의 새로운 기능들에 대해 간략히 정리한다. 제목의 말마따나 빼먹은 게 있는지 체크해볼 수 있다.

### [THE REDUX BEST PRACTICE “DO NOT PUT NON-SERIALIZABLE VALUES IN STATE OR ACTIONS” EXPLAINED](https://blog.bam.tech/developer-news/the-redux-best-practice-do-not-put-non-serializable-values-in-state-or-actions-explained)

Redux 사용 시 `state`나 `action`에 non-serializable 데이터를 사용하면 안 되는 이유에 대해 설명한다. (여기서 seriealizable 데이터란 `JSON.parse()`와 `JSON.stringify()`를 차례로 써서 원본 데이터를 얻을 수 있는 데이터라고 이해하면 쉽다.)

당연히 쓰지 않는 게 좋지만 개발자의 판단에 따라 쓰고 싶다면 써도 된다고 말하기도 하는데, 이 글에서 인용한 [Redux 공식 문서](https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)에 재미있는 말이 나와있다.

&gt; If you are okay with things like persistence and time-travel debugging potentially not working as intended, then you are totally welcome to put non-serializable items into your Redux store. Ultimately, it&apos;s _your application_, and how you implement it is up to you.

*your application*이 강조되어 있는 게 재미있다.

## 개발문화

### [페어 프로그래밍이란 무엇 일까?](https://kihoonkim.github.io/2018/01/01/Agile/pair-programming/)

페어프로그래밍의 장단점, 하는 방법 등이 읽기 좋게 정리되어 있다.

### [코드 리뷰 in 뱅크샐러드 개발 문화](https://blog.banksalad.com/tech/banksalad-code-review-culture/#:~:text=%EC%BD%94%EB%93%9C%20%EB%A6%AC%EB%B7%B0%EB%9E%80%20%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80,%EC%9D%84%20%EB%B0%9C%EA%B2%AC%ED%95%A0%20%EC%88%98%EB%8F%84%20%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4.)

뱅크샐러드의 코드 리뷰 문화가 정리되어 있는 글이다. 잘 읽히는 상세한 글이다.
</content:encoded></item><item><title><![CDATA[읽은 좋은 글들 (~21.6.28)]]></title><description><![CDATA[JavaScript A surprising feature of JavaScript optional chaining

제목 그대로, ?. 문법의 사용법에 관한 글이다. 처음보는 용례까지 있어서 깜짝 놀랐다.

ES2021 Features!

ES2021의…]]></description><link>https://ricale.kr/blogposts/210628-read-writings</link><guid isPermaLink="false">https://ricale.kr/blogposts/210628-read-writings</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Sun, 27 Jun 2021 15:00:00 GMT</pubDate><content:encoded>
## JavaScript

### [A surprising feature of JavaScript optional chaining](https://swizec.com/blog/a-surprising-feature-of-javascript-optional-chaining/)

제목 그대로, `?.` 문법의 사용법에 관한 글이다. 처음보는 용례까지 있어서 깜짝 놀랐다.

### [ES2021 Features!](https://h3manth.com/ES2021/)

ES2021의 새로운 기능들을 소개하는 글이다. 아래 다섯 가지 새로운 기능을 소개하고 있다.

- Logical Assignment Operators
- Numeric Separators
- Promise.any and AggregateError
- String.prototype.replaceAll
- WeakRefs and FinalizationRegistry Objects

## React

### [React — 5 Things That Might Surprise You](https://medium.com/geekculture/react-5-things-that-might-surprise-you-ddefd9fbac0f)

React 에서 사람들이 놓치기 쉬운 특징들 다섯 가지에 대해 설명하는 글이다. 각각 `useState`, `useRef`, `key` 어트리뷰트, `Context` API, `children` 프로퍼티와 관련된 내용이다.

### [When to useMemo and useCallback](https://kentcdodds.com/blog/usememo-and-usecallback)

`useMemo`와 `useCallback`을 언제 써야 할지에 관한 글이다. 안 쓰는 사람들에게 &quot;적극적으로 쓰자&quot;고 말하는 글이 아니라, 남발하는 사람들에게 &quot;적절히 쓰자&quot;고 말하는 글이다. 개인적으로 글 중에 나온 아래 구절이 인상깊었다.

&gt; Performance optimizations are not free. They ALWAYS come with a cost but do NOT always come with a benefit to offset that cost.

### [Using Next.js and Vercel to instantly load a data-heavy website](https://tinloof.com/blog/using-next.js-and-vercel-to-instantly-load-a-data-heavy-website/)

Vercel 플랫폼에서 돌아가는 Next.js 웹앱의 성능 개선에 관한 글. 프로덕션 레벨까지 배포된 앱에서의 `getStaticProps`의 상세한 사용 예를 볼 수 있다.

### [Demystifying styled-components](https://www.joshwcomeau.com/react/demystifying-styled-components/)

styled-components 의 동작 원리를 간단한 코드와 함께 살펴보는 글. 동적으로 CSS를 삽입하고 클래스 이름을 생성하는 기본적인 원리부터, styled 메서드를 중첩 적용했을 때 어떻게 스타일이 문제 없이 적용되는지에 대해서까지. 사용만으로는 알 수 없는, 공식 문서에서도 찾아보기 힘든 내용들이 들어있다.
</content:encoded></item><item><title><![CDATA[Next.js 로 GitHub Pages 배포하기]]></title><description><![CDATA[간단한 프로토타이핑 공유를 위해, Next.js로 구현한 웹앱을 GitHub Pages에 배포하기로 했다. nextJS 뭘로 배포할까? (Netlify, Vercel, Github page) 문서를 보면 GitHub Pages는 물론이고 Netlify…]]></description><link>https://ricale.kr/blogposts/210613-nextjs-github-pages</link><guid isPermaLink="false">https://ricale.kr/blogposts/210613-nextjs-github-pages</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Sat, 12 Jun 2021 15:00:00 GMT</pubDate><content:encoded>
[origin-post]: https://taeny.dev/javascript/nextjs-with-deployment-platform/#3-netlify-vs-vercel
[origin-post-build-section]: https://taeny.dev/javascript/nextjs-with-deployment-platform/#5--github-page-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0

간단한 프로토타이핑 공유를 위해, Next.js로 구현한 웹앱을 GitHub Pages에 배포하기로 했다.

[nextJS 뭘로 배포할까? (Netlify, Vercel, Github page)][origin-post] 문서를 보면 GitHub Pages는 물론이고 Netlify, Vercel 을 사용해 배포하는 방법과, 플랫폼간의 장단점까지 비교해 놓았다. 세 플랫폼에 모두 관심이 있다면 해당 글을 읽기를 권한다.

이 글에서는 해당 글의 내용을 토대로 GitHub Pages에 배포하는 방법만 간략히 정리한다.

## 1. 배포 방법

[위 문서][origin-post-build-section]에서는 아래의 명령어를 `package.json`에 등록해놓고 사용하라고 안내하고 있다.

```js
&quot;scripts&quot;: {
  &quot;deploy&quot;: &quot;rm -rf node_modules/.cache &amp;&amp; next build &amp;&amp; next export &amp;&amp; touch out/.nojekyll &amp;&amp; git add out/ &amp;&amp; git commit -m \&quot;Deploy Next.js to gh-pages\&quot; &amp;&amp; git subtree push --prefix out origin gh-pages&quot;
},
```

명령어를 하나하나 살펴보면 아래와 같다.

```shell
rm -rf node_modules/.cache
next build
next export
touch out/.nojekyll
git add out/
git commit -m &quot;Deploy Next.js to gh-pages&quot;
git subtree push --prefix out origin gh-pages
```

(각 명령어에 관한 설명은 [원 문서][origin-post-build-section]에 잘 되어있으므로 여기서는 생략하겠다.)

대부분의 경우 위 명령어를 그대로 써도 문제가 없겠지만, 개인적으로는 이슈가 몇 개 있었다.

## 2. 이슈

### 2.1. 빌드 결과물을 git 스테이지에 추가

위에서는 `git add out/` 명령어를 통해 빌드한 결과물을 git의 스테이지에 추가한다. 하지만 일반적인 Next.js 프로젝트에서 `out/` 디렉토리는 `.gitignore`에 등록되어있기 때문에, 해당 명령어로는 스테이지에 추가되지 않는다.

해결 방법은 해당 디렉토리를 `.gitignore`에서 제외시키거나 `-f` 옵션을 주어서 `.gitignore`와 관계 없이 강제로 추가시키는 것이다.

여기서는 `-f` 옵션을 사용한다. 왜냐면 빌드할 때만 `out/` 디렉토리를 스테이지에 포함시키고, 빌드 후에는 삭제할 생각이기 때문이다.

### 2.2. 커밋 및 푸시

위 문서에서는 아래 명령어를 사용해 빌드 결과를 커밋하고 푸시한다.

```shell
git commit -m &quot;Deploy Next.js to gh-pages&quot;
git subtree push --prefix out origin gh-pages
```

이 경우 `out/` 디렉토리의 내용물을 `main`(혹은 `master`) 브랜치에 계속 유지해야 한다. `out/` 디렉토리 내용을 git 에서 계속 유지할 것이라면 문제 없다. 하지만 내 경우 `out/` 디렉토리의 내용을 `main` 브랜치에 유지하고 싶지 않았다. (유지하지 않는 편이 히스토리 관리에 더 좋다고 생각했다.) 내가 원하는 프로세스는 아래와 같다.

1. git 스테이지에 임시로 `out/` 디렉토리를 추가하고 커밋한다.
2. 해당 커밋을 가지고 `gh-pages` 브랜치에 배포를 진행한다. (배포하면 `gh-pages` 브랜치에 커밋이 새로 생성될 것이다.)
3. 배포가 끝난 후 1번에서 추가했던 커밋을 삭제한다.

그럼 원하는 방향이 적용되게끔 명령어를 변경해보자.

```shell
# temp-for-deploy-gh-pages 브랜치를 생성한다.
git checkout -b temp-for-deploy-gh-pages

# 생성한 브랜치에 `out/` 디렉토리가 포함된 내용을 커밋한다.
git commit -m &quot;Deploy Next.js to gh-pages&quot;

# 해당 커밋을 사용해 `out/` 디렉토리만으로 로컬의 gh-pages 브랜치에 새로운 커밋을 만든다.
git subtree split --prefix out -b gh-pages

# 로컬의 gh-pages를 강제로 gh-pages 에 푸시한다.
git push -f origin gh-pages:gh-pages

# 로컬의 gh-pages 브랜치를 삭제한다.
git branch -D gh-pages

# temp-for-deploy-gh-pages 브랜치를 삭제한다.
git checkout main
git branch -D temp-for-deploy-gh-pages
```

`gh-pages`를 강제로 푸시하는 이유는 이미 원격에 `gh-pages` 브랜치가 있을 경우, 새로운 커밋이 원격에 있는 기존의 커밋과 이어지지 않는 커밋이기 때문이다. (`gh-pages`에 추가되는 커밋의 부모 커밋이 `main` 브랜치 쪽에 유지되면, 이어지는 커밋으로 판단된다.)

## 3. 이슈 해결 결과

```shell
rm -rf node_modules/.cache
next build
next export
touch out/.nojekyll
git add -f out/
git checkout -b temp-for-deploy-gh-pages
git commit -m &quot;Deploy Next.js to gh-pages&quot;
git subtree split --prefix out -b gh-pages
git push -f origin gh-pages:gh-pages
git branch -D gh-pages
git checkout main
git branch -D temp-for-deploy-gh-pages
```

위 명령어들을 연달아 쓰면 Next.js 앱을 GitHub Pages에 배포할 수 있다. 매번 치기 귀찮을 것이므로 `package.json`에 등록해두고 사용하자.

```js
&quot;scripts&quot;: {
  &quot;deploy-gh-pages&quot;: &quot;rm -rf node_modules/.cache &amp;&amp; next build &amp;&amp; next export &amp;&amp; touch out/.nojekyll &amp;&amp; git add -f out/ &amp;&amp; git checkout -b temp-for-deploy-gh-pages &amp;&amp; git commit -m \&quot;Deploy Next.js to gh-pages\&quot; &amp;&amp; git subtree split --prefix out -b gh-pages &amp;&amp; git push -f origin gh-pages:gh-pages &amp;&amp; git branch -D gh-pages &amp;&amp; git checkout main &amp;&amp; git branch -D temp-for-deploy-gh-pages&quot;
},
```

## 4. 주의

- 위 내용은 어디까지나 &quot;프로토타이핑 공유를 위한 GitHub Pages 배포&quot;를 목적으로 하고 있다. 다른 목적으로 사용할 경우 적절하지 않을 수 있다.
- 환경변수와 관련된 내용은 이 문서에서 정리하지 않았다. 해당 내용은 [원 문서][origin-post-build-section]에 잘 설명되어 있다.

## References

- [nextJS 뭘로 배포할까? (Netlify, Vercel, Github page)][origin-post]
- [tduarte/publish-ghpages.md](https://gist.github.com/tduarte/eac064b4778711b116bb827f8c9bef7b)
</content:encoded></item><item><title><![CDATA[CRA webpack 분석 (2) - module 설정]]></title><description><![CDATA[1. 서문 create-react-app(이하 CRA) 으로 React 웹앱을 만들었다. 타입스크립트TypeScript도 쓰고 싶어서 만들 때 --template typescript 옵션도 주었다. 웹팩Webpack 설정은 어떻게 되어 있는지 살펴보고…]]></description><link>https://ricale.kr/blogposts/210527-cra-webpack-2-module</link><guid isPermaLink="false">https://ricale.kr/blogposts/210527-cra-webpack-2-module</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Wed, 26 May 2021 15:00:00 GMT</pubDate><content:encoded>
## 1. 서문

create-react-app(이하 CRA) 으로 React 웹앱을 만들었다. 타입스크립트TypeScript도 쓰고 싶어서 만들 때 `--template typescript` 옵션도 주었다. 웹팩Webpack 설정은 어떻게 되어 있는지 살펴보고 싶어서 `yarn eject` 명령어도 실행했다.

(위 문단이 이해되지 않는다면 이 글이 다소 이해하기 어려울 수도 있다. 그럴 경우 [create-react-app 공식 문서](https://create-react-app.dev/docs/documentation-intro/)를 참고하자.)

이번에는 웹팩의 `module` 설정을 살펴보자.

## 2. `module`

`module` 설정은 프로젝트 내 여러 타입의 모듈들을 어떻게 다룰지 정의하는 옵션이다. [웹팩 공식 문서](https://webpack.js.org/configuration/module/)에는 아래와 같이 설명되어 있다.

&gt; These options determine how the different types of modules within a project will be treated.

(*모듈Module*은 기능 단위로 작게 나누어진 코드 뭉치다. ES6+에 익숙하다면 `export` 문으로 선언되고 `import` 문으로 사용되는 것이 모듈이라고 이해하면 되고, CommonJS에 익숙하다면 `exports`로 선언 및 정의되고 `require()`로 사용되는 것을 모듈이라고 이해하면 된다. [참고 문서](https://webpack.js.org/concepts/modules/))

CRA로 생성된 앱에는 `module` 설정에 `strictExportPresence`와 `rules`, 이렇게 두 가지 값이 설정되어 있다.

```js
{
  // ...
  module: {
    strictExportPresence: true,
    rules: [
      // ...
    ]
  },
}
```

`module.strictExportPresence`는 `true`로 설정 시 모듈 내에 exports 문이 없을 때 에러를 발생시키도록 한다. (`false`라면 warning만 발생한다.)

`module.rules`는 웹팩이 모듈을 생성(초기화)할 때 사용하는 규칙들이다. 이 규칙들로 모듈이 생성되는 방법을 변경할 수 있다.

### 2.1. `module.rules`

CRA로 생성된 앱의 `modules.rules`에는 두 규칙이 정의되어 있다.

```js
// ...
rules: [
  { parser: { requireEnsure: false } },
  {
    oneOf: [
      {
        /* ... */
      },
      {
        /* ... */
      },
      {
        /* ... */
      },
      {
        /* ... */
      },
      // ...
    ],
  },
];
```

첫번째는 아래와 같은 비교적 짧은 규칙이다.

```js
{ parser: { requireEnsure: false } },
```

`module.rules`에 사용되는 규칙에는 보통 `test` 값이 포함된다. `test`는 문자열이나 정규표현식, 혹은 그것들의 배열값으로, `test` 조건에 일치하는 파일이 갖고 있는 모듈에 대해서 해당 규칙을 적용하라는 의미이다. (자세한 예는 아래에서 볼 수 있다.)

하지만 위 규칙에는 `test` 값이 없다. 이는 모든 유형의 파일에 대해 적용되는 공통 규칙이라는 의미다. 이 규칙은 이 앱의 모든 모듈에서`require.ensure` 기능을 쓰지 못하도록 하는 규칙이다. (`require.ensure`는 모듈을 동적으로 불러오는 CommonJS 문법이다. 자세한 사항은 [문서](https://webpack.js.org/api/module-methods/#requireensure) 참고)

또다른 규칙은 `oneOf`라는 값을 갖는 객체다.

```js
{
  oneOf: [
    {
      /* ... */
    },
    {
      /* ... */
    },
    {
      /* ... */
    },
    {
      /* ... */
    },
    // ...
  ];
}
```

`oneOf`는 규칙들의 배열인데, 이는 특정 모듈을 생성할 때 조건에 맞는 첫번째 규칙만 적용하도록 지정하는 규칙이다.

다시 정리하자면 모든 모듈은 위의 `{ parser: { requireEnsure: false } }` 규칙이 일괄적으로 적용되고, `oneOf` 규칙 중에서는 첫 번째로 매칭되는 규칙만 적용된다.

### 2.2. 규칙의 조건

`oneOf` 배열에는 9개의 규칙이 포함되어 있다. 해당 규칙들의 조건들만 추려보면 다음과 같다.

```js
{
  test: [/\.avif$/],
  // ...
},
{
  test: [/\.bmp$/, /\.gif$/, /\.jpe?g$/, /\.png$/],
  // ...
},
{
  test: /\.(js|mjs|jsx|ts|tsx)$/,
  include: paths.appSrc,
  // ...
},
{
  test: /\.(js|mjs)$/,
  exclude: /@babel(?:\/|\\{1,2})runtime/,
  // ...
},
{
  test: cssRegex,
  exclude: cssModuleRegex,
  // ...
},
{
  test: cssModuleRegex,
  // ...
},
{
  test: sassRegex,
  exclude: sassModuleRegex,
  // ...
},
{
  test: sassModuleRegex,
  // ...
},
{
  // `test` 값 없음
  exclude: [/\.(js|mjs|jsx|ts|tsx)$/, /\.html$/, /\.json$/],
}
```

위 설정에 따르면, CRA 앱의 모듈은 아래와 같은 순서로 조건을 확인하고 조건에 맞는 규칙에 따라 모듈을 생성한다.

1. `.avif` 파일인지 확인한다.
   - 조건이 일치하면 첫번째 규칙을 사용해 모듈을 생성한다.
   - 아니면 다음 규칙을 확인한다.
2. `.bmp`, `.gif`, `.jpg`, `.jpeg`, `.png` 파일인지 확인한다.
   - 조건이 일치하면 두번째 규칙을 사용해 모듈을 생성한다.
   - 아니면 다음 규칙을 확인한다.
3. `.js`, `.mjs`, `.jsx`, `.ts`, `.tsx` 파일인지 확인한다. 동시에 `paths.appSrc` 경로에 있는 파일인지도 확인한다.
   - 조건이 일치하면 세번째 규칙을 사용해 모듈을 생성한다.
   - 아니면 다음 규칙을 확인한다.
4. `.js`, `.mjs` 파일인지 확인한다. @babel/runtime 패키지에 포함되지 않았는지도 확인한다.
   - 조건이 일치하면 네번째 규칙을 사용해 모듈을 생성한다.
   - 아니면 다음 규칙을 확인한다.
5. `.css` 파일인지 확인한다. `.module.css` 파일이 아닌지도 확인한다.
   - 조건이 일치하면 다섯번째 규칙을 사용해 모듈을 생성한다.
   - 아니면 다음 규칙을 확인한다.
6. `.module.css` 파일인지 확인한다.
   - 조건이 일치하면 여섯번째 규칙을 사용해 모듈을 생성한다.
   - 아니면 다음 규칙을 확인한다.
7. `.scss`, `.sass` 파일인지 확인한다. `.module.scss`, `module.sass` 파일이 아닌지도 확인한다.
   - 조건이 일치하면 일곱번째 규칙을 사용해 모듈을 생성한다.
   - 아니면 다음 규칙을 확인한다.
8. `.module.scss`, `module.sass` 파일인지 확인한다.
   - 조건이 일치하면 여덟번째 규칙을 사용해 모듈을 생성한다.
   - 아니면 다음 규칙을 확인한다.
9. `.js`, `.mjs`, `.jsx`, `.ts`, `.tsx`, `.html`, `.json` 파일이 아닌지 확인한다.
   - 조건이 일치하면 마지막 규칙을 사용해 모듈을 생성한다.

### 2.3. 로더

`loader` 혹은 `use` 값은 모듈을 생성할 때 쓰일 로더를 지정할 때 쓰인다.

(로더Loader는 모듈 생성 시 전처리를 담당하는 라이브러리다. 일반적으로 웹팩에 포함되지 않는 라이브러리들이므로, 별도로 설치를 해주어야 한다. [공식 문서](https://webpack.js.org/loaders/) 참고.)

CRA로 생성된 앱에서는 이미지 파일을 모듈로 생성할 때는 `url-loader`, 자바스크립트 관련 파일에는 `babel-loader`, CSS 관련 파일에는 `style-loader`, `css-loader`, `postcss-loader` 등, 그 이외의 파일들에는 `file-loader`를 사용한다.

유형에 따라 어떻게 설정되었는지 살펴보자.

#### 2.3.1. 이미지 모듈

**2.2. 규칙의 조건**에서 살펴보았던 규칙들 중 `.avif` 파일을 위한 첫번째 규칙, `.bmp`, `.gif`, `.jpg`, `.jpeg`, `.png` 파일들을 위한 두번째 규칙이 `url-loader`를 사용한다. 해당 규칙의 전문은 아래와 같다.

```js
{
  test: [/\.avif$/],
  loader: require.resolve(&apos;url-loader&apos;),
  options: {
    limit: imageInlineSizeLimit,
    mimetype: &apos;image/avif&apos;,
    name: &apos;static/media/[name].[hash:8].[ext]&apos;,
  },
},
{
  test: [/\.bmp$/, /\.gif$/, /\.jpe?g$/, /\.png$/],
  loader: require.resolve(&apos;url-loader&apos;),
  options: {
    limit: imageInlineSizeLimit,
    name: &apos;static/media/[name].[hash:8].[ext]&apos;,
  },
},
```

`loader` 이외에도 `options` 값이 눈에 들어온다. 이 값은 웹팩이 직접 사용하는 값이 아니라 로더 라이브러리에 전달될 설정값이다.

첫번째 규칙에 의하면 `.avif`파일은 먼저 용량(단위: byte)이 `imageInlineSizeLimit`보다 큰지 검사한다. 만약 크다면 `url-loader`가 아닌 `file-loader`가 사용된다. 만약 작다면 `url-loader`에 의해 `&apos;image/avif&apos;` mimetype 에 맞춰 _base64 URI_ 형식으로 변환된다. 변환된 파일은 번들링 결과가 저장되는 디렉토리에 `static/media/[name].[hash:8].avif` 형식으로 저장된다.

두번째 규칙도 첫번째 규칙과 거의 동일하다. 대상이 `.bmp`, `.gif`, `.jpg`, `.jpeg`, `.png` 파일들이라는 것과, mimetype 강제가 없다는 것만 다르다.

#### 2.3.2. 자바스크립트 모듈

**2.2. 규칙의 조건**에서 살펴보았던 규칙들 중 `.js`, `.mjs`, `.jsx`, `.ts`, `.tsx` 파일들을 위한 세번째 규칙, 네번째 규칙은 `babel-loader`를 사용한다. 해당 규칙 전문은 아래와 같다.

```js
{
  test: /\.(js|mjs|jsx|ts|tsx)$/,
  include: paths.appSrc,
  loader: require.resolve(&apos;babel-loader&apos;),
  options: {
    customize: require.resolve(
      &apos;babel-preset-react-app/webpack-overrides&apos;
    ),
    presets: [
      [
        require.resolve(&apos;babel-preset-react-app&apos;),
        {
          runtime: hasJsxRuntime ? &apos;automatic&apos; : &apos;classic&apos;,
        },
      ],
    ],

    plugins: [
      [
        require.resolve(&apos;babel-plugin-named-asset-import&apos;),
        {
          loaderMap: {
            svg: {
              ReactComponent:
                &apos;@svgr/webpack?-svgo,+titleProp,+ref![path]&apos;,
            },
          },
        },
      ],
      isEnvDevelopment &amp;&amp;
        shouldUseReactRefresh &amp;&amp;
        require.resolve(&apos;react-refresh/babel&apos;),
    ].filter(Boolean),
    cacheDirectory: true,
    cacheCompression: false,
    compact: isEnvProduction,
  },
},
{
  test: /\.(js|mjs)$/,
  exclude: /@babel(?:\/|\\{1,2})runtime/,
  loader: require.resolve(&apos;babel-loader&apos;),
  options: {
    babelrc: false,
    configFile: false,
    compact: false,
    presets: [
      [
        require.resolve(&apos;babel-preset-react-app/dependencies&apos;),
        { helpers: true },
      ],
    ],
    cacheDirectory: true,
    cacheCompression: false,

    sourceMaps: shouldUseSourceMap,
    inputSourceMap: shouldUseSourceMap,
  },
},
```

`paths.appSrc`(`PROJECT_ROOT/src` 디렉토리) 안에 있는 자바스크립트 파일들에 세번째 규칙이, 밖에 있는 자바스크립트 파일들에 네번째 규칙이 적용된다. `options`값을 통해 전처리 및 최적화를 다르게 하고 있다는 걸 알 수 있다. 관련된 자세한 내용은 추후 다른 글에서 다시 정리해보겠다.

#### 2.3.3. 스타일시트 모듈

**2.2. 규칙의 조건**에서 살펴보았던 규칙들 중 `.css`, `.module.css`, `.scss`, `.sass`, `.module.scss`, `module.sass` 파일들을 위한 다섯번째 규칙부터 여덟번째 규칙까지는 스타일시트와 관련된 여러 로더를 사용한다. 해당 규칙 전문은 아래와 같다.

```js
{
  test: cssRegex,
  exclude: cssModuleRegex,
  use: getStyleLoaders({
    importLoaders: 1,
    sourceMap: isEnvProduction
      ? shouldUseSourceMap
      : isEnvDevelopment,
  }),
  sideEffects: true,
},
{
  test: cssModuleRegex,
  use: getStyleLoaders({
    importLoaders: 1,
    sourceMap: isEnvProduction
      ? shouldUseSourceMap
      : isEnvDevelopment,
    modules: {
      getLocalIdent: getCSSModuleLocalIdent,
    },
  }),
},
{
  test: sassRegex,
  exclude: sassModuleRegex,
  use: getStyleLoaders(
    {
      importLoaders: 3,
      sourceMap: isEnvProduction
        ? shouldUseSourceMap
        : isEnvDevelopment,
    },
    &apos;sass-loader&apos;
  ),
  sideEffects: true,
},
{
  test: sassModuleRegex,
  use: getStyleLoaders(
    {
      importLoaders: 3,
      sourceMap: isEnvProduction
        ? shouldUseSourceMap
        : isEnvDevelopment,
      modules: {
        getLocalIdent: getCSSModuleLocalIdent,
      },
    },
    &apos;sass-loader&apos;
  ),
},
```

모든 규칙이 `getStyleLoaders` 함수를 쓰고 있는데, 이는 설정 파일 내에 선언된 함수이다. 해당 함수는 각 규칙에 알맞는 로더 설정을 반환한다. 첫번째 인자로 `css-loader` 에 쓰일 `options` 값을 받고 두번째 인자는 대상이 SASS 파일일 경우에만 받으며 `sass-loader`를 써달라는 의미로 쓰인다.

세부 옵션을 다 정리하면 너무 길어지니 간략히 하면 `*.css` 파일들은 아래 로더들을 순서대로 적용한다.

- [postcss-loader](https://github.com/webpack-contrib/postcss-loader): [PostCSS](https://github.com/postcss/postcss)(CSS에 자바스크립트 플러그인을 적용할 수 있게 도와주는 라이브러리)가 적용된 코드를 순수한 CSS로 변환한다.
- [css-loader](https://webpack.js.org/loaders/css-loader/): CSS 안에 `@import`, `url()` 문을 해석(resolve)해 불러온다. 단, 이 로더의 결과는 자동으로 번들링에 반영되지 않는다. `style-loader` 등 다른 로더와 조합해서 써야 한다.
- [style-loader](https://webpack.js.org/loaders/style-loader/): CSS를 `&lt;style&gt;`태그로 감싸서 DOM에 삽입한다.
  - 프로덕션 빌드라면 `style-loader` 대신 [MiniCssExtractPlugin.loader](https://webpack.js.org/plugins/mini-css-extract-plugin/)를 사용한다. 이 로더는 CSS를 `import`한 자바스크립트 파일과 맞춰서 여러 CSS 파일로 나누어 저장한다.

`*.sass`, `*.scss` 파일들은 아래 로더들이 순서대로 적용된다.

- [sass-loader](https://github.com/webpack-contrib/sass-loader): SASS를 CSS로 변환한다.
- [resolve-url-loader](https://www.npmjs.com/package/resolve-url-loader): 분산되어 저장되어있던 SASS 파일들의 상대 경로 관련 이슈를 해결해준다.
- `postcss-loader`
- `css-loader`
- `style-loader`
  - 프로덕션 빌드라면 `style-loader` 대신 `MiniCssExtractPlugin.loader`를 사용한다.

`sideEffect` 옵션은 해당 파일이 다른 파일에도 영향을 주는지 알려주는 옵션이다. 만약 `true` 값이면 해당 규칙에 의해 불려오는 파일은 트리 셰이킹Tree Shaking에 영향받지 않고 무조건 로드된다. 자세한 사항은 [트리 셰이킹 문서](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free)를 참고. (왜 `.css`와 `.scss`, `.sass` 규칙에만 `sideEffect` 옵션이 붙어있는지는 [이 이슈](https://github.com/webpack/webpack/issues/6571)를 참고.)

#### 2.3.4. 기타 파일

**2.2. 규칙의 조건**에서 살펴보았던 규칙들 중 아홉번째 규칙은 위 여덟 개의 규칙의 조건에 해당하지 않은 기타 파일들을 위한 규칙이며 `file-loader`를 사용한다.

```js
{
  loader: require.resolve(&apos;file-loader&apos;),
  exclude: [/\.(js|mjs|jsx|ts|tsx)$/, /\.html$/, /\.json$/],
  options: {
    name: &apos;static/media/[name].[hash:8].[ext]&apos;,
  },
},
```

`file-loader`는 특별한 처리 없이 해당 파일을 `outputPath` 로 복사한다.

또한 자바스크립트 관련 파일은(`.js`, `.jsx`, `.mjs`, `.ts`, `.tsx`) `exclude` 조건에 포함되었는데, 이는 일반적인 자바스크립트 관련 파일들은 세번째 네번째 규칙에서 모두 처리되었을 것이며 처리되지 않은 파일들은 CSS 관련 로더가 런타임에 동적으로 만든 파일일 가능성이 높기 때문이다.

더불이 `.html`과 `.json`도 제외되었는데 이 두 유형은 웹팩의 내장 로더가 처리하므로 별도의 설정이 필요 없기 때문이다.

## 3. 결론

CRA로 생성한 앱의 웹팩 `module` 설정은 이미지 파일, 자바스크립트 관련 파일, 스타일시트 파일, 그리고 기타 파일을 위한 로더 설정이 되어 있음을 간단히 살펴보았다.

어디까지나 훑어본 것이기 때문에 자바스크립트 관련 파일들에 관한 설정이나 스타일시트 파일들에 관한 설정을 자세히 살펴보지는 못했다. 이 설정들은 추후 다른 글을 통해 조금 더 자세히 살펴보도록 하겠다.
</content:encoded></item><item><title><![CDATA[CRA webpack 분석 (1) - resolve.alias 설정]]></title><description><![CDATA[1. 서문 create-react-app(이하 CRA) 으로 React 웹앱을 만들었다. typescript도 쓰고 싶어서 만들 때 --template typescript 옵션도 주었다. webpack 설정을 직접 수정하고 싶어서 yarn eject…]]></description><link>https://ricale.kr/blogposts/210505-cra-webpack-1-resolve-alias</link><guid isPermaLink="false">https://ricale.kr/blogposts/210505-cra-webpack-1-resolve-alias</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Tue, 04 May 2021 15:00:00 GMT</pubDate><content:encoded>
## 1. 서문

create-react-app(이하 CRA) 으로 React 웹앱을 만들었다. typescript도 쓰고 싶어서 만들 때 `--template typescript` 옵션도 주었다. webpack 설정을 직접 수정하고 싶어서 `yarn eject` 커맨드도 실행했다.

(위 문단이 이해되지 않는 사람이라면 이 글이 다소 이해하기 어려울 수도 있다. 그럴 경우 [create-react-app 공식 문서](https://create-react-app.dev/docs/documentation-intro)를 참고하자.)

webpack 직접 설정하기 첫걸음으로, `resolve.alias`를 설정해보자.

## 2. `resolve.alias` 설정하기

`resolve.alias` 옵션은 [공식 문서](https://webpack.js.org/configuration/resolve/#resolvealias) 에서 아래와 같이 설명하고 있다.

&gt; Create aliases to import or require certain modules more easily.
&gt; 특정 모듈을 더욱 쉽게 import 혹은 require 하기 위해 aliases 를 생성한다.

말하자면 상대 경로로 불편하게 `import`해야 했던 것을 쉽게 `import`할 수 있게 해주는 옵션이다.

```javascript
/* webpack.config.js */

// ...
module.exports = {
  //...
  resolve: {
    alias: {
      Utilities: path.resolve(__dirname, &quot;src/utilities/&quot;),
    },
  },
};

/* someCode.js */

// // 위 resolve.alias 설정이 없었다면 이렇게 import 해야 하지만
// import Utility from &apos;../../utilities/utility&apos;;

// 설정 덕분에 상대 경로 없이 편하게 import 할 수 있다.
import Utility from &quot;utilities/utility&quot;;
```

CRA로 만든 앱에서도 이 설정을 이용하고 싶다. 어떻게 하면 효율적으로 적용할 수 있을까? 일단 기존 코드를 분석해보자.

### 2.1. 기존 `resolve.alias` 분석

CRA로 만든 앱의 기존 `resolve.alias` 는 아래와 같다.

```javascript
// ...
resolve: {
  // ...
  alias: {
    // 2.1.1. &apos;react-native&apos;
    // Support React Native Web
    &apos;react-native&apos;: &apos;react-native-web&apos;,
    // 2.1.2. profiling
    // Allows for better profiling with ReactDevTools
    ...(isEnvProductionProfile &amp;&amp; {
      &apos;react-dom$&apos;: &apos;react-dom/profiling&apos;,
      &apos;scheduler/tracing&apos;: &apos;scheduler/tracing-profiling&apos;,
    }),
    // 2.1.3. webpackAliases
    ...(modules.webpackAliases || {}),
  }
  // ...
}
```

#### 2.1.1. `&apos;react-native&apos;`

```javascript
// Support React Native Web
&apos;react-native&apos;: &apos;react-native-web&apos;,
```

이 설정은 react-native-web을 지원하기 위한 설정이다. 지금 우리의 관심사는 아니니 넘어가자.

#### 2.1.2. profiling

```javascript
// Allows for better profiling with ReactDevTools
...(isEnvProductionProfile &amp;&amp; {
  &apos;react-dom$&apos;: &apos;react-dom/profiling&apos;,
  &apos;scheduler/tracing&apos;: &apos;scheduler/tracing-profiling&apos;,
}),
```

여기서 `isEnvProductionProfile` 값은 아래와 같다.

```javascript
const isEnvProductionProfile =
  isEnvProduction &amp;&amp; process.argv.includes(&quot;--profile&quot;);
```

프로덕션 환경이면서, webpack 실행 당시 `--profile` 옵션을 받았는지 여부를 확인하는 플래그이다.

즉 이 웹앱의 성능 분석을 하고자 할 때 사용하는 옵션이다. 자세한 사항은 React 성능 분석 관련 공식 문서([Introducing the React Profiler](https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html))를 참고하자.

#### 2.1.3. `webpackAliases`

```javascript
...(modules.webpackAliases || {}),
```

여기서 `modules`는 아래와 같다.

```javascript
const modules = require(&quot;./modules&quot;);
```

그럼 `./modules.js` 파일을 찾아가 `webpackAliases` 값은 어떻게 지정되어 있는지 살펴보자.

```javascript
return {
  // ...
  webpackAliases: getWebpackAliases(options),
  // ...
};
```

`options`와 `getWebpackAliases`는 뭔지 살펴보자.

##### 2.1.3.1. `options`

`options` 값은 아래와 같다.

```javascript
let config;
if (hasTsConfig) {
  const ts = require(resolve.sync(&quot;typescript&quot;, {
    basedir: paths.appNodeModules,
  }));
  config = ts.readConfigFile(paths.appTsConfig, ts.sys.readFile).config;
} else if (hasJsConfig) {
  /// ...
}
config = config || {};
const options = config.compilerOptions || {};
```

`tsconfig.json`의 `compilerOptions` 값을 읽어온 것이 `options`다.

##### 2.1.3.2. `getWebpackAliases`

`getWebpackAliases` 내용도 보자.

```javascript
function getWebpackAliases(options = {}) {
  const baseUrl = options.baseUrl;

  if (!baseUrl) {
    return {};
  }

  const baseUrlResolved = path.resolve(paths.appPath, baseUrl);

  if (path.relative(paths.appPath, baseUrlResolved) === &quot;&quot;) {
    return {
      src: paths.appSrc,
    };
  }
}
```

인자로 받은 `options`에 `baseUrl`값이 있고, 해당 값이 `path.appPath`와 같으면, `{ src: paths.appSrc }`를 반환하는 함수다.

여기서 `baseUrl`은 타입스크립트 설정에서 쓰이는 값이다. 이 값은 webpack 설정의 `resolve.alias`와 거의 같은 일을 한다. `import`할 때 상대 경로를 쓰지 않고 `baseUrl`부터 절대 경로로 쓸 수 있게끔 설정해준다.

```javascript
/* tsconfig.json */
{
  &quot;compilerOptions&quot;: {
    // ...
    &quot;baseUrl&quot;: &quot;./&quot;
  }
}

// // 위 설정이 없었따면 아래처럼 import 해야 한다.
// import { Button } from &apos;../../../components&apos;;

// 위 설정 덕에 아래처럼 import 가능하다.
import { Button } from &apos;src/components&apos;;
```

문제는 webpack 도 같이 설정을 해주어야 이 기능을 제대로 쓸 수 있다는 것이다. 그래서 위에 나왔던 `getWebpackAliases`의 마지막 즈음 문장을 해석하자면

```javascript
if (path.relative(paths.appPath, baseUrlResolved) === &quot;&quot;) {
  return {
    src: paths.appSrc,
  };
}
```

`path.appPath`(앱의 루트 디렉토리의 절대 경로)와 `baseUrlResolved`(`baseUrl`의 절대 경로)가 같다면 `webpack.alias.src`로 쓰일 값을 `paths.appSrc`(앱의 `./src`의 절대 경로)로 해줘라, 라는 뜻이다.

한 마디로 `...(modules.webpackAliases || {}),` 이 구문은, 타입스크립트의 `baseUrl` 설정값 사용을 webpack 에 적용하기 위한 설정이라고 이해하면 된다.

#### 2.1.4 정리

정리하자면, `--profile` 옵션을 주지 않고 빌드 혹은 devServer 실행을 했다고 하면 `resolve.alias` 설정은 아래와 같이 된다.

```javascript
resolve: {
  alias: {
    &apos;react-native&apos;: &apos;react-native-web&apos;,
  }
}
```

만약 여기에 `tsconfig.json`에서 `baseUrl` 값을 설정해 주었다면 이렇게 설정될 것이다.

```javascript
resolve: {
  alias: {
    &apos;react-native&apos;: &apos;react-native-web&apos;,
    src: paths.appSrc, // `./src` 디렉토리의 절대 경로
  }
}
```

### 2.2. `resolve.alias` 설정 추가하기

그럼 이제 현재 설정을 해치지 않으면서 자연스럽게 `resolve.alias` 설정을 추가해보자.

이 글에서는 `./src/components` 디렉토리와 `./src/themes` 디렉토리를 alias 로 등록할 것이다.

타입스크립트 사용 시에는 `tsconfig.json`도 같이 수정해주어야 적용이 문제 없이 되기 때문에, 위 2.1.3. 항목에서 보았던 것처럼, `tsconfig.json`을 작성하면 자동으로 webpack 설정에도 적용되게끔 진행할 것이다.

#### 2.2.1. `tsconfig.json` 수정

`compilerOptions`에 `baseUrl`과 `paths`를 추가해주자.

```javascript
{
  &quot;compilerOptions&quot;: {
    // ...
    &quot;baseUrl&quot;: &quot;./&quot;,
    &quot;paths&quot;: {
      &quot;components&quot;: [&quot;src/components&quot;],
      &quot;themes&quot;: [&quot;src/themes&quot;]
    }
  },
  // ...
}
```

`baseUrl`은 위에서 한 번 설명했고, `paths`는 webpack 의 `resolve.alias`와 같은 기능이라고 생각하면 된다. (세부 사항이 좀 다르긴 한데, 자세한 내용은 이 문서[TypeScript - Module Resolution](https://www.typescriptlang.org/docs/handbook/module-resolution.html)를 참고하자)

#### 2.2.2. `config/aliases.js` 작성

기존의 설정 코드는 최대한 수정하지 않는 방향으로 진행하겠다. `config/aliases.js`을 추가해서 설정을 작성하자. 기존 코드를 참고해서 작성할 것이기 때문에 코드 중복이 생기겠지만, 기존 설정 코드를 수정할 생각은 없기 때문에 코멘트만 남기는 정도로 넘어가겠다.

우선 `config/modules.js`를 참고해서 `tsconfig.json` 설정 내용을 가져오는 함수를 작성한다.

```javascript
// NOTE: duplicated with `getModules` in ./modules.js
function getCompilerOptions() {
  const hasTsConfig = fs.existsSync(paths.appTsConfig);

  if (!hasTsConfig) {
    throw new Error(&quot;You don&apos;t have a tsconfig.json.&quot;);
  }

  const ts = require(resolve.sync(&quot;typescript&quot;, {
    basedir: paths.appNodeModules,
  }));
  const config =
    ts.readConfigFile(paths.appTsConfig, ts.sys.readFile).config || {};
  return config.compilerOptions || {};
}
```

(타입스크립트를 쓸 것이기 때문에 자바스크립트 관련 코드는 삭제했다.)

가져온 `tsconfig.json`의 설정을 가지고 alias 내용을 생성하는 코드도 작성한다.

```javascript
function getAliases() {
  const { baseUrl, paths: tsPaths } = getCompilerOptions();

  // baseUrl 값이 없으면 tsconfig.json 의 paths 가 제대로 적용되지 않는다.
  // 따라서 해당 값으로 aliases 를 설정할 필요도 없다.
  if (!baseUrl) {
    return {};
  }

  const baseUrlResolved = path.resolve(paths.appPath, baseUrl);

  //  앱의 루트 디렉토리와 baseUrl 이 동일한 디렉토리가 아니라면
  // alias를 설정하지 않는다.
  //  이는 `config/modules.js` 에서도 사용하는 예외처리인데,
  // convention over configuration 을 따르면서
  // 복잡한 예외 처리를 하지 않으려는 의도 같다.
  if (path.relative(paths.appPath, baseUrlResolved) !== &quot;&quot;) {
    return {};
  }

  // `&quot;components&quot;: [&quot;src/components&quot;],` 형태를
  // `&quot;components&quot;: path.resolve(__dirname, `../src/components`)`
  // 형태로 변환
  return Object.keys(tsPaths).reduce((cfg, key) =&gt; {
    cfg[key] = path.resolve(__dirname, `../${tsPaths[key][0]}`);
    return cfg;
  }, {});
}
```

이제 `config/modules.js` 와 같은 방식으로 exports 해주며 마무리하면 된다.

```js
module.exports = getAliases();
```

#### 2.2.3. `webpack.config.js` 수정

이제 작성한 `config/aliases.js` 파일을 `webpack.config.js` 안에서 사용해보자.

```js
// 최상단의 온갖 코드를 require 하는 부분 마지막 부분에
// 적당히 끼워넣자.
const tsAliases = require(&apos;./aliases&apos;);

// ...

// resolve.alias 부분에 설정을 추가하자
      alias: {
        &apos;react-native&apos;: &apos;react-native-web&apos;,
        ...(isEnvProductionProfile &amp;&amp; {
          &apos;react-dom$&apos;: &apos;react-dom/profiling&apos;,
          &apos;scheduler/tracing&apos;: &apos;scheduler/tracing-profiling&apos;,
        }),
        ...(modules.webpackAliases || {}),
        ...tsAliases, // &lt;- 이 코드를 추가하자
      },
```

## 3. 결과

이제 `tsconfig.json` 파일의 `compilerOptions.paths` 값을 가지고 webpack 의 `resolve.alias` 옵션을 자동 설정할 수 있게 되었다. 실제 프로젝트에 적용된 코드가 궁금하다면 아래 소스 코드들을 참고하자.

- [ricale.github.io/tsconfig.json](https://github.com/ricale/ricale.github.io/blob/develop/tsconfig.json)
- [ricale.github.io/config/aliases.js](https://github.com/ricale/ricale.github.io/blob/develop/config/aliases.js)
</content:encoded></item><item><title><![CDATA[Create React App 으로 GitHub Pages 적용하기]]></title><description><![CDATA[References Create React App documentation - Deployment - GitHub PagesGitHub Docs - Managing a custom domain for your GitHub Pages site

C…]]></description><link>https://ricale.kr/blogposts/210503-create-react-app-github-pages</link><guid isPermaLink="false">https://ricale.kr/blogposts/210503-create-react-app-github-pages</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Sun, 02 May 2021 15:00:00 GMT</pubDate><content:encoded>
## References

[managing-domain]: https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site

- [Create React App documentation - Deployment](https://create-react-app.dev/docs/deployment/) - [GitHub Pages](https://create-react-app.dev/docs/deployment/#github-pages)
- [GitHub Docs](https://docs.github.com/en) - [Managing a custom domain for your GitHub Pages site][managing-domain]

---

[Create React App](https://create-react-app.dev)은 React 웹앱을 만들고자 할 때 프로젝트 초기 셋팅 (디펜던시 설치, 각종 설정 적용 등) 을 도와주는 편리한 툴이다. 이 글에서는 이 툴을 가지고 생성한 앱을 [GitHub Pages](https://pages.github.com/)에 배포해 볼 것이다.

이 글은 위 References 의 두 문서를 보며 진행한 작업을 정리한 것이다. 따라서 영어를 읽는데 문제가 없다면 이 문서를 보는 것 보다는 References 의 두 문서를 보는 것을 권한다.

## 1. React 앱 생성

먼저 Create React App 으로 웹앱을 만들자.

`create-react-app`을 설치하자. 전역적으로 설치해야 하므로 `yarn global add` 명령어를 쓴다.

```shell
yarn global add create-react-app
```

그리고 앱을 생성한다.

```shell
# ./app-name 폴더에 프로젝트 생성
yarn create react-app app-name

# 현재 폴더에 프로젝트 생성
yarn create react-app .

# 타입스크립트가 적용된 프로젝트 생성
yarn create react-app app-name --template typescript
```

`./src/index.ts`가 엔트리 포인트다. (앱을 구현하는 자세한 방법은 [Create React App 공식 문서](https://create-react-app.dev/docs/documentation-intro)와 [React 공식 문서](https://reactjs.org/docs/getting-started.html)를 참고하자.)

개발 중에는 개발 서버를 띄워서 확인하고

```shell
yarn start # 로컬 개발 서버를 띄운다
```

개발이 끝나면 빌드한 뒤 그 결과물을 배포하면 된다.

```shell
yarn build # 빌드한다.
```

### 1.1. `eject`

`create-react-app`은 webpack 등 설정과 관련된 것을 [react-scripts](https://github.com/facebook/create-react-app/tree/master/packages/react-scripts) 모듈에 몰아넣어서, 사용자는 신경쓰지 않아도 되게끔 관리하고 있다. webpack 설정을 직접 수정할 일이 없다면 신경쓰지 않아도 되지만, 만약 직접 수정하고 싶다면 `eject`를 해주어야 한다.

```shell
yarn eject # `react-scripts` 내부에 숨겨져있던 설정 파일들이 프로젝트에 생성된다.
```

`eject` 과정은 GitHub Pages 기능을 사용하는 데 필요한 과정은 아니므로 생략해도 무방하다.

## 2. 설정 및 배포

구현한 앱을 GitHub Pages 에 배포하려면 간단한 설정을 해주어야 한다.

### 2.1. 주소 설정

먼저 프로젝트의 `package.json` 파일에 아래 내용을 추가하자.

```javascript
&quot;homepage&quot;: &quot;https://username.github.io&quot;,
```

만약 username.github.io 코드저장소가 아닌, 기존 프로젝트에 GitHub Pages 기능을 사용하는 것이라면 아래 형식으로 해야 한다.

```javascript
&quot;homepage&quot;: &quot;https://username.github.io/my-app&quot;,
```

### 2.2. 빌드 명령어 추가

[gh-pages](https://github.com/tschaub/gh-pages)를 설치한 뒤

```shell
yarn add --dev gh-pages
```

`package.json`의 `scripts` 에 아래 내용을 추가하자.

```javascript
&quot;scripts&quot;: {
  &quot;predeploy&quot;: &quot;yarn build&quot;,
  &quot;deploy&quot;: &quot;gh-pages -b master -d build&quot;,
  // ...
}
```

`-b master` 옵션은 빌드 결과를 `master` 브랜치로 올려주겠다는 옵션이다. 만약 다른 브랜치를 사용하려면 변경해주어도 좋다. 브랜치를 설정해주지 않으면 (`-b` 옵션을 제거하면) `gh-pages` 브랜치에 빌드 결과가 올라간다.

### 2.3. 빌드

```shell
yarn deploy
```

`yarn build` 명령어를 통해 생성된 빌드 결과가 `master` 브랜치의 새로운 커밋으로 푸시된다.

### 2.4. GitHub 코드저장소 설정

코드저장소의 [settings] 페이지의 [Pages] 메뉴에 들어가면 GitHub Pages 관련 설정을 수정할 수 있다.

![](./screenshot1.png)

#### Source

GitHub Pages 로 쓰일 브랜치와 디렉토리를 지정할 수 있다. 기본값은 `master` 브랜치와 root 디렉토리이다. 위의 과정을 쭉 따라왔다면 이 값은 수정할 필요가 없다.

#### Custom domain

이 메뉴에서 커스텀 도메인 설정이 가능하다.

## 3. 커스텀 도메인 적용

usename.github.io 도메인이 마음에 들지 않는다면 위에서 언급한 Custom domain 메뉴 및 몇 가지 설정을 통해 자신이 갖고 있는 도메인으로 설정할 수 있다.

### 3.1. 주소 설정

먼저 &quot;2.1. 주소 설정&quot;에서처럼 `package.json`의 `homepage` 항목을 수정하자.

```javascript
&quot;homepage&quot;: &quot;http://mydomain.com&quot;,
```

### 3.2. 도메인 네임서버 CNAME 설정

도메인 등록 업체로 가서 CNAME 을 설정해주어야 한다. 업체마다 설정 페이지가 다를 수 있다. [후이즈](https://whois.co.kr/) 기준으로 [네임서버 고급설정] - [CNAME 레코드 관리] 메뉴로 들어가면 설정할 수 있다.

![](./screenshot2.png)

| 호스트명         | CNAME 레코드       |
| ---------------- | ------------------ |
| www.mydomain.com | username.github.io |

위처럼 설정해준다.

### 3.3. 도메인 네임서버 A 레코드 설정

A 레코드도 설정해주자. [후이즈](https://whois.co.kr/) 기준으로 [네임서버 고급설정] - [A 레코드 관리 (네임서버 호스팅)] 메뉴에서 설정할 수 있다.

![](./screenshot3.png)

| 호스트명     | IP 주소         |
| ------------ | --------------- |
| mydomain.com | 185.199.108.153 |
| mydomain.com | 185.199.109.153 |
| mydomain.com | 185.199.110.153 |
| mydomain.com | 185.199.111.153 |

주의할 점은 여기에서는 www.mydomain.com 이 아니라 mydomain.com 이라는 것이다. www 를 뺀다.

### 3.4. 코드저장소의 Custom domain 설정

코드저장소의 Settings 페이지의 Pages 메뉴에 들어가면 Custom domain 섹션이 존재한다. 이곳에 사용하고자 하는 도메인(mydomain.com)을 적자.

Save 버튼을 누르면 자동으로 `master` 브랜치에 추가 커밋이 생성되는데, 해당 커밋에서는 루트 디렉토리에 `CNAME` 파일을 자동 생성해준다. 해당 파일에는 방금 작성한 도메인이 작성되어 있다.

주의할 점은, 작업 브랜치의 `./public` 디렉토리에도 동일한 파일을 생성해 주어야 한다. 만약 생성해주지 않으면 다음 `yarn deploy` 때는 `CNAME` 파일이 자동 생성되지 않는다.

### 3.4. 결과

이제 mydomain.com 으로 내 GitHub Pages 가 접속된다.

#### 결과물 예시

이 [코드저장소](https://github.com/ricale/ricale.github.io)에서 결과물을 볼 수 있다.

## 4. 이슈

### 4.1. `NotServedByPagesError`

&quot;3.4. 코드저장소의 Custom domain 설정&quot; 메뉴에서 도메인을 입력하고 Save 버튼을 누르면 아래와 같은 메시지가 뜰 때가 있다.

&gt; Both www.mydomain.com and its alternate name are improperly configured
&gt; Domain does not resolve to the GitHub Pages server. For more information, see Learn more (NotServedByPagesError). We recommend you change this to a CNAME record pointing to username.github.io.

정확한 원인이 무엇인지 알아내지 못했는데, 네임서버 설정은 원래 전파되는데 시간이 걸릴 수 있어서 그렇다는 이야기가 있다. 실제로 몇 시간이 지나고 부터는 에러 메시지가 없어졌다.
</content:encoded></item><item><title><![CDATA[기술 면접에서 받은 질문 (2) - React 및 기타]]></title><description><![CDATA[요 근래 몇몇 크고 작은 회사에서 기술 면접을 봤다. 경력에 관련된 질문은 제외하고, 순수하게 기술과 관련된 질문 중 기억에 남는 것들을 정리해 보았다. 이 글에는 React를 비롯한 여러 라이브러리와 기타 프론트엔드 관련된 내용들을 정리했다…]]></description><link>https://ricale.kr/blogposts/210430-tech-interview-questions-2</link><guid isPermaLink="false">https://ricale.kr/blogposts/210430-tech-interview-questions-2</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Thu, 29 Apr 2021 15:00:00 GMT</pubDate><content:encoded>
요 근래 몇몇 크고 작은 회사에서 기술 면접을 봤다. 경력에 관련된 질문은 제외하고, 순수하게 기술과 관련된 질문 중 기억에 남는 것들을 정리해 보았다.

이 글에는 React를 비롯한 여러 라이브러리와 기타 프론트엔드 관련된 내용들을 정리했다. Vanilla JavaScript 에 관련된 질문은 [이전 글](https://ricale.kr/blog/posts/210430-tech-interview-questions-1/)에서 정리했다.

인용구로 작성된 내용은 *인용구가 나오기 전 링크가 연결된 문서*에서 가져온 문장이거나, 해당 문서에 있는 영문장을 번역한 문장이다.

# React

## 1. 함수 컴포넌트와 클래스 컴포넌트의 차이

함수 컴포넌트와 클래스 컴포넌트의 차이를 묻는 질문이었다. React Hooks API 기능이 나오면서 차이는 없어졌다고 봐도 무방하지만, 굳이 찾아보면 아래와 같은 차이가 있다.

- 문법
- 클래스 컴포넌트는 라이프 사이클을 지원한다.
  - 함수 컴포넌트도 `useEffect` 등을 사용하면 대부분의 라이프 사이클을 사용할 수 있다.
  - `componentDidCatch`, `getSnapshotBeforeUpdate`, `getDerivedStateFromError`는 여전히 사용할 수 없다.
- 클래스 컴포넌트는 `state`를 지원한다.
  - 함수 컴포넌트도 `useState`를 사용하면 `state`를 사용할 수 있다.
- 클래스 컴포넌트는 ref 인자를 받거나 자신의 자식 컴포넌트에게 ref 를 줄 수 있다.
  - 함수 컴포넌트도 `forwardRef`와 `useRef`를 통해 ref 를 사용할 수 있다.

## 2. `useLayoutEffect`

`useLayoutEffect`를 사용한 적이 있는지, `useEffect`와 어떻게 다른지에 관한 질문이었다. 해당 내용은 [Hooks API Reference](https://reactjs.org/docs/hooks-reference.html) 문서의 [useLayoutEffect](https://reactjs.org/docs/hooks-reference.html#uselayouteffect) 섹션에서 확인할 수 있다.

---

&gt; 주요 특징은 `useEffect`와 동일하다. 하지만 `useLayoutEffect`는 모든 DOM 변경이 끝난 이후에 동기적으로 실행된다. 이것은 DOM으로부터 레이아웃을 읽어와 동기적으로 재렌더링할 때 사용된다. `useLayoutEffect` 내에서 예정된 업데이트는 브라우저가 실제로 렌더링을 업데이트하기 전에 동기적으로 실행된다.

&gt; **일단 `useEffect`를 먼저 사용하기를 권한다.** 만약 `useEffect`가 문제를 일으키면 그 때 `useLayoutEffect`를 사용하라. (원문: **we recommend starting with useEffect first** and only trying useLayoutEffect if that causes a problem.)

컴포넌트가 업데이트된 직후 `useEffect`에서 다시 컴포넌트 업데이트를 시도하면, 바로 화면 업데이트를 재시도하면서 화면이 깜빡이는 것처럼 보일 수 있다 (flikering). 이럴 때 `useLayoutEffect`를 사용하면, 화면이 갱신되기 직전에 동기적으로 로직이 실행되므로 깜빡이는 현상을 막을 수 있다.

[When to useLayoutEffect Instead of useEffect (example)](https://daveceddia.com/useeffect-vs-uselayouteffect/) 문서에서 예제 코드를 실행해 볼 수 있다.

## 3. Context API

React Context API 가 무엇인지, 사용해 봤는지에 관한 질문이었다. reactjs.org 의 [Context](https://reactjs.org/docs/context.html) 문서에 잘 설명되어 있다.

---

&gt; Context 는 React 컴포넌트 트리 내에서 데이터를 &quot;글로벌&quot;하게 공유하게 위해 설계되었다.

React로 개발을 한 경험이 있다면 직접 사용해 보지는 않았더라도 외부 라이브러리를 통해 간접적으로 사용해 보았을 것이다. [React Redux](https://react-redux.js.org/)의 `Provider`, [styled components](https://styled-components.com/)의 `ThemeProvider`, [React DnD](https://github.com/react-dnd/react-dnd)의 `DndProvider` 등 많은 라이브러리에서 내부적으로 Context를 사용하고 있다.

&gt; 만약 특정 prop을 멀리 있는 컴포넌트에게 전달하기만을 원한다면, Context 보다는 [component composition](https://reactjs.org/docs/composition-vs-inheritance.html)(prop을 여러 레벨에 거쳐 계속 전달하기보다는 해당 prop을 사용하는 컴포넌트 자체를 전달하는 방식)이 종종 더 간단한 해결책이 되곤 한다.

## 4. `useReducer`

어떤 상황을 주고 해당 상황에 대해 `useReducer`를 사용해서 해결할 수 있겠느냐는 질문이었다. `useReducer`에 관한 내용은 [Hooks API Reference](https://reactjs.org/docs/hooks-reference.html) 문서의 [해당 섹션](https://reactjs.org/docs/hooks-reference.html#usereducer)에서 확인할 수 있다.

---

&gt; ```javascript
&gt; const [state, dispatch] = useReducer(reducer, initialArg, init);
&gt; ```
&gt;
&gt; `useState`의 대안이 될 수 있다. `(state, action) =&gt; newState` 타입의 `reducer`를 인자로 받고, 현재 `state`와 `dispatch` 메서드를 반환해준다. (만약 Redux에 익숙하다면, 당신은 이미 이게 어떻게 동작하는지 알고 있을 것이다.)

## 5. 부모자식 컴포넌트 간 렌더링/라이프 사이클 순서

부모자식 컴포넌트 간 렌더링 순서를 묻는 질문이었다. 직관적으로 알 수 있듯이, 부모를 렌더링하다가 자식 컴포넌트를 그려야 하는 시점이 오면 자식을 먼저 렌더링하고 부모의 남은 부분을 마저 렌더링하는 식으로 진행된다.

imkev.dev의 [React Rendering Order](https://imkev.dev/react-rendering-order) 글을 보면 예시까지 있어 더 이해하기 쉬울 것이다.

라이프 사이클 순서도 렌더링과 별반 다를 것 없다.

## 6. Hooks API로 라이프사이클 구현

함수 컴포넌트에서 Hooks API로 클래스 컴포넌트의 라이프사이클 메서드를 구현할 수 있는지 묻는 질문이었다.

`useEffect`로 `componentDidMount`, `componentDidUpdate`, `componentDidUnmount` 를 대체할 수 있다. 자세한 설명은 [Using the Effect Hook](https://reactjs.org/docs/hooks-effect.html) 문서에서 볼 수 있다.

&gt; 만약 당신이 React 클래스의 라이프사이클 메서드에 익숙하다면, `useEffect` hook이 `componentDidMount`, `componentDidUpdate`, `componentDidUnmount`의 조합이라고 생각할 수 있겠다.

`useMemo`, `useCallback` 등을 활용해서 `shouldComponentUpdate`도 대체할 수 있다. 관련 내용은 [Hooks API Reference 문서의 useCallback 항목](https://reactjs.org/docs/hooks-reference.html#usecallback)에서 볼 수 있다.

&gt; `useCallback`은 콜백 함수를 전달 받는 자식 컴포넌트의 reference 비교에 의존한 불필요한 렌더링을 막는데 유용하다. (예를 들면 `shouldComponentUpdate` 같이)

# 그 외 라이브러리

## 1. TypeScript 장단점

현재 재직 중인 회사의 프로젝트에서 타입스크립트를 쓰고 있어서 나온 질문이다. 아마 타입스크립트를 사용한 적이 없는 사람들에게는 질문하지 않을 것 같다. 관련 내용은 [The Good and the Bad of TypeScript](https://www.altexsoft.com/blog/typescript-pros-and-cons/) 문서나 [자바스크립트 개발자를 위한 타입스크립트](https://ahnheejong.gitbook.io/ts-for-jsdev/)의 [1.2 왜 타입스크립트인가](https://ahnheejong.gitbook.io/ts-for-jsdev/01-introducing-typescript/why-typescript) 문서 등 많은 문서에 나와 있다.

---

간단히 정리해보자면 장점은 아래와 같다.

- 코드의 가독성을 올려준다.
  - 유지보수, 리팩토링 등이 용이해진다.
- 자바스크립트 사용자가 습득하기 쉽다.
- 타입과 관련된 에러를 컴파일 단계에서 잡아준다.
- OOP를 지원한다.

단점은 아래와 같다.

- 진짜 정적 타이핑이 아니다. 컴파일 후에는 자바스크립트로 변환된다. 따라서 런타임에서는 여전히 타입과 관련된 에러 가능성이 있다.
- 타입 선언 및 사용을 위해 코드 작성을 더 해야 한다. 작업 시간이 늘어나며 소스코드의 크기도 커진다.

## 2. Redux

Redux가 어떤 것인지, 장단점이 무엇인지, 비슷한 다른 것들은 써보았는지, 어떤 상황에서 쓰면 좋고 어떤 상황은 피하는 게 좋은지. Redux를 써봤다고 하면 들을 수 있는 전형적인 질문들이었다.

---

&gt; Redux는 JavaScript를 위한 예측 가능한 상태 컨테이너이다.
&gt;
&gt; 이것은 **일관적으로 동작하고 다른 여러 환경에서 동작하며 테스트하기 쉬운 앱**을 만들 수 있도록 도와준다.

[Redux 공식 문서](https://redux.js.org/introduction/getting-started)에는 위처럼 나와있다. Redux가 무엇인지에 대한 간략한 답은 &quot;React에서는 전역적인 상태 관리를 위한 라이브러리&quot;라고 하면 충분할 것이고, 더 깊은 답을 원한다면 One-way(single-direction) data flow 등으로 대표되는 [Flux architecture](https://facebook.github.io/flux/)와 연관지어 설명해주면 된다.

Redux를 대체할 수 있는 것으로는 [MobX](https://mobx.js.org/README.html), [Recoil](https://recoiljs.org/) 등이 있고 React Context API 로도 대체할 수 있다.

- MobX에 관한 좋은 글: [React에서 Mobx 경험기 (Redux와 비교기)](https://woowabros.github.io/experience/2019/01/02/kimcj-react-mobx.html)
- Recoil에 관한 좋은 글: [Recoil - 또 다른 React 상태 관리 라이브러리?](https://ui.toast.com/weekly-pick/ko_20200616)

Redux가 전역적인 상태 관리에 좋긴 하지만 간단한 앱에서는 도리어 코드의 복잡도만 올릴 뿐 생산성에 도움이 되지 않는 경우도 있다. 따라서 만드려는 앱의 규모와 관리하려는 상태의 구조를 잘 생각해 사용을 선택해야 한다.

## 3. webpack 최적화

[webpack-optimization-document]: https://blog.logrocket.com/guide-performance-optimization-webpack/

webpack 최적화 경험에 관한 질문이었다. 관련 내용은 [An in-depth guide to performance optimization with webpack][webpack-optimization-document] 글에 잘 나와있다.

---

일단 가장 단순한 최적화는 `mode: &apos;production&apos;` 설정을 해주는 것이다. 이렇게 설정해주면 webpack에서 많은 설정을 자동으로 해주는데, [공식 문서](https://webpack.js.org/configuration/mode/)에 따르면 아래와 같은 설정들을 적용해준다.

&gt; `DefinePlugin`을 사용해 `process.env.NODE_ENV` 값을 `production`으로 설정해준다. module과 chunk를 위한 deterministic mangled names, `FlagDependencyUsagePlugin`, `FlagIncludedChunksPlugin`, `ModuleConcatenationPlugin`, `NoEmitOnErrorsPlugin`, `TerserPlugin`을 활성화해준다.

[Webpack Bundle Analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer)를 사용해 번들링된 결과물의 Treemap을 시각화해서 볼 수 있다. 이 Treemap을 보며 각 모듈이 어떻게 구성되고 크기가 얼마나 하는지 알 수 있고, 불필요하거나 비효율적인 모듈을 찾을 수도 있다.

이외에도 [이 글][webpack-optimization-document]에서는 아래와 같은 방법들을 제시한다.

- 가능하다면 앱의 구조 및 설계에 따라 앱을 SPA(Single-Page Application)가 아닌 MPA(Multi-Page Appliation)로 구성하자.
- 캐시 효율을 높이기 위해 외부 라이브러리와 직접 작성한 코드를 나눠서 번들링하자.
- Lazy-load 기능을 활용하자.
  - reactjs.org의 [Code-Splitting](https://reactjs.org/docs/code-splitting.html) 문서도 참고
- 외부 라이브러리를 번들링에서 제외하고, CDN 등을 통해 따로 제공하자.
- [Tree Shaking](https://webpack.js.org/guides/tree-shaking/) (사용하지 않는 코드를 번들링에서 제외하는 것) 기능을 활용하자.
  - [Webpack 4의 Tree Shaking에 대한 이해](https://huns.me/development/2265), [Webpack에서 Tree Shaking 적용하기](https://medium.com/naver-fe-platform/webpack%EC%97%90%EC%84%9C-tree-shaking-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0-1748e0e0c365) 문서들 참고
- 번들링 결과물의 크기를 제한하자.
  - `performance.maxAssetSize`, `performance.maxEntrypointSize` 옵션 등. webpack의 [Performance 옵션](https://webpack.js.org/configuration/performance/) 문서 참고
- 목적에 따른 적절한 [Devtool](https://webpack.js.org/configuration/devtool/) 옵션을 사용하자.

# 일반

## 1. 브라우저 렌더링 방식

브라우저가 웹페이지를 렌더링할 때 어떤 일이 일어나는 가를 설명해달라는 질문이었다. 관련 내용은 [브라우저 렌더링 과정 - Reflow Repaint, 그리고 성능 최적화](https://boxfoxs.tistory.com/408) 문서에 자세히 나와있다.

---

렌더링 엔진의 기본 동작 방식은 아래와 같다.

1. 먼저 DOM(Document Object Model) Tree와 CSSOM (CSS Object Model) Tree를 생성한다.
2. 위 두 항목을 기반으로 Render Tree를 생성한다.
3. Layout 단계: Render Tree를 사용해 뷰포트Viewport에서의 엘리먼트의 크기와 위치를 계산한다.
4. Paint 단계: Layout 단계에서 계산한 값을 가지고 실제로 화면에 그린다.

### Reflow

Layout 단계부터 다시 렌더링 작업을 수행하는 것을 Reflow 라고 한다. 아래와 같은 경우에 Reflow가 발생한다.

- 페이지 최초 렌더링 시
- 윈도우 리사이징 시
- 노드 추가 또는 제거 시
- 요소 위치 또는 크기 변경 시
- 폰트, 텍스트 내용, 이미지 크기 변경 시

### Repaint

Paint 단계를 다시 렌더링 작업을 수행하는 것을 Repaint 라고 한다. 아래와 같은 경우에 Repaint가 발생한다.

- Reflow 발생 시
- 레이아웃에 영향을 주지 않는 스타일 속성 변경 시 (예, `background-color`, `visibility`)

### Reflow, Repaint 줄이려면

1. Reflow, Redraw 가 발생하는 CSS 속성들의 사용을 피하자.
2. 레이아웃 변경 시 영향을 주는 노트/엘리먼트 수를 줄이자.
3. 애니메이션 사용 시 애니메이션 프레임을 줄이자.

### 추가로 볼 문서

위에서 언급한 [브라우저 렌더링 과정 - Reflow Repaint, 그리고 성능 최적화](https://boxfoxs.tistory.com/408) 문서도 충분히 좋은 내용이다.

MDN의 [Populating the page: how browsers work](https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work) 문서나 네이버 개발자 블로그의 [브라우저는 어떻게 동작하는가?](https://d2.naver.com/helloworld/59361) 문서도 좋다. 두 문서는 내용이 꽤 길긴 하지만 충분히 읽어볼 만하다.
</content:encoded></item><item><title><![CDATA[기술 면접에서 받은 질문 (1) - JavaScript]]></title><description><![CDATA[요 근래 몇몇 크고 작은 회사에서 기술 면접을 봤다. 경력에 관련된 질문은 제외하고, 순수하게 기술과 관련된 질문 중 기억에 남는 것들을 정리해 보았다. 이 글에는 Vanilla JavaScript에 관련된 내용만 정리했다. TypeScript…]]></description><link>https://ricale.kr/blogposts/210430-tech-interview-questions-1</link><guid isPermaLink="false">https://ricale.kr/blogposts/210430-tech-interview-questions-1</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Thu, 29 Apr 2021 15:00:00 GMT</pubDate><content:encoded>
요 근래 몇몇 크고 작은 회사에서 기술 면접을 봤다. 경력에 관련된 질문은 제외하고, 순수하게 기술과 관련된 질문 중 기억에 남는 것들을 정리해 보았다.

이 글에는 Vanilla JavaScript에 관련된 내용만 정리했다. TypeScript, React, 그 외 기타 프론트엔드에 관련된 질문은 [다음 글](https://ricale.kr/blog/posts/210430-tech-interview-questions-2/)에서 정리한다.

인용구로 작성된 내용은 *인용구가 나오기 전 링크가 연결된 문서*에서 가져온 문장이거나, 해당 문서에 있는 영문장을 번역한 문장이다.

## 1. 부모자식 엘리먼트 간 이벤트 흐름

이벤트 버블링과 이벤트 캡쳐링에 관해 묻는 질문이었다. 해당 내용은 MDN의 [Introduction to events](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events) 문서의 [Event bubbling and capture](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_bubbling_and_capture) 섹션에서 확인할 수 있다.

---

&gt; 부모 엘리먼트를 갖고 있는 엘리먼트에 이벤트가 발생하면, 모던 브라우저Morden Browser는 두 가지의 국면에 돌입한다. 각각을 캡쳐링Capturing 과 버블링Bubbling 이라 칭한다.
&gt;
&gt; 캡처링에서는:
&gt;
&gt; - 브라우저는 이벤트가 발생한 엘리먼트의 최상위 부모 엘리먼트(`&lt;html&gt;`)를 찾아 그 엘리먼트가 이벤트 리스너를 갖고 있는지 확인한다. 만약 갖고 있다면 이벤트 리스너를 실행한다.
&gt; - 이후 바로 아랫단계의 부모 엘리먼트를 찾는다. 그리고 위에서 한 일을 반복한다. 이것을 이벤트가 발생한 엘리먼트에 도달할 때까지 반복한다.
&gt;
&gt; 버블링에서는:
&gt;
&gt; - 브라우저는 이벤트가 발생한 엘리먼트가 이벤트 리스너를 갖고 있는지 확인한다. 만약 갖고 있다면 이벤트 리스너를 실행한다.
&gt; - 이후 바로 윗단계의 부모 엘리먼트를 찾는다. 그리고 위에서 한 일을 반복한다. 이것을 최상위 부모 엘리먼트(`&lt;html&gt;`)에 도달할 때까지 반복한다.

간단히 말해 이벤트가 발생하면, 캡처링은 위에서부터 쭉 훑으며 이벤트 리스너를 실행하고, 버블링은 아래에서부터 쭉 훑으며 이벤트 리스너를 실행한다.

&gt; 모던 브라우저에서, 모든 이벤트는 기본적으로 버블링 과정을 거치도록 되어있다.

&gt; 버블링 과정을 거치게 하고 싶지 않다면 (해당 엘리먼트만 이벤트를 처리하게 하고 싶다면) `event.stopPropagation()`을 사용하면 된다.

&gt; 만약 캡처링 과정을 거치게 하고 싶다면, `addEventListener()` 메서드의 세 번째 인자를 `true`로 하면 된다.

개인적으로 이벤트 캡처링을 실무에서 사용해 본 경험은 없다. 버블링은 이벤트 델리게이션을 활용하기 위해 많이 사용했다. 이벤트 델리게이션은 수많은 자식 엘리먼트의 이벤트 핸들링을 부모 엘리먼트에서 한 번에 처리하는 것을 말한다. (예, `&lt;table&gt;` 혹은 `&lt;ul&gt;` 등의 부모 엘리먼트 안에 각각의 항목에 대해 동일한 종류의 처리를 해줘야 할 때)

[javascript.info](https://javascript.info/)의 [Bubbling and capturing](https://javascript.info/bubbling-and-capturing) 문서도 참고할 만 하다.

## 2. 호이스팅

호이스팅이 무엇인지, 그리고 그것을 `var`, `const`, `let`과 연관지어서 설명해달라는 질문이었다. 해당 내용은 MDN의 [Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting) 문서에서 확인할 수 있다.

---

&gt; 개념적인 호이스팅Hoisting의 정의는 &quot;변수와 함수의 선언이 물리적으로 코드의 최상단으로 이동한다&quot;는 것이다. 하지만 실제로는 그렇지 않다. 실제로는 컴파일 단계에서 변수와 함수의 선언이 메모리에 저장되지만, 코드상으로는 입력된 위치에 그대로 남아있다.

&gt; ```javascript
&gt; catName(&quot;Chloe&quot;);
&gt; function catName(name) {
&gt;   console.log(&quot;My cat&apos;s name is &quot; + name);
&gt; }
&gt; /*
&gt; The result of the code above is: &quot;My cat&apos;s name is Chloe&quot;
&gt; */
&gt; ```

함수를 사용하는 코드가 함수의 선언 앞에 있어도 호이스팅에 의해 문제 없이 실행된다.

&gt; 오직 선언만이 호이스팅 된다. 초기화는 호이스팅되지 않는다.

&gt; `let`과 `const`는 호이스팅되지 않는다.

```javascript
console.log(&quot;a is&quot;, a); // -&gt; &quot;a is undefined&quot;
console.log(&quot;b is&quot;, b); // -&gt; Uncaught ReferenceError: b is not defined
console.log(&quot;c is&quot;, c); // -&gt; Uncaught ReferenceError: Cannot access &apos;c&apos; before initialization
console.log(&quot;d is&quot;, d); // -&gt; Uncaught ReferenceError: d is not defined

var a = 1;
b = 2;
const c = 3;
let b = 4;
```

## 3. `this` 바인딩

함수 내부에서 `this` 바인딩이 어떤 원리와 과정으로 진행되는지 설명해달라는 질문이었다. 관련된 내용은 MDN의 [this](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) 문서에서 확인할 수 있다.

---

`this`는 함수가 어떻게 호출되느냐에 따라 그 값이 달라진다.

### 3.1. 글로벌 컨텍스트

글로벌 컨텍스트에서 `this`는 글로벌 객체가 된다. (브라우저 환경에서는 `window`, node.js 환경에서는 `globalThis` 등)

### 3.2. 함수

함수에서는 값이 지정되지 않으면 strict mode에 따라 값이 달라진다.

- strict 모드가 아니라면 글로벌 객체가 지정된다.
- strict 모드라면 `undefined`가 된다. (단 몇몇 브라우저에서 글로벌 객체값이 되기도 한다.)

`call(obj)`, `apply(obj)`를 사용하면 `this`는 `obj`가 된다.

- strict 모드가 아니라면 객체가 아닌 타입이 `obj`로 넘어왔을 때 이 값을 객체로 바꿔서 `this`로 지정한다. 예를 들어 `obj`가 `7`이었다면 `new Number(7)`로 변형해서 사용한다.
- strict 모드라면 `obj` 값을 그대로 사용한다. 예를 들어 `obj`가 `7`이었다면 `7`을 그대로 사용한다.

#### `new` 키워드와 함께 생성자로 쓰일 때

함수가 생성자로 쓰이면 (`new` 키워드와 함께 쓰이면) `this`는 생성된 객체를 지정한다.

만약 해당 함수에서 별도의 새로운 객체를 반환하면, 함수 내에서 쓰이던 `this` 객체가 반환되는 게 아니라 새로운 객체가 반환된다.

### 3.3. 클래스

생성자에서 `this`는 일반 객체가 된다. `this.prototype`에는 해당 클래스의 non-static 메서드들이 포함된다.

자식 클래스에서는 `super()` 를 호출해야지만 `this`가 지정된다. `super()` 호출 이전에 `this`를 사용하면 에러가 발생한다. `super()` 호출 없이 `this`를 사용하지 않고 일반 객체를 리턴하는 것은 문제 없다.

#### 클래스 인스턴스 메서드

클래스 인스턴스의 메서드는 일반 함수와 동일하게 동작한다. 따라서 클래스 인스턴스를 `this`로 가리키게 하는 확실한 방법은 생성자에서 `bind(this)`를 사용해주는 것이다.

```javascript
class Person {
  constructor() {
    this.hi = this.thi.bind(this);
  }
  hi() {
    // 생성자에서 `bind(this)`를 해주었기 때문에
    // 이 메서드에서의 `this`는 무조건 클래스 인스턴스 객체를 가리킨다.
  }
  bye() {
    // 이 메서드는 어떻게 사용하느냐에 따라 `this`가 바뀔 수 있다.
  }
}
```

### 3.4. `bind()`

`bind(obj)`로 `this`를 지정하면, 이후에 어떻게 사용하던 `this`는 `obj`로 남게 된다. 이는 `bind(obj2)`를 재사용하거나, `call(obj2)`, `apply(obj2)`를 사용해도 변경되지 않는다.

### 3.5. 화살표 함수

화살표 함수에서는 `this`가 가장 가까운 컨텍스트의 `this`로 자동 지정된다.

화살표 함수의 `this` 지정은 `bind()`와 유사해서, 한 번 지정된 이후로는 어떻게 사용하던 변경되지 않는다.

&gt; ```javascript
&gt; var obj = {
&gt;   bar: function () {
&gt;     var x = () =&gt; this;
&gt;     return x;
&gt;   },
&gt; };
&gt; var fn = obj.bar();
&gt; console.log(fn() === obj); // true
&gt; var fn2 = obj.bar;
&gt; console.log(fn2()() == window); // true
&gt; ```

### 3.6. 객체의 메서드

객체의 메서드일 경우, 해당 함수의 `this`는 해당 객체로 지정된다. 이는 함수를 어디서 선언했는가와 관계 없이 동작한다. 즉 객체의 외부에서 정의된 함수를 객체의 메서드로 할당해서 사용하면 `this`는 해당 객체로 변경된다. (단 `bind(obj)`를 사용한 함수는 예외.) 이는 `prototype` 체인으로 생성된 객체의 메서드일 경우에도 동일하며, `get`, `set` 키워드를 사용해 선언된 메서드의 경우에도 동일하다.

### 3.7. DOM 객체의 이벤트 핸들러

이벤트 핸들러의 `this`는 해당 핸들러가 할당된 엘리먼트가 된다. 이는 인라인 이벤트 핸들러의 경우에도 동일하지만, 인라인 이벤트 핸들러 내부에서 선언된 별도의 함수는 `this`가 지정되지 않은 것으로 인식되어 글로벌 객체를 가리키게 된다.

## 4. 이벤트 루프

이벤트 루프가 함수의 콜스택과 연관지어서 어떻게 동작하는지 설명해달라는 질문이었다. 관련 내용은 MDN의 [Concurrency model and the event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) 문서에서 확인할 수 있다.

---

이벤트 루프는 이름 그대로 이벤트를 처리하는 루프다. 아래의 코드와 유사한 형식으로 구현되어 있다고 한다.

&gt; ```javascript
&gt; while (queue.waitForMessage()) {
&gt;   queue.processNextMessage();
&gt; }
&gt; ```

이벤트 루프는 메시지 큐와 헷갈리기 쉽다. 메시지 큐는 (이벤트를 포함한) 메시지를 쌓는 큐이고, 이벤트 루프는 이 큐의 메시지를 처리하는 루프라고 이해하면 된다.

이 코드는 동기적으로synchronously 동작한다.

&gt; 각각의 메시지(이벤트)는 다른 메시지가 처리되기 전에 완벽하게 처리된다.

비동기적인 코드에 비해 로직을 구현하고 작성하기 편리하지만, 한 편으로는 하나의 메시지 처리가 오래 걸리면 다른 메시지 처리도 할 수 없기 때문에 너무 오래 걸리는 작업은 하지 않는 것이 좋다.

&gt; 이벤트가 발생하고 그 이벤트 처리를 위한 이벤트 리스너가 존재한다면 이것은 이벤트 루프에서 처리된다. 하지만 이벤트 리스너가 없다면, 이벤트는 이벤트 루프로 가지 않고 그냥 사라진다.

`setTimeout` 또한 메시지로 처리된다.

&gt; 만약에 (이벤트 루프에서 사용하는) 큐에 메시지가 하나도 없다면, 그리고 콜스택도 비어있다면, `setTimeout`의 메시지는 딜레이 시간 이후에 바로 실행된다. 하지만 큐에 메시지가 있다면 `setTimeout` 메시지는 해당 메시지의 처리를 기다렸다가 실행된다. 따라서 `setTimeout`의 두번째 인자는 *딜레이될 최소 시간*을 의미한다. *보장된 딜레이 시간*을 의미하지 않는다.

`setTimeout`의 두번째 인자를 0으로 넣어도, 위와 같은 이유로 바로 실행되지 않는다.

&gt; 웹워커나 크로스오리진`iframe`은 자신만의 스택, 힙, 메시지 큐를 갖고 있다. 이 개별적인 런타임 환경은 `postMessage`를 통해 메시지를 주고 받는 방식으로만 대화할 수 있다. 이 메시지 또한 메시지큐에 쌓인다.

## 5. CORS and preflight

CORS가 무엇인지, preflight 요청이 무엇인지에 관해 묻는 질문이었다. 관련 내용은 MDN의 [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) 문서에서 확인할 수 있다.

---

&gt; 크로스오리진 리소스 쉐어링 (CORS)은 서버가 다른 origin의 서버에게 자원을 가져갈 수 있게 허용해주는, HTTP 헤더 기반 메커니즘이다.

CORS는 [동일 출처 정책](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)을 제한적으로 해제할 수 있는 기능이다. 웹앱을 구현할 때 데이터가 있는 백엔드는 다른 서버에 있는 경우가 많은데, 그 경우 CORS 설정은 필수가 된다.

&gt; CORS는 또한 브라우저가 크로스오리진 리소스 요청을 위해 만드는 &quot;preflight&quot; 리퀘스트에도 의존하는데, 이것은 서버가 리스소에 접근하려는 실제 리퀘스트를 허용하는지 체크하기 위한 요청이다.

번역이 좀 어색한데 간단히 말하면 서버에 리퀘스트를 보내기 전에 해당 서버가 CORS를 허용하는지 확인하는 리퀘스트를 브라우저가 자동으로 보낸다는 이야기다.

예를 들어 GET 리퀘스트를 발송하면 브라우저는 **실제로는 같은 URL로 OPTIONS 메서드의 요청을 먼저 날린다**. 그리고 이 요청이 승인을 받으면, 그제서야 원래 하려고 했던 GET 요청을 날리게 된다. 여기서 먼저 발송되었던 OPTIONS 리퀘스트가 바로 preflight 리퀘스트다.
</content:encoded></item><item><title><![CDATA[[팁] 1~n 배열 만들기]]></title><description><![CDATA[JavaScript 로 1 ~ n 까지의 숫자 배열을 만들고 싶어졌다. 쉽게 생각할 수 있는 방법은 새로운 n 크기의 배열을 만든 뒤 map 메서드를 사용해 숫자를 1부터 n까지 채워 넣는 것이다. 하지만 위 코드의 결과는 우리가 예상한 것과 다르게…]]></description><link>https://ricale.kr/blogposts/210416-create-n-length-array</link><guid isPermaLink="false">https://ricale.kr/blogposts/210416-create-n-length-array</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Thu, 15 Apr 2021 15:00:00 GMT</pubDate><content:encoded>
JavaScript 로 1 ~ n 까지의 숫자 배열을 만들고 싶어졌다. 쉽게 생각할 수 있는 방법은 새로운 n 크기의 배열을 만든 뒤 `map` 메서드를 사용해 숫자를 1부터 n까지 채워 넣는 것이다.

```javascript
const nums = new Array(5).map((_, i) =&gt; i + 1);
```

하지만 위 코드의 결과는 우리가 예상한 것과 다르게 나온다.

```javascript
console.log(nums);
// [empty * 5]
```

순차적인 값이 들어가길 기대한 것과 달리, 배열의 모든 값은 여전히 비어있다. 왜일까? 버그일까? 아니다. [MDN의 Array.prototype.map 문서](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#description)를 보면 아래와 같은 내용이 나온다.

&gt; `callback` is invoked only for indexes of the array which have assigned values (including `undefined`).

`map` 메서드는 *값이 할당된 인덱스*에 대해서만 동작한다고 되어 있다. `new Array(n)`으로 생성된 배열은 모든 값이 비어있다. **`undefined`로도 채워져 있지 않다**. 때문에 `map` 메서드가 동작하지 않는 것이다.

그렇다면 해결 방법은? 값을 채워준 뒤 `map` 메서드를 사용하면 된다.

```javascript
const nums = new Array(5).fill(0).map((_, i) =&gt; i + 1);
console.log(nums);
// [1, 2, 3, 4, 5];
```

좀 더 ES6+스러운 코드도 있다.

```javascript
const nums = [...new Array(5)].map((_, i) =&gt; i + 1);
console.log(nums);
// [1, 2, 3, 4, 5];
```

---

### References

- Stack Overflow - [JavaScript “new Array(n)” and “Array.prototype.map” weirdness](https://stackoverflow.com/questions/5501581/javascript-new-arrayn-and-array-prototype-map-weirdness)
- MDN Web Docs - [Array.prototype.map()
  ](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
</content:encoded></item><item><title><![CDATA[크롬에서 Web Worker 로 이미지 업로드 안 되는 현상 해결]]></title><description><![CDATA[1. 발단 3월 초 즈음 크롬이 업데이트된 이후로 우리 웹앱에서 이미지 업로드가 되지 않는 현상이 발생했다. 해당 현상은 크롬 사용자에게만 나타났다. 그냥 자바스크립트 에러가 나면서 기능이 동작하지 않는 정도가 아니다. 아래처럼 아예 크롬이 죽어버린다…]]></description><link>https://ricale.kr/blogposts/210330-chrome-web-worker-issue</link><guid isPermaLink="false">https://ricale.kr/blogposts/210330-chrome-web-worker-issue</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Mon, 29 Mar 2021 15:00:00 GMT</pubDate><content:encoded>
## 1. 발단

3월 초 즈음 크롬이 업데이트된 이후로 우리 웹앱에서 이미지 업로드가 되지 않는 현상이 발생했다. 해당 현상은 크롬 사용자에게만 나타났다. 그냥 자바스크립트 에러가 나면서 기능이 동작하지 않는 정도가 아니다. 아래처럼 아예 크롬이 죽어버린다.

![screenshot](./screenshot.png)

크롬이 죽는 순간 개발자도구도 같이 죽기 때문에, 이 현상의 유일한 단서는 화면에 표시된 `RESULT_CODE_KILLED_BAD_MESSAGE` 뿐이었다. 하지만 해당 메시지를 포함한 여러 가지 조합으로 검색을 시도해봤지만 유의미한 정보를 찾을 수는 없었다.

불행 중 다행인 것은 파이어폭스로는 해당 기능이 문제없이 동작한다는 것이었다. 일단 고객 측에는 임시로 파이어폭스를 사용해달라고 하고, 원인을 찾기로 했다.

## 2. 현황 및 원인

현재 우리의 이미지 업로드 기능은 아래와 같이 구현되어 있다.

1. 사용자가 이미지 업로드를 시도하면 이미지 업로드 Redux Action 이 발송(`dispatch`) 된다.
2. 해당 액션을 듣고 있던 Redux Saga 가 Web Worker 에 이미지 업로드를 요청(`worker.postMessage`)한다.
   - 이미지는 여러 개일 수 있고 고용량일 수도 있기 때문에 메인 스레드에서는 직접 업로드하지 않고 워커 스레드를 사용한다.
3. Web Worker 는 `fetch` 메서드를 사용해 이미지 업로드 리퀘스트를 발송한다.
   - 이미지가 여러 개일 경우 리퀘스트는 이미지 개수만큼 발송된다.
4. 이미지 업로드가 성공/실패할 때마다 메인 스레드에 결과를 알린다 (`self.postMessage`).

크롬이 죽는 시점은 `fetch` 메서드가 실행되는 순간이다 (위에서는 3번 시점). 리퀘스트는 발송되지 않고 `fetch` 가 호출되는 그 순간 바로 죽어버린다.

테스트를 위해 워커에서 다른 리퀘스트들도 요청해봤는데 다른 리퀘스트들은 정상적으로 동작했다. 오로지 `body` 에 파일이 실려있을 때만 크롬이 죽었다.

왜 파일 업로드 요청에서만 죽는가? 라는 것은 알아내지 못했다. 혹시 우리가 Web Worker 혹은 `fetch` 메서드의 중요한 무언가를 놓친 게 아닐까 싶다가도, 크롬 업데이트 전에는 문제없었으며 현재도 파이어폭스 및 사파리에서는 멀쩡히 동작하기 때문에 그건 아닌 것 같았다.

그리고 설령 우리가 놓친 게 뭔가 있다고 할지라도 꽤 오랜 시간을 검색에 투자했음에도 이렇다 할 글을 찾지 못한 걸로 봐서는 쉽게 찾아질 녀석은 아닌 게 분명했다.

따라서 우리는 일단 근본적인 원인을 찾는 것은 멈추고 **&apos;Web Worker 에서 `fetch` 메서드로 파일 업로드 시도&apos;**를 원인으로 하여 해결책을 찾기로 했다.

## 3. 수정

원인을 찾았으니 해결 방법은 명확하다. `fetch` 메서드를 쓰지 않으면 된다. 대신 `XMLHttpRequest` 를 쓰자. `fetch` 메서드의 문제가 맞다면 이것만으로도 충분히 버그는 제거될 것이다.

### 3.1. `fetch` 를 사용한 기존 코드

```javascript
// UI로부터 받아온 해시 형식의 데이터를 FormData 로 변환하는 메서드
function getFormData(body) {
  const formData = new FormData();
  Object.keys(body).forEach((key) =&gt; {
    if (body[key] instanceof FileList) {
      for (let i = 0; i &lt; body[key].length; i++) {
        formData.append(key, body[key][i]);
      }
    } else {
      formData.append(key, body[key]);
    }
  });
  return formData;
}

// 리퀘스트 발송 메서드
async function uploadImages(method, url, data) {
  return await fetch(URL, {
    method: &quot;POST&quot;,
    mode: &quot;cors&quot;,
    headers: {
      Authorization: &quot;JWT TOKEN&quot;,
    },
    body: getFormData(data),
  });
}

await uploadImages(/* ... */);
```

### 3.2. `XMLHttpRequest` 를 활용해 수정한 코드

```javascript
// `XMLHttpRequest`를 사용한 코드

// async/await 문법을 사용하기 위해 Promise 활용
async function uploadImagesUsingXhr(method, url, token, data) {
  return new Promise((resolve, reject) =&gt; {
    const xhr = new XMLHttpRequest();
    xhr.open(method, url, true);
    xhr.setRequestHeader(&quot;Authorization&quot;, &quot;JWT TOKEN&quot;);
    xhr.onreadystatechange = function () {
      if (this.readyState === 4) {
        resolve(JSON.parse(xhr.response));
      }
    };
    xhr.onerror = function onerror(e) {
      reject(e);
    };

    xhr.send(getFormData(data));
  });
}

await uploadImagesUsingXhr(/* ... */);
```

## 4. 결과

다행히도 `XMLHttpRequest` 를 활용해 수정하자 크롬에서도 문제없이 동작하게 되었다. 일단은 한숨 돌릴 수 있게 되었다.
</content:encoded></item><item><title><![CDATA[ESLint 적용 및 자동화]]></title><description><![CDATA[코드를 일관성 있는 형식으로 유지하는 것은 중요하다. 일관성 있는 코드는 가독성을 올려주며, 이는 협업 및 유지보수에 큰 도움을 준다. 코드를 일관성있게 유지하는 방법은 많이 있겠지만, (React Native 환경에서) 가장 쉽게 적용할 수 있는…]]></description><link>https://ricale.kr/blogposts/210325-apply-eslint</link><guid isPermaLink="false">https://ricale.kr/blogposts/210325-apply-eslint</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Wed, 24 Mar 2021 15:00:00 GMT</pubDate><content:encoded>
[eslint]: https://eslint.org/
[react-native-community]: https://github.com/react-native-community
[react-native-community-eslint-config]: https://www.npmjs.com/package/@react-native-community/eslint-config
[eslint-plugin-prettier]: https://www.npmjs.com/package/eslint-plugin-prettier
[eslint-docs]: https://eslint.org/docs/user-guide/configuring/
[git]: https://git-scm.com/
[git-hooks]: https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks
[pre-commit-gist]: https://gist.github.com/ricale/a386ae04faff3ba26f3f44c0bbcfcbe3
[pre-commit-gist-origin]: https://gist.github.com/broofa/730fab6ceb1686f4a1fa9977b791b1b5
[prettier]: https://prettier.io/

코드를 일관성 있는 형식으로 유지하는 것은 중요하다. 일관성 있는 코드는 가독성을 올려주며, 이는 협업 및 유지보수에 큰 도움을 준다.

코드를 일관성있게 유지하는 방법은 많이 있겠지만, (React Native 환경에서) 가장 쉽게 적용할 수 있는 방법 중 하나가 ESLint 적용이라고 생각한다. [ESLint][eslint] 는 설정된 규칙에 어긋나는 코드를 리포팅해주는 도구이다. 설치 및 설정이 간단하기 때문에 누구나 쉽게 사용할 수 있다.

## 1. 설치

```bash
$ yarn add --dev eslint
```

위 명령어를 통해 설치할 수 있다.

ESLint 는 설치한 뒤, 설정 파일을 작성해야 한다. 방법은 두 가지가 있다. 하나는 ESLint 에서 제공하는 명령어를 통해 자동 생성하는 것이고, 다른 하나는 프리셋을 사용하는 것이다. (물론 직접 작성하는 방법도 있지만 이 글에서는 다루지 않는다.)

### 1.1. `eslint --init`

```bash
$ ./node_modules/.bin/eslint --init
```

위 명령어를 입력하면 아래처럼 터미널에 몇 가지 문항이 뜨는데 자신에게 알맞는 답을 선택하면 자동으로 설정 파일을 생성해주고 필요한 디펜던시까지 설치해준다.

```
✔ How would you like to use ESLint?
✔ What type of modules does your project use?
✔ Which framework does your project use?
✔ Does your project use TypeScript?
✔ Where does your code run?
✔ What format do you want your config file to be in?
The config that you&apos;ve selected requires the following dependencies:

eslint-plugin-react@latest @typescript-eslint/eslint-plugin@latest @typescript-eslint/parser@latest
✔ Would you like to install them now with npm?
Installing eslint-plugin-react@latest, @typescript-eslint/eslint-plugin@latest, @typescript-eslint/parser@latest
```

### 1.2. react-native-community 의 프리셋 사용

또다른 방법은 [React Native Community][react-native-community] 에서 제공하는 설정 [프리셋][react-native-community-eslint-config]을 사용하는 것이다. 해당 프리셋은 아래 명령어로 설치할 수 있다.

```
$ yarn add --dev @react-native-community/eslint-config
```

이 프리셋에는 TypeScript 관련 설정이 포함되어 있다.

라이브러리가 설치되면 설정 파일을 작성해주어야 한다.

```js
// {ROOT}/.eslintrc.js
module.exports = {
  root: true,
  extends: [&quot;@react-native-community&quot;],
};
```

[@react-native-community/eslint-config][react-native-community-eslint-config] 패키지에 설정이 미리 되어 있으므로, 이 이상 더 해 줄 것은 없다.

#### 1.2.1. 프리셋 설정 수정

React Native Community 의 프리셋이 일부 마음에 들지 않을 수 있다. 그렇다면 설정 파일을 수정하면 된다.

마음에 들지 않을 수 있는 대표적은 설정으로는 [prettier][eslint-plugin-prettier] 설정이 있다. React Native Community 의 프리셋에는 prettier 옵션이 설정되어 있고, 이 옵션에 의한 코드 스타일은 개발자의 호불호가 크게 갈릴 수 있다. 만약 해당 설정을 끄고 싶다면 아래처럼 설정 파일을 수정하면 된다.

```js
// {ROOT}/.eslintrc.js
module.exports = {
  root: true,
  extends: [
    &quot;@react-native-community&quot;,

    // eslint-config-prettier 는
    // @react-native-community/eslint-config 의 디펜던시에
    // 포함된 패키지이므로, 추가로 설치해 줄 필요는 없다.
    &quot;eslint-config-prettier&quot;,
  ],
  rules: {
    // prettier 설정을 끈다.
    &quot;prettier/prettier&quot;: 0,
  },
};
```

단 위처럼 prettier를 꺼버리면 `comma-dangle`, `quotes` 등 prettier 를 통해 적용되고 있던 일부 lint 옵션들이 꺼질 수 있다. 그러면 `rules` 필드에 원하는 룰을 추가해주면 된다.

```js
// {ROOT}/.eslintrc.js
module.exports = {
  // ...
  rules: {
    // ...
    &quot;comma-dangle&quot;: [&quot;error&quot;, &quot;always-multiline&quot;],
    quotes: [&quot;error&quot;, &quot;single&quot;],
    semi: [&quot;error&quot;, &quot;always&quot;],
  },
};
```

설정에 관한 자세한 내용은 [공식 문서][eslint-docs]를 참고하자.

## 2. 자동화

ESLint 를 적용했지만, 이 툴은 설치한 것만으로 자동으로 코드를 검사를 해주지 않는다. `eslint` 명령어를 실행해야지만 코드를 검사해준다. 하지만 명령어를 일일이 쳐주는 것은 번거로울 뿐더러 까먹기도 쉽다. 까먹고 커밋하고 푸시하면 결국 설치한 것이 의미가 없어진다. 까먹지 않는 가장 좋은 방법은 툴이 자동으로 알아서 실행되게끔 자동화를 해주는 것이다.

자동화 방법에는 여러가지가 있을 수 있겠지만, 여기서는 [git][git] 의 [pre-commit 훅][git-hooks]을 사용한다.

### 2.1. pre-commit

pre-commit 훅은 커밋 직전에 실행되는 스크립트다. 스크립트 결과에 따라 커밋을 막을 수도 있다. 즉 우리는 pre-commit 으로 `eslint` 명령어를 실행하고, 룰셋에 맞지 않는 코드가 있으면 커밋을 하지 못하게 할 것이다.

pre-commit 훅은 `.git/hooks/pre-commit` 파일에 작성하면 된다. 아래는 간략화한 pre-commit 코드다.

```bash
# eslint 가 설치되어 있는지 확인하고 설치되어있지 않다면 커밋을 막는다.
ESLINT=&quot;node_modules/.bin/eslint&quot;
if [[ ! -x &quot;$ESLINT&quot; ]]; then
  printf &quot;Please install ESlint\n&quot;
  exit 1
fi

# staged 된 파일들에 대해서만 eslint --fix 명령어를 실행한다.
STAGED_FILES=($(git diff --cached --name-only --diff-filter=ACM | grep &quot;.[jt]sx\{0,1\}$&quot;))
$ESLINT &quot;${STAGED_FILES[@]}&quot; --fix
ESLINT_EXIT=&quot;$?&quot;

# eslint --fix 결과에 따라 커밋을 진행한다.
if [[ &quot;${ESLINT_EXIT}&quot; == 0 ]]; then
  printf &quot;COMMIT SUCCEEDED&quot;
else
  printf &quot;COMMIT FAILED&quot;
  exit 1
fi
exit $?
```

([스크립트 원문][pre-commit-gist])

## 3. 결과

이제 코드를 커밋할 때마다 git 스테이지에 포함된 파일에 대해 자동으로 eslint 명령어가 실행될 것이다. 작업 다 끝났다고 생각했는데 pre-commit 에 의해 커밋이 막히면 기분이 나쁠 수도 있지만, 장기적으로 봤을 때 작업의 효율성이 개선될 것이다.

## 4. 개선점?

ESLint 는 기본적으로 일관된 코드를 강제하는 것에 초점을 두기 보다는 나쁜 코드를 막는 것에 초점을 둔다. 규칙에 맞지 않는 코드를 찾아주지만 그것을 자동으로 고쳐주지는 않고 (`--fix` 옵션을 통해 몇몇 옵션들은 코드를 자동으로 고쳐주기도 하지만 모든 옵션이 다 그렇지는 않다), 규칙 자체도 상황에 따라서는 느슨하다고 느낄 수 있다.

그렇다면 일관된 코드를 강제하기 위한 대안은 어떤 게 있을까?

[Prettier][prettier] 라이브러리를 사용하는 방법이 있다. Prettier 는 말 그대로 일관된 코드를 강제하는, 일관되지 않은 부분을 강제로 고쳐주는 툴이다. (**1.2.1. 프리셋 설정 수정** 에서 비활성화했던 prettier 옵션이 이 [Prettier 라이브러리의 ESLint 플러그인 버전][eslint-plugin-prettier]이다.) 다만 이 툴은 강제성이 크기 때문에 사용자에 따라 호불호가 갈릴 수 있다. 사용해보고 더 맞는 쪽을 선택하는 것이 좋을 것 같다.

---

## References

- [GitHub Gist - broofa/pre-commit][pre-commit-gist-origin]
- [facebook/react-native - Remove prettier from eslint-config-react-native-community](https://github.com/facebook/react-native/issues/26903)
</content:encoded></item><item><title><![CDATA[sqlite3 데이터 타입]]></title><description><![CDATA[아래 내용은 sqlite 의 공식 문서인 Datatypes In SQLite Version 3를 간단히 인용 및 정리한 것이다. 정확한 내용은 본문보다는 해당 문서 참고를 권장한다. 1. Datatypes In SQLite

In SQLite…]]></description><link>https://ricale.kr/blogposts/210320-sqlite3-data-types</link><guid isPermaLink="false">https://ricale.kr/blogposts/210320-sqlite3-data-types</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Fri, 19 Mar 2021 15:00:00 GMT</pubDate><content:encoded>
[cast-to-numeric]: https://www.sqlite.org/lang_expr.html#castexpr

아래 내용은 sqlite 의 공식 문서인 [Datatypes In SQLite Version 3](https://www.sqlite.org/datatype3.html)를 간단히 인용 및 정리한 것이다. 정확한 내용은 본문보다는 해당 문서 참고를 권장한다.

---

## 1. Datatypes In SQLite

&gt; In SQLite, the datatype of a value is associated with the value itself, not with its container.

sqlite는 SQL이지만 데이터 타입은 동적 타입을 사용한다.

## 2. Storage Classes and Datatypes

Storage class 는 다섯 가지가 있다.

- NULL
- INTEGER. signed 1,2,3,4,5,6,8 byte number.
- REAL: floating point value. 8 byte.
- TEXT
- BLOB: blob of data

&gt; A storage class is more general than a datatype. (...) And so for the most part, &quot;storage class&quot; is indistinguishable from &quot;datatype&quot; and the two terms can be used interchangeably.

Storage class 는 데이터 타입보다 더 일반적인 개념이다. (...) 대부분의 경우, storage class 와 데이터 타입은 구분할 수 없다. 두 용어는 혼용될수 있다.

&gt; Any column in an SQLite version 3 database, except an INTEGER PRIMARY KEY column, may be used to store a value of any storage class.

INTEGER PRIMARY KEY 컬럼을 제외한 모든 컬럼은, 어떤 storage class 의 값이라도 저장할 수 있다.

### 2.1. Boolean Datatype

&gt; Boolean values are stored as integers 0 (false) and 1 (true).

### 2.2. Date and Time Datatype

&gt; SQLite does not have a storage class set aside for storing dates and/or times. Instead, the [built-in Date And Time Functions](https://www.sqlite.org/lang_datefunc.html) of SQLite are capable of storing dates and times as TEXT, REAL, or INTEGER values

일시(날짜 및 시간)을 위한 storage class 는 따로 없고, 해당 값을 TEXT, REAL, INTEGER 로 저장할 수 있게 도와주는 함수들이 존재한다.

## 3. Type Affinity

&gt; The type affinity of a column is the recommended type for data stored in that column. The important idea here is that the type is recommended, not required.

Type affinity 는 특정 컬럼에 저장하도록 **권장**하는 데이터 타입을 말한다.

아래와 같은 다섯 가지 Type affinity 가 존재함

- TEXT: 숫자 타입(INTEGER, REAL)은 TEXT 로 변환되어 저장된다. 나머지 storage class 는 그대로 저장된다.
- NUMERIC: 문자열은 가능하면 REAL 혹은 INTEGER 로 변환되어 저장되고, 가능하지 않다면 TEXT 로 저장된다. 숫자도 (실수라고 해도) INTEGER 로 변환 가능하다면 (변환해도 잃는 값이 없다면) 변환된다. 나머지 storage class 는 그대로 저장된다.
- INTEGER: [CAST expression](https://www.sqlite.org/lang_expr.html#castexpr) 을 제외하고 NUMERIC 과 동일하다.
- REAL: INTERGER 를 REAL 로 변환하여 저장함. 나머지는 NUMERIC 과 동일하다.
- BLOB: 별다른 타입 변환 없이 그대로 저장된다.

### 3.1. Determination Of Column Affinity

&gt; 1. If the declared type contains the string &quot;INT&quot; then it is assigned INTEGER affinity.
&gt; 2. If the declared type of the column contains any of the strings &quot;CHAR&quot;, &quot;CLOB&quot;, or &quot;TEXT&quot; then that column has TEXT affinity. Notice that the type VARCHAR contains the string &quot;CHAR&quot; and is thus assigned TEXT affinity.
&gt; 3. If the declared type for a column contains the string &quot;BLOB&quot; or if no type is specified then the column has affinity BLOB.
&gt; 4. If the declared type for a column contains any of the strings &quot;REAL&quot;, &quot;FLOA&quot;, or &quot;DOUB&quot; then the column has REAL affinity.
&gt; 5. Otherwise, the affinity is NUMERIC.

CREATE TABLE 문 등으로 컬럼의 타입 선언 시

1. 컬럼의 선언된 타입 이름에 &quot;INT&quot; 가 들어가면 INTEGER affinity
2. 선언된 타입 이름에 &quot;CHAR&quot;, &quot;CLOB&quot;, &quot;TEXT&quot;가 들어가면 TEXT affinity
3. 이름에 &quot;BLOB&quot;가 들어가거나 타입이 지정되지 않으면 BLOB affinity
4. 이름에 &quot;REAL&quot;, &quot;FLOA&quot;, &quot;DOUB&quot;가 들어가면 REAL affinity
5. 위 조건에 모두 걸리지 않으면, NUMERIC affinity

가 지정된다.

#### 3.1.1. Affinity Name Examples

해당 문서의 해당 항목 참고

### 3.2. Affinity Of Expression

&gt; Every table column has a type affinity (one of BLOB, TEXT, INTEGER, REAL, or NUMERIC) but expressions do not necessarily have an affinity.

모든 테이블 컬럼은 type affinity 를 갖지만, 표현식(Expression)은 type affinity 가 필수적이지 않다.

&gt; - The right-hand operand of an IN or NOT IN operator has no affinity if the operand is a list and has the same affinity as the affinity of the result set expression if the operand is a SELECT.

IN/NOT IN 문의 오른쪽 피연산자는 리스트면서 피연산자가 SELECT 인 결과 표현식의 affinity 와 같은 affinity 를 갖는다면 affinity 가 없다. &lt;span style={{color: &quot;darkgray&quot;}}&gt;(무슨 말인지 모르겠다..)&lt;/span&gt;

&gt; - When an expression is a simple reference to a column of a real table (not a VIEW or subquery) then the expression has the same affinity as the table column.
&gt;   - Parentheses around the column name are ignored.
&gt;   - Any operators applied to column names, including the no-op unary &quot;+&quot; operator, convert the column name into an expression which always has no affinity.

표현식이 테이블의 컬럼에 대한 레퍼런스라면, affinity 는 해당 컬럼과 동일하다.

- affinity 판단 시 괄호는 무시된다.
- 연산자를 사용했다면, 해당 표현식은 무조건 affinity 가 없다.

&gt; An expression of the form &quot;CAST(expr AS type)&quot; has an affinity that is the same as a column with a declared type of &quot;type&quot;.

&quot;CAST(expr AS type)&quot; 형식의 표현식은 &quot;type&quot; affinity 를 갖는다.

&gt; A COLLATE operator has the same affinity as its left-hand side operand.

COLLATE 연산자는 왼쪽 피연산자와 같은 affinity 를 갖는다.

&gt; Otherwise, an expression has no affinity.

여기까지 해당사항이 없으면, 해당 표현식에 affinity 는 없다.

### 3.3. Column Affinity For Views And Subqueries

&lt;span style={{ color: &quot;darkgray&quot; }}&gt;
  (뷰와 서브쿼리는 사용해 본 적이 거의 없으므로, 이 문단은 생략.)
&lt;/span&gt;

### 3.4. Column Affinity Behavior Example

해당 문서의 해당 항목 참고

## 4. Comparison Expressions

&gt; &quot;=&quot;, &quot;==&quot;, &quot;\&lt;&quot;, &quot;\&lt;=&quot;, &quot;&gt;&quot;, &quot;&gt;=&quot;, &quot;!=&quot;, &quot;&quot;, &quot;IN&quot;, &quot;NOT IN&quot;, &quot;BETWEEN&quot;, &quot;IS&quot;, and &quot;IS NOT&quot;

### 4.1. Sort Order

정렬 시 순서는 아래처럼 적용된다.

- NULL &lt; not NULL
- INTEGER/REAL &lt; TEXT &lt; BLOB
- BLOB 끼리의 비교에는 memcmp() 사용

### 4.2. Type Conversion Prior To Comparison

&gt; - If one operand has INTEGER, REAL or NUMERIC affinity and the other operand has TEXT or BLOB or no affinity then NUMERIC affinity is applied to other operand.
&gt; - If one operand has TEXT affinity and the other has no affinity, then TEXT affinity is applied to the other operand.
&gt; - Otherwise, no affinity is applied and both operands are compared as is.

- 피연산자 하나가 INTEGER/REAL/NUMERIC 이고 다른 피연산자가 TEXT/BLOB/affinity없음 이면, 숫자 유형이 다른 피연산자 유형으로 변환된다.
- 피연산자 하나가 TEXT 이고 다른 피연산자의 affinity 가 없으면 TEXT 가 다른 피연산자 유형으로 적용된다. &lt;span style={{ color: &quot;darkgray&quot; }}&gt;(?? affinity 가 없는 걸로 적용된다고? 3.1. 항목을 보면 affinity 가 없는 경우는 없는 것 같은데, BLOB 를 말하는 건가?)&lt;/span&gt;
- 그렇지 않으면, 두 피연산자는 affinity 변환 없이 있는 그대로 비교된다.

### 4.3. Comparison Example

해당 문서의 해당 항목 참고

&lt;span style={{ color: &quot;darkgray&quot; }}&gt;(예시에 있는 CREATE 문을 보면&lt;/span&gt;

```sql
CREATE TABLE t1(
    a TEXT,      -- text affinity
    b NUMERIC,   -- numeric affinity
    c BLOB,      -- no affinity
    d            -- no affinity
);
```

&lt;span style={{ color: &quot;darkgray&quot; }}&gt;
  c 는 BLOB 로 지정하고 d 는 지정하지 않았는데, 주석으로 no affinity 라고
  되어있다. 3.1. 항목에 나온대로라면 BLOB affinity 가 적용되어야 하는 것 아닌가?
  의문.)
&lt;/span&gt;

## 5. Operators

&gt; +, -, \*, /, %, \&lt;\&lt;, &gt;&gt;, &amp;, and |

&gt; The implied type conversion of mathematical operands is slightly different from [CAST to NUMERIC][cast-to-numeric] in that string and BLOB values that look like real numbers but have no fractional part are kept as REAL instead of being converted into INTEGER as they would be for [CAST to NUMERIC][cast-to-numeric].

수학적 피연산자의 암시적 타입 변환은 [CAST to NUMERIC][cast-to-numeric] 문서에 나온 것과는 약간 다르다. 문자열이나 BLOB 값이 REAL 형식이면서 소숫점 아래 값이 없을 경우, INTEGER 로 자동 변환하는 것이 아니라 REAL 로 유지한다.

&gt; The conversion from STRING or BLOB into REAL or INTEGER is performed even if it is lossy and irreversible.

수학적 피연산자로 사용된 문자열이나 BLOB 값은 무조건 REAL/INTEGER 로 변환된다. 심지어는 변환으로 인해 값의 손실이 생기더라도.

&gt; Some mathematical operators (%, \&lt;\&lt;, &gt;&gt;, &amp;, and |) expect INTEGER operands. For those operators, REAL operands are converted into INTEGER in the same way as a CAST to INTEGER.

어떤 연산자들은 피연산자로 INTEGER 값만을 사용한다. 이런 연산자들은 만약 REAL 이 피연산자로 사용되면, 값의 손실이 생기더라도 이 값을 INTEGER 로 변환한다.

## 6. Sorting, Grouping and Compound SELECTs

&gt; When query results are sorted by an ORDER BY clause, values with storage class NULL come first, followed by INTEGER and REAL values interspersed in numeric order, followed by TEXT values in collating sequence order, and finally BLOB values in memcmp() order.

쿼리 결과가 ORDER BY 문으로 정렬될 경우, 아래 순서대로 값이 나온다.

1. NULL 값이 먼저 나옴. 그 뒤를 따라서
2. INTEGER/REAL 값들이 숫자 순서에 따라 정렬됨. 그 뒤를 따라서
3. TEXT 값들이 collaing sequence 순서에 따라 정렬됨. 그 뒤를 따라서
4. BLOB 값이 memcmp() 순서에 따라 정렬됨

&gt; When grouping values with the GROUP BY clause values with different storage classes are considered distinct, except for INTEGER and REAL values which are considered equal if they are numerically equal.

쿼리 결과를 GROUP BY 절에 의해 묶을 경우, storage class 가 다른 값은 별개의 값으로 판단된다. 단, INTEGER/REAL 의 경우 같은 숫자값이라면 같은 값으로 판단된다.

&gt; The compound SELECT operators UNION, INTERSECT and EXCEPT perform implicit comparisons between values. No affinity is applied to comparison operands for the implicit comparisons associated with UNION, INTERSECT, or EXCEPT - the values are compared as is.

UNION, INTERSEC, EXCEPT 문을 사용할 때 각 값 간에 암시적 비교가 실시된다. 이 때 변환은 일어나지 않고 값들은 있는 그대로 비교된다.

## 7. Collating Sequences

&gt; When SQLite compares two strings, it uses a collating sequence or collating function (two words for the same thing) to determine which string is greater or if the two strings are equal. SQLite has three built-in collating functions: BINARY, NOCASE, and RTRIM.

두 문자열을 비교할 때, collating sequence 혹은 collating function 을 사용한다. sqlite 는 세 개의 내장 collating function 을 제공한다.

- BINARY: 문자열 비교에 memcmp() 사용
- NOCASE: 문자열 비교에 [sqlite3_strnicmp()](https://www.sqlite.org/c3ref/stricmp.html) 사용
- RTRIM: BINARY 와 동일하나 앞뒤 공백 문자는 제거한 뒤 비교

### 7.1. Assigning Collating Sequences from SQL

&gt; 1. If either operand has an explicit collating function assignment using the postfix COLLATE operator, then the explicit collating function is used for comparison, with precedence to the collating function of the left operand.

만약 두 피연산자가 COLLATE 문을 사용해 collating function 이 지정되어 있다면, 두 값의 비교를 위해 이 명시적 collating function 이 사용된다. 왼쪽 피연산자의 collating function 가 우선권을 가진다.

&gt; 2. If either operand is a column, then the collating function of that column is used with precedence to the left operand. For the purposes of the previous sentence, a column name preceded by one or more unary &quot;+&quot; operators and/or CAST operators is still considered a column name.

&lt;span style={{ color: &quot;darkgray&quot; }}&gt;(무슨 말인지 잘 모르겠다..)&lt;/span&gt;

&gt; 3. Otherwise, the BINARY collating function is used for comparison.

그렇지 않으면 BINARY collating function 이 사용된다.

### 7.2. Collating Sequence Example

해당 문서의 해당 항목 참고
</content:encoded></item><item><title><![CDATA[빌드할 때마다 환경 변수 파일을 자동으로 갱신]]></title><description><![CDATA[사고가 발생했다. 어제 배포한 앱에서 발생한 사고였다. 구글 로그인 기능이 동작하지 않았다. 확인해보니 구글 로그인 라이브러리 초기화 시 사용하는 토큰 값이 잘못되어 있었다. 해당 값은 환경 변수에 넣어서 관리하고 있었는데, 빌드한 사람(본인)의 환경…]]></description><link>https://ricale.kr/blogposts/210304-auto-update-env-variable-files</link><guid isPermaLink="false">https://ricale.kr/blogposts/210304-auto-update-env-variable-files</guid><dc:creator><![CDATA[ricale]]></dc:creator><pubDate>Wed, 03 Mar 2021 15:00:00 GMT</pubDate><content:encoded>
사고가 발생했다.

어제 배포한 앱에서 발생한 사고였다. 구글 로그인 기능이 동작하지 않았다. 확인해보니 구글 로그인 라이브러리 초기화 시 사용하는 토큰 값이 잘못되어 있었다. 해당 값은 환경 변수에 넣어서 관리하고 있었는데, 빌드한 사람(본인)의 환경 변수 최신화가 제대로 이뤄지지 않았던 것이다. 개발/테스트 환경에서는 해당 값이 문제가 없었기 때문에, 프로덕션 레벨까지 배포되고 나서야 문제를 인지할 수 있었다.

부랴부랴 환경 변수를 최신화해서 앱을 재배포했다. 불행 중 다행으로 아직 사용자가 많지 않은 제품이었기에, 큰 사고로 이어지지는 않았다. 하지만 사고는 사고다. 5인 미만의 작은 팀이라 별다른 도구 없이도 잘 관리할 거라 생각했던 안일함이 사고를 불러왔다. 그리고 이대로라면 앞으로 같은 일이 반복되지 말란 법도 없었다.

그래서 우리는 이 사고의 원인을 근본적으로 해결할 방법을 찾기로 했다.

## 현황

우리 앱은 [React Native](https://github.com/facebook/react-native)로 구현되었다. 환경변수 사용에는 [react-native-config](https://github.com/luggit/react-native-config) 라이브러리를 사용한다.

앱은 안드로이드로만 배포된다. 추후에 iOS에도 앱을 출시할 생각이지만, 당장은 몇몇 사정 때문에 출시하지 않고 있다. (따라서 해결책을 찾을 때는 안드로이드 빌드만 고려할 생각이다. iOS에 대해서는 미래의 자신에게 맡기기로 했다.)

환경 변수(Environment Variables)에는 보통 각 환경마다 다르게 적용되는 상수 값들이 들어 있다. 프로젝트의 성격에 따라 다르겠지만 그 값들에는 DB 접속 정보, 서드 파티 접속 정보 같이 보안상 민감한 정보들도 포함하고 있다. 따라서 환경 변수를 관리하는 파일을 코드 저장소에서 제외하도록 권장되고 있다. (보다 자세한 정보는 [The Twelve-Factor App](https://12factor.net/ko/) 의 [3번 항목](https://12factor.net/ko/config)을 참고)

권장된 내용처럼 우리도 환경변수 파일들을 모두 코드 저장소에서 제외했다. 그리고 값이 변경될 경우 (인원이 많지 않다 보니) slack 등의 메신저를 통해 값을 주고 받아 각자 최신화를 해왔다.

팀원들 모두 이것이 문제라고 인지하고는 있었지만, 당장은 고치지 않아도 된다고 생각하고 있었다.

## 어떻게 해결해야 할까?

첫번째 방법으로는 툴을 쓰는 것이다. [Vault][vault]가 가장 널리 쓰이는 툴인 듯 하다. [EnvKey][envkey], [Envault][envault] 등의 대체제들도 눈에 띈다.

하지만 일단 툴은 사용하지 않는다. 급박하게 돌아가고 있는 현재 스프린트에 최대한 지장을 주지 않는 선에서 빠르게 적용해야 하기 때문이다. 더군다나 보안과 관련된 툴을 급하게 적용하고 싶지는 않다.

두번째 방법은 비공개 코드 저장소를 활용하는 것이다. 이미 익숙한 툴이고, 쉘스크립트를 통해 자동화하기도 쉽다.

### 비공개 코드 저장소

[github](https://github.com/)을 사용했다. 프로젝트의 루트 디렉토리에 환경변수 파일을 모두 저장했다.

```
.
+-- .env
+-- .env.dev
+-- .env.staging
+-- .env.production
```

### 쉘스크립트

빌드 전에 환경 변수 파일들을 다운로드 받는다. 정확히는 위에서 만든 코드 저장소에서 clone 혹은 pull 로 코드를 받아온다.

```bash
# $1에는 dev/staging/production 등 환경 이름이 들어간다.
ENVFILE_PATH=&quot;./env/.env.$1&quot;
if [ -f &quot;$ENVFILE_PATH&quot; ]; then
  # 파일이 존재하면 코드 저장소로부터 파일을 업데이트한다.
  cd env &amp;&amp; git checkout master &amp;&amp; git pull origin master &amp;&amp; cd ../
else
  # 파일이 존재하지 않으면 코드 저장소로부터 파일을 다운로드 받는다.
  git clone https://github.com/OWNER/PROJECT.git ./env
fi
```

(당연하지만 `ENVFILE_PATH`로 사용된 경로 및 파일은 `.gitignore`에 포함되어 있어야 한다.)

그다음에는 안드로이드 빌드 명령어를 실행한다.

```bash
# $2에는 assembleReleasedev 등 안드로이드 빌드 시 쓰이는 빌드 타입이 들어간다.
cd ./android &amp;&amp; ENVFILE=env/.env.$1 ./gradlew $2 &amp;&amp; cd ../
```

보너스로 빌드가 완료되면 자동으로 폴더를 열어주자.

```bash
BUILD_DIR=&quot;$(echo ${2:8} | tr &apos;[A-Z]&apos; &apos;[a-z]&apos;)&quot;
open ./android/app/build/outputs/apk/$BUILD_DIR
```

마지막으로 작성이 완료된 쉘스크립트를 `package.json` 에 등록하면 된다.

```javascript
// package.json
{
  // ...
  &quot;scripts&quot;: {
    // ...
    &quot;build-android-dev&quot;: &quot;bash scripts/build-android.sh dev assembleReleasedev&quot;,
    &quot;build-android-staging&quot;: &quot;bash scripts/build-android.sh staging assembleReleasedev&quot;,
    // ...
  }
}
```

이제 빌드 시 위에 등록해둔 명령어를 사용하기만 하면, 환경 변수 파일은 빌드 전에 항상 자동으로 최신화 될 것이다.

```
$ yarn build-android-dev
```

## 개선할 점

보안 상으로 문제가 있을까봐 앱 코드 저장소에서 제외시킨 환경변수 파일들을 **같은 계정이 관리하는 다른 코드 저장소**로 옮겼다. 결국 해당 계정이 뚫리면 환경변수 파일도 같이 뚫리는 거잖아? 라는 생각을 하지 않을 수 없다. 같은 코드 저장소에 있는 것보다야 당연히 낫겠지만, 하나마나한 짓을 한게 아닌가 하는 생각이 들기도 한다.

다음에는 관련 툴(특히 [Vault][vault])에 대해 자세히 알아봐야 할 것 같다.

## 참고 자료

- [reddit.com - Question: How does your team manage environment variables?](https://www.reddit.com/r/ruby/comments/7fau96/question_how_does_your_team_manage_environment/)
- [dev.to - How do you keep your environment variable synchronized among your development team.](https://dev.to/espoir/how-do-you-keep-your-environment-variable-synchronized-among-your-development-team-175a)
- [reddit.com - Managing env variables for a small dev team](https://www.reddit.com/r/devops/comments/c7u29k/managing_env_variables_for_a_small_dev_team/)
- [Vault][vault]
- [EnvKey][envkey]
- [Envault][envault]

[vault]: https://www.vaultproject.io/
[envkey]: https://www.envkey.com/
[envault]: https://envault.dev/
</content:encoded></item></channel></rss>