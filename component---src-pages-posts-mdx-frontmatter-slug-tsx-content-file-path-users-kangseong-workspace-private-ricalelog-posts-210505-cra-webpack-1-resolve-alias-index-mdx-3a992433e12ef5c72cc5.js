"use strict";(self.webpackChunkricalelog=self.webpackChunkricalelog||[]).push([[364],{9198:function(e,n,l){l.r(n),l.d(n,{Head:function(){return f},default:function(){return v}});var t=l(1151),a=l(7294);function c(e){const n=Object.assign({h2:"h2",p:"p",code:"code",a:"a",blockquote:"blockquote",pre:"pre",h3:"h3",h4:"h4",h5:"h5",ul:"ul",li:"li"},(0,t.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(n.h2,null,"1. 서문"),"\n",a.createElement(n.p,null,"create-react-app(이하 CRA) 으로 React 웹앱을 만들었다. typescript도 쓰고 싶어서 만들 때 ",a.createElement(n.code,null,"--template typescript")," 옵션도 주었다. webpack 설정을 직접 수정하고 싶어서 ",a.createElement(n.code,null,"yarn eject")," 커맨드도 실행했다."),"\n",a.createElement(n.p,null,"(위 문단이 이해되지 않는 사람이라면 이 글이 다소 이해하기 어려울 수도 있다. 그럴 경우 ",a.createElement(n.a,{href:"https://create-react-app.dev/docs/documentation-intro"},"create-react-app 공식 문서"),"를 참고하자.)"),"\n",a.createElement(n.p,null,"webpack 직접 설정하기 첫걸음으로, ",a.createElement(n.code,null,"resolve.alias"),"를 설정해보자."),"\n",a.createElement(n.h2,null,"2. ",a.createElement(n.code,null,"resolve.alias")," 설정하기"),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"resolve.alias")," 옵션은 ",a.createElement(n.a,{href:"https://webpack.js.org/configuration/resolve/#resolvealias"},"공식 문서")," 에서 아래와 같이 설명하고 있다."),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"Create aliases to import or require certain modules more easily.\n특정 모듈을 더욱 쉽게 import 혹은 require 하기 위해 aliases 를 생성한다."),"\n"),"\n",a.createElement(n.p,null,"말하자면 상대 경로로 불편하게 ",a.createElement(n.code,null,"import"),"해야 했던 것을 쉽게 ",a.createElement(n.code,null,"import"),"할 수 있게 해주는 옵션이다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},'/* webpack.config.js */\n\n// ...\nmodule.exports = {\n  //...\n  resolve: {\n    alias: {\n      Utilities: path.resolve(__dirname, "src/utilities/"),\n    },\n  },\n};\n\n/* someCode.js */\n\n// // 위 resolve.alias 설정이 없었다면 이렇게 import 해야 하지만\n// import Utility from \'../../utilities/utility\';\n\n// 설정 덕분에 상대 경로 없이 편하게 import 할 수 있다.\nimport Utility from "utilities/utility";\n')),"\n",a.createElement(n.p,null,"CRA로 만든 앱에서도 이 설정을 이용하고 싶다. 어떻게 하면 효율적으로 적용할 수 있을까? 일단 기존 코드를 분석해보자."),"\n",a.createElement(n.h3,null,"2.1. 기존 ",a.createElement(n.code,null,"resolve.alias")," 분석"),"\n",a.createElement(n.p,null,"CRA로 만든 앱의 기존 ",a.createElement(n.code,null,"resolve.alias")," 는 아래와 같다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},"// ...\nresolve: {\n  // ...\n  alias: {\n    // 2.1.1. 'react-native'\n    // Support React Native Web\n    'react-native': 'react-native-web',\n    // 2.1.2. profiling\n    // Allows for better profiling with ReactDevTools\n    ...(isEnvProductionProfile && {\n      'react-dom$': 'react-dom/profiling',\n      'scheduler/tracing': 'scheduler/tracing-profiling',\n    }),\n    // 2.1.3. webpackAliases\n    ...(modules.webpackAliases || {}),\n  }\n  // ...\n}\n")),"\n",a.createElement(n.h4,null,"2.1.1. ",a.createElement(n.code,null,"'react-native'")),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},"// Support React Native Web\n'react-native': 'react-native-web',\n")),"\n",a.createElement(n.p,null,"이 설정은 react-native-web을 지원하기 위한 설정이다. 지금 우리의 관심사는 아니니 넘어가자."),"\n",a.createElement(n.h4,null,"2.1.2. profiling"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},"// Allows for better profiling with ReactDevTools\n...(isEnvProductionProfile && {\n  'react-dom$': 'react-dom/profiling',\n  'scheduler/tracing': 'scheduler/tracing-profiling',\n}),\n")),"\n",a.createElement(n.p,null,"여기서 ",a.createElement(n.code,null,"isEnvProductionProfile")," 값은 아래와 같다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},'const isEnvProductionProfile =\n  isEnvProduction && process.argv.includes("--profile");\n')),"\n",a.createElement(n.p,null,"프로덕션 환경이면서, webpack 실행 당시 ",a.createElement(n.code,null,"--profile")," 옵션을 받았는지 여부를 확인하는 플래그이다."),"\n",a.createElement(n.p,null,"즉 이 웹앱의 성능 분석을 하고자 할 때 사용하는 옵션이다. 자세한 사항은 React 성능 분석 관련 공식 문서(",a.createElement(n.a,{href:"https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html"},"Introducing the React Profiler"),")를 참고하자."),"\n",a.createElement(n.h4,null,"2.1.3. ",a.createElement(n.code,null,"webpackAliases")),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},"...(modules.webpackAliases || {}),\n")),"\n",a.createElement(n.p,null,"여기서 ",a.createElement(n.code,null,"modules"),"는 아래와 같다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},'const modules = require("./modules");\n')),"\n",a.createElement(n.p,null,"그럼 ",a.createElement(n.code,null,"./modules.js")," 파일을 찾아가 ",a.createElement(n.code,null,"webpackAliases")," 값은 어떻게 지정되어 있는지 살펴보자."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},"return {\n  // ...\n  webpackAliases: getWebpackAliases(options),\n  // ...\n};\n")),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"options"),"와 ",a.createElement(n.code,null,"getWebpackAliases"),"는 뭔지 살펴보자."),"\n",a.createElement(n.h5,null,"2.1.3.1. ",a.createElement(n.code,null,"options")),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"options")," 값은 아래와 같다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},'let config;\nif (hasTsConfig) {\n  const ts = require(resolve.sync("typescript", {\n    basedir: paths.appNodeModules,\n  }));\n  config = ts.readConfigFile(paths.appTsConfig, ts.sys.readFile).config;\n} else if (hasJsConfig) {\n  /// ...\n}\nconfig = config || {};\nconst options = config.compilerOptions || {};\n')),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"tsconfig.json"),"의 ",a.createElement(n.code,null,"compilerOptions")," 값을 읽어온 것이 ",a.createElement(n.code,null,"options"),"다."),"\n",a.createElement(n.h5,null,"2.1.3.2. ",a.createElement(n.code,null,"getWebpackAliases")),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"getWebpackAliases")," 내용도 보자."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},'function getWebpackAliases(options = {}) {\n  const baseUrl = options.baseUrl;\n\n  if (!baseUrl) {\n    return {};\n  }\n\n  const baseUrlResolved = path.resolve(paths.appPath, baseUrl);\n\n  if (path.relative(paths.appPath, baseUrlResolved) === "") {\n    return {\n      src: paths.appSrc,\n    };\n  }\n}\n')),"\n",a.createElement(n.p,null,"인자로 받은 ",a.createElement(n.code,null,"options"),"에 ",a.createElement(n.code,null,"baseUrl"),"값이 있고, 해당 값이 ",a.createElement(n.code,null,"path.appPath"),"와 같으면, ",a.createElement(n.code,null,"{ src: paths.appSrc }"),"를 반환하는 함수다."),"\n",a.createElement(n.p,null,"여기서 ",a.createElement(n.code,null,"baseUrl"),"은 타입스크립트 설정에서 쓰이는 값이다. 이 값은 webpack 설정의 ",a.createElement(n.code,null,"resolve.alias"),"와 거의 같은 일을 한다. ",a.createElement(n.code,null,"import"),"할 때 상대 경로를 쓰지 않고 ",a.createElement(n.code,null,"baseUrl"),"부터 절대 경로로 쓸 수 있게끔 설정해준다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},'/* tsconfig.json */\n{\n  "compilerOptions": {\n    // ...\n    "baseUrl": "./"\n  }\n}\n\n// // 위 설정이 없었따면 아래처럼 import 해야 한다.\n// import { Button } from \'../../../components\';\n\n// 위 설정 덕에 아래처럼 import 가능하다.\nimport { Button } from \'src/components\';\n')),"\n",a.createElement(n.p,null,"문제는 webpack 도 같이 설정을 해주어야 이 기능을 제대로 쓸 수 있다는 것이다. 그래서 위에 나왔던 ",a.createElement(n.code,null,"getWebpackAliases"),"의 마지막 즈음 문장을 해석하자면"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},'if (path.relative(paths.appPath, baseUrlResolved) === "") {\n  return {\n    src: paths.appSrc,\n  };\n}\n')),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"path.appPath"),"(앱의 루트 디렉토리의 절대 경로)와 ",a.createElement(n.code,null,"baseUrlResolved"),"(",a.createElement(n.code,null,"baseUrl"),"의 절대 경로)가 같다면 ",a.createElement(n.code,null,"webpack.alias.src"),"로 쓰일 값을 ",a.createElement(n.code,null,"paths.appSrc"),"(앱의 ",a.createElement(n.code,null,"./src"),"의 절대 경로)로 해줘라, 라는 뜻이다."),"\n",a.createElement(n.p,null,"한 마디로 ",a.createElement(n.code,null,"...(modules.webpackAliases || {}),")," 이 구문은, 타입스크립트의 ",a.createElement(n.code,null,"baseUrl")," 설정값 사용을 webpack 에 적용하기 위한 설정이라고 이해하면 된다."),"\n",a.createElement(n.h4,null,"2.1.4 정리"),"\n",a.createElement(n.p,null,"정리하자면, ",a.createElement(n.code,null,"--profile")," 옵션을 주지 않고 빌드 혹은 devServer 실행을 했다고 하면 ",a.createElement(n.code,null,"resolve.alias")," 설정은 아래와 같이 된다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},"resolve: {\n  alias: {\n    'react-native': 'react-native-web',\n  }\n}\n")),"\n",a.createElement(n.p,null,"만약 여기에 ",a.createElement(n.code,null,"tsconfig.json"),"에서 ",a.createElement(n.code,null,"baseUrl")," 값을 설정해 주었다면 이렇게 설정될 것이다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},"resolve: {\n  alias: {\n    'react-native': 'react-native-web',\n    src: paths.appSrc, // `./src` 디렉토리의 절대 경로\n  }\n}\n")),"\n",a.createElement(n.h3,null,"2.2. ",a.createElement(n.code,null,"resolve.alias")," 설정 추가하기"),"\n",a.createElement(n.p,null,"그럼 이제 현재 설정을 해치지 않으면서 자연스럽게 ",a.createElement(n.code,null,"resolve.alias")," 설정을 추가해보자."),"\n",a.createElement(n.p,null,"이 글에서는 ",a.createElement(n.code,null,"./src/components")," 디렉토리와 ",a.createElement(n.code,null,"./src/themes")," 디렉토리를 alias 로 등록할 것이다."),"\n",a.createElement(n.p,null,"타입스크립트 사용 시에는 ",a.createElement(n.code,null,"tsconfig.json"),"도 같이 수정해주어야 적용이 문제 없이 되기 때문에, 위 2.1.3. 항목에서 보았던 것처럼, ",a.createElement(n.code,null,"tsconfig.json"),"을 작성하면 자동으로 webpack 설정에도 적용되게끔 진행할 것이다."),"\n",a.createElement(n.h4,null,"2.2.1. ",a.createElement(n.code,null,"tsconfig.json")," 수정"),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"compilerOptions"),"에 ",a.createElement(n.code,null,"baseUrl"),"과 ",a.createElement(n.code,null,"paths"),"를 추가해주자."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},'{\n  "compilerOptions": {\n    // ...\n    "baseUrl": "./",\n    "paths": {\n      "components": ["src/components"],\n      "themes": ["src/themes"]\n    }\n  },\n  // ...\n}\n')),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"baseUrl"),"은 위에서 한 번 설명했고, ",a.createElement(n.code,null,"paths"),"는 webpack 의 ",a.createElement(n.code,null,"resolve.alias"),"와 같은 기능이라고 생각하면 된다. (세부 사항이 좀 다르긴 한데, 자세한 내용은 이 문서",a.createElement(n.a,{href:"https://www.typescriptlang.org/docs/handbook/module-resolution.html"},"TypeScript - Module Resolution"),"를 참고하자)"),"\n",a.createElement(n.h4,null,"2.2.2. ",a.createElement(n.code,null,"config/aliases.js")," 작성"),"\n",a.createElement(n.p,null,"기존의 설정 코드는 최대한 수정하지 않는 방향으로 진행하겠다. ",a.createElement(n.code,null,"config/aliases.js"),"을 추가해서 설정을 작성하자. 기존 코드를 참고해서 작성할 것이기 때문에 코드 중복이 생기겠지만, 기존 설정 코드를 수정할 생각은 없기 때문에 코멘트만 남기는 정도로 넘어가겠다."),"\n",a.createElement(n.p,null,"우선 ",a.createElement(n.code,null,"config/modules.js"),"를 참고해서 ",a.createElement(n.code,null,"tsconfig.json")," 설정 내용을 가져오는 함수를 작성한다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},'// NOTE: duplicated with `getModules` in ./modules.js\nfunction getCompilerOptions() {\n  const hasTsConfig = fs.existsSync(paths.appTsConfig);\n\n  if (!hasTsConfig) {\n    throw new Error("You don\'t have a tsconfig.json.");\n  }\n\n  const ts = require(resolve.sync("typescript", {\n    basedir: paths.appNodeModules,\n  }));\n  const config =\n    ts.readConfigFile(paths.appTsConfig, ts.sys.readFile).config || {};\n  return config.compilerOptions || {};\n}\n')),"\n",a.createElement(n.p,null,"(타입스크립트를 쓸 것이기 때문에 자바스크립트 관련 코드는 삭제했다.)"),"\n",a.createElement(n.p,null,"가져온 ",a.createElement(n.code,null,"tsconfig.json"),"의 설정을 가지고 alias 내용을 생성하는 코드도 작성한다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-javascript"},'function getAliases() {\n  const { baseUrl, paths: tsPaths } = getCompilerOptions();\n\n  // baseUrl 값이 없으면 tsconfig.json 의 paths 가 제대로 적용되지 않는다.\n  // 따라서 해당 값으로 aliases 를 설정할 필요도 없다.\n  if (!baseUrl) {\n    return {};\n  }\n\n  const baseUrlResolved = path.resolve(paths.appPath, baseUrl);\n\n  //  앱의 루트 디렉토리와 baseUrl 이 동일한 디렉토리가 아니라면\n  // alias를 설정하지 않는다.\n  //  이는 `config/modules.js` 에서도 사용하는 예외처리인데,\n  // convention over configuration 을 따르면서\n  // 복잡한 예외 처리를 하지 않으려는 의도 같다.\n  if (path.relative(paths.appPath, baseUrlResolved) !== "") {\n    return {};\n  }\n\n  // `"components": ["src/components"],` 형태를\n  // `"components": path.resolve(__dirname, `../src/components`)`\n  // 형태로 변환\n  return Object.keys(tsPaths).reduce((cfg, key) => {\n    cfg[key] = path.resolve(__dirname, `../${tsPaths[key][0]}`);\n    return cfg;\n  }, {});\n}\n')),"\n",a.createElement(n.p,null,"이제 ",a.createElement(n.code,null,"config/modules.js")," 와 같은 방식으로 exports 해주며 마무리하면 된다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-js"},"module.exports = getAliases();\n")),"\n",a.createElement(n.h4,null,"2.2.3. ",a.createElement(n.code,null,"webpack.config.js")," 수정"),"\n",a.createElement(n.p,null,"이제 작성한 ",a.createElement(n.code,null,"config/aliases.js")," 파일을 ",a.createElement(n.code,null,"webpack.config.js")," 안에서 사용해보자."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-js"},"// 최상단의 온갖 코드를 require 하는 부분 마지막 부분에\n// 적당히 끼워넣자.\nconst tsAliases = require('./aliases');\n\n// ...\n\n// resolve.alias 부분에 설정을 추가하자\n      alias: {\n        'react-native': 'react-native-web',\n        ...(isEnvProductionProfile && {\n          'react-dom$': 'react-dom/profiling',\n          'scheduler/tracing': 'scheduler/tracing-profiling',\n        }),\n        ...(modules.webpackAliases || {}),\n        ...tsAliases, // <- 이 코드를 추가하자\n      },\n")),"\n",a.createElement(n.h2,null,"3. 결과"),"\n",a.createElement(n.p,null,"이제 ",a.createElement(n.code,null,"tsconfig.json")," 파일의 ",a.createElement(n.code,null,"compilerOptions.paths")," 값을 가지고 webpack 의 ",a.createElement(n.code,null,"resolve.alias")," 옵션을 자동 설정할 수 있게 되었다. 실제 프로젝트에 적용된 코드가 궁금하다면 아래 소스 코드들을 참고하자."),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,a.createElement(n.a,{href:"https://github.com/ricale/ricale.github.io/blob/develop/tsconfig.json"},"ricale.github.io/tsconfig.json")),"\n",a.createElement(n.li,null,a.createElement(n.a,{href:"https://github.com/ricale/ricale.github.io/blob/develop/config/aliases.js"},"ricale.github.io/config/aliases.js")),"\n"))}var r,s=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?a.createElement(n,e,a.createElement(c,e)):c(e)},o=l(1880),i=l(1883),m=l(3723),p=l(1858),u=l(3904),E=l(891),d=l(5534);const g=e=>{let{data:n,children:l}=e;const{title:t,date:c,tags:r,heroImage:s,heroImageAlt:o}=n.mdx.frontmatter,u=s?(0,m.c)(s):null;return console.log("image",u),a.createElement(p.Z,null,a.createElement("h1",null,t),a.createElement(h,null,r.map((e=>a.createElement("li",{key:e},a.createElement(i.rU,{to:"/tags/"+e},e))))),a.createElement("div",null,c),!!u&&a.createElement(m.G,{image:u,alt:null!=o?o:""}),a.createElement(d.Z,null,l))},h=E.ZP.ul(r||(r=(0,o.Z)(["\n  display: flex;\n  flex-direction: row;\n  flex-wrap: wrap;\n  gap: ","px;\n\n  margin: 0;\n  padding: 0;\n  list-style: none;\n\n  > li {\n    padding: ","px ","px\n      0px;\n    border-radius: 2px;\n\n    background-color: ",";\n    color: ",";\n\n    > a {\n      text-decoration: none;\n    }\n  }\n"])),(e=>e.theme.dimens.gutter),(e=>e.theme.dimens.thin),(e=>e.theme.dimens.gutter),(e=>e.theme.colors.tag),(e=>e.theme.colors.onTag)),f=e=>{var n,l;let{data:t}=e;const{frontmatter:{title:c,slug:r,heroImage:s},excerpt:o}=t.mdx,i=s?(0,m.c)(s):null;return a.createElement(u.Z,{title:c,og:{title:c,path:r,type:"article",description:o,image:null==i||null===(n=i.images)||void 0===n||null===(l=n.fallback)||void 0===l?void 0:l.src}})};function v(e){return a.createElement(g,e,a.createElement(s,e))}}}]);
//# sourceMappingURL=component---src-pages-posts-mdx-frontmatter-slug-tsx-content-file-path-users-kangseong-workspace-private-ricalelog-posts-210505-cra-webpack-1-resolve-alias-index-mdx-3a992433e12ef5c72cc5.js.map